[[chap07]]
== Iteración

Este capítulo se centra en la iteración, que es la capacidad de ejecutar repetidamente un bloque de sentencias. Hemos visto dos tipos de iteración: usando recursión en <<recursion>>, y usando ciclos +for+, en <<simple_repetition>>. En este capítulo veremos otro tipo más: usando sentencias +while+. Primeramente, se introducirán algunos términos sobre asignación de variables.
(((iteration)))(((recursion)))(((for statement)))

=== Asignación múltiple

Puede que ya haya descubierto que está permitido realizar más de una asignación a la misma variable. Una nueva asignación hace que la variable existente se refiera a un nuevo valor (y deje de referirse al viejo valor).

[source,@julia-repl-test chap07]
----
julia> x = 5
5
julia> x = 7
7
----

La primera vez que se muestra +x+ su valor es 5, y la segunda vez su valor es 7

[[fig07-1]]
.State diagram
image::images/fig71.svg[]

<<fig07-1>> muestra el aspecto de una _asignación múltiple_ en un diagrama de estado.
(((reassignment)))(((state diagram)))

Es necesario aclarar algo que puede causar confusión. Puesto que Julia usa el signo igual (+=+) para la asignación, es tentador interpretar una sentencia +a = b+ como una sentencia de igualdad. Pero esta interpretación es incorrecta.
(((assignment statement)))

Para empezar, la igualdad es simétrica y la asignación no lo es. Por ejemplo, en matemáticas, si latexmath:[\(a=7\)] entonces latexmath:[\(7=a\)]. Pero en Julia la sentencia +a = 7+ es válida, y +7 = a+ no lo es.

Además, en matemáticas, una sentencia de igualdad es verdadera o falsa siempre. Si latexmath:[\(a=b\)] ahora, entonces latexmath:[\(a\)] siempre será igual a latexmath:[\(b\)]. En Julia, una sentencia de asignación puede hacer que dos variables sean iguales, pero no tienen por qué quedarse así:

[source,@julia-repl-test]
----
julia> a = 5
5
julia> b = a    # a y b son iguales 
5
julia> a = 3    # a y b ya no son iguales 
3
julia> b
5
----

La tercera línea cambia el valor de +a+ pero no cambia el valor de +b+, por lo tanto ya dejan de ser iguales. 

[WARNING]
====
Reasignar variables puede ser útil, pero se debe tener precaución. Si los valores cambian frecuentemente, la reasignación puede hacer que el código sea difícil de leer y depurar.

Está permitido definir una función con el mismo nombre de una variable definida anteriormente.
====


=== Actualización de variables

Una de las formas más comunes de asignación múltiple es la actualización, donde el nuevo valor de la variable depende del anterior.
(((update)))

[source,@julia-repl-test chap07]
----
julia> x = x + 1
8
----

Esto significa “tome el valor actual de +x+, súmele uno, y después actualice +x+ con el nuevo valor.”

Si intenta actualizar una variable que no existe obtendrá un error, puesto que Julia evalúa la expresión del lado derecho antes de asignar un valor a +x+:
(((UndefVarError)))

[source,@julia-repl-test]
----
julia> y = y + 1
ERROR: UndefVarError: y not defined
----

Antes de actualizar una variable tiene que inicializarla, usualmente con una asignación simple:
(((initialization)))

[source,@julia-repl-test]
----
julia> y = 0
0
julia> y = y + 1
1
----

Actualizar una variable sumándole 1 de denomina un _incremento_; y restándole 1 de llama un _decremento_.
(((increment)))(((decrement)))

=== La Sentencia +while+

Las computadoras se usan a menudo para automatizar tareas repetitivas. Realizar repetidamente tareas idénticas o similares sin cometer errores es algo que las computadoras hacen bien y que los seres humanos hacemos limitadamente. La ejecución repetida de un conjunto de sentencias se llama _iteración_. 
(((iteration)))

Ya hemos visto dos funciones, +cuenta regresiva+ y +printn+, que iteran usando recursividad. Por ser la iteración tan común, Julia proporciona varias características que la hacen más fácil. Una es la sentencia +for+ que vimos en <<simple_repetition>>, a la cual volveremos más adelante. 
(((recursion)))(((for statement)))

Otra característica es la _sentencia_ +while+. Aquí hay una versión de +cuentaregresiva+ que muestra el uso de la sentencia +while+:
(((while)))((("keyword", "while", see="while")))(((while statement)))((("statement", "while", see="while statement")))

[source,@julia-setup]
----
function cuentaregresiva(n)
    while n > 0
        print(n, " ")
        n = n - 1
    end
    println("¡Despegue!")
end
----

Casi podría leer la sentencia while como si fuera Español. La función anterior significa: “Mientras +n+ sea mayor que 0, continúe mostrando el valor de +n+ y luego reduciendo el valor de +n+ en 1. Cuando llegue a 0, muestre la palabra ¡Despegue!“
(((countdown)))

Más formalmente, el flujo de ejecución de una sentencia +while+ es el siguiente:
(((flow of execution)))

. Se determina si la condición es verdadera o falsa.

. Si es falsa, se sale de la sentencia while y continúa la ejecución con la siguiente sentencia.

. Si es verdadera, ejecuta cada una de las sentencias en el cuerpo y regresa al paso 1.

Este tipo de flujo de llama bucle porque el tercer paso vuelve a la parte superior.
(((loop)))

El cuerpo del bucle debería cambiar el valor de una o más variables de manera que, en algún momento, la condición sea falsa y el bucle termine. En caso contrario, el bucle se repetirá indefinidamente, lo cual se llama _bucle infinito_. Una interminable fuente de diversión para los informáticos es la observación de que las instrucciones del champú “Enjabone, enjuague, repita”, son un bucle infinito.
(((infinite loop)))

En el caso de +cuentaregresiva+, podemos probar que el bucle termina: si +n+ es cero o negativo, el ciclo no se produce. En otro caso, el valor de +n+ se hace más pequeño cada vez que pasa por el bucle, así en cierto momento llegaremos a 0. 

En otros casos no es tan fácil decirlo. Por ejemplo:
(((seq)))((("function", "programmer-defined", "seq", see="seq")))

[source,@julia-setup]
----
function seq(n)
    while n != 1
        println(n)
        if n % 2 == 0        # n is par
            n = n / 2
        else                 # n is impar
            n = n*3 + 1
        end
    end
end
----

La condición de este bucle es +n != 1+, de manera que el bucle continuará hasta que +n+ sea 1, que hará que la condición sea falsa.

Cada vez que pasa por el bucle, el programa muestra como salida el valor de +n+ y luego comprueba si es par o impar. Si es par, el valor de +n+ se divide por dos. Si es impar, el valor de +n+ se sustituye por +pass:[n*3 + 1]+. Por ejemplo, si el argumento pasado a la función seq es 3, los valores resultantes +n+ son 3, 10, 5, 16, 8, 4, 2, 1.

Puesto que n a veces aumenta y a veces disminuye, no hay una prueba obvia de que +n+ alcanzará alguna vez el valor 1, o de que el programa vaya a terminar. Para algunos valores particulares de +n+, podemos probar que sí termina. Por ejemplo, si el valor de inicio es una potencia de dos, entonces el valor de +n+ será par cada vez que se pasa por el bucle, hasta que llegue a 1. El ejemplo anterior produce dicha secuencia si se inicia con 16.

Lo díficil es preguntarnos si se puede probar que este programa termina para todos los valores positivos de +n+. Hasta ahora, nadie ha sido capaz de probar que lo hace o ¡que no lo hace! (Vea https://en.wikipedia.org/wiki/Collatz_conjecture.)
(((Collatz conjecture)))

===== Ejercicio 7-1

Reescribe la función +printn+ de <<recursion>> utilizando iteración en vez de recursión.

=== +break+

A veces no se sabe que un ciclo debe terminar hasta que se llega al cuerpo. En ese caso, se puede usar la _sentencia break_ para salir del bucle.
(((break)))((("keyword", "break", see="break")))(((break statement)))((("statement", "break", see="break statement")))

Por ejemplo, suponga que se desea recibir entradas del usuario hasta que este escriba "listo". Podríamos escribir:
(((readline)))

[source,julia]
----
while true
    print("> ")
    linea = readline()
    if line == "listo"
        break
    end
    println(linea)
end
println("¡Listo!")
----

La condición del bucle es +true+, que siempre es verdadero, por lo que el bucle se ejecuta hasta que llega a la sentencia break.

En cada iteración, se le pide al usuario (con el símbolo "> ") una entrada. Si el usuario escribe +listo+, la sentencia break sale del bucle. De lo contrario, el programa repite lo que escriba el usuario y vuelve a la parte superior del bucle. A continuación se muestra cómo funciona este programa:

[source]
----
> no listo
no listo
> listo
¡Listo!
----

Esta forma de escribir bucles while es común porque permite verificar la condición en cualquier parte del bucle (no solo en la parte superior) y puede expresar la condición de término de manera afirmativa ("detenerse cuando esto suceda"), en vez de negativamente ("continuar hasta que esto suceda").

=== +continue+

La sentencia break permite terminar el bucle. Cuando aparece una _sentencia continue_ dentro de un bucle, se regresa al comienzo del bucle, ignorando todos las sentencias que quedan en la iteración actual del bucle e inicia la siguiente iteración. Por ejemplo:
(((continue)))((("keyword", "continue", see="continue")))(((continue statement)))((("statement", "continue", see="continue statement")))

[source,@julia]
----
for i in 1:10
    if i % 3 == 0
        continue
    end
    print(i, " ")
end
----

Si +i+ es divisible por 3, la sentencia continue detiene la iteración actual y comienza la siguiente iteración. Solo se imprimen los números en el rango de 1 a 10 no divisibles por 3.

[[square_roots]]
=== Raíces Cuadradas

Los bucles se usan a menudo en programas que calculan resultados numéricos empezando con una respuesta aproximada, mejorando iterativamente.

Por ejemplo, una forma de calcular raíces cuadradas es el método de Newton. Suponga que desea conocer la raíz cuadrada de latexmath:[\(a\)]. Si comienza con casi cualquier estimación latexmath:[\(x\)], se puede obtener una mejora con la siguiente fórmula:
(((Newton's method)))

[latexmath]
++++
\begin{equation}
{y = \frac{1}{2}\left(x + \frac{a}{x}\right)}
\end{equation}
++++

Por ejemplo, si latexmath:[\(a\)] es 4 y latexmath:[\(x\)] es 3:

[source,@julia-repl-test chap07]
----
julia> a = 4
4
julia> x = 3
3
julia> y = (x + a/x) / 2
2.1666666666666665
----

El resultado está más cerca de la respuesta correcta (latexmath:[\(\sqrt 4 = 2\)]). Si repetimos el proceso con la nueva estimación, se acerca aún más:

[source,@julia-repl-test chap07]
----
julia> x = y
2.1666666666666665
julia> y = (x + a/x) / 2
2.0064102564102564
----

Después de algunas actualizaciones, la estimación es casi exacta:

[source,@julia-repl-test chap07]
----
julia> x = y
2.0064102564102564
julia> y = (x + a/x) / 2
2.0000102400262145
julia> x = y
2.0000102400262145
julia> y = (x + a/x) / 2
2.0000000000262146
----

En general, no sabemos de antemano cuántos pasos se necesitan para llegar a la respuesta correcta, pero sabemos cuándo hemos llegado a ella pues la estimación deja de cambiar:

[source,@julia-repl-test chap07]
----
julia> x = y
2.0000000000262146
julia> y = (x + a/x) / 2
2.0
julia> x = y
2.0
julia> y = (x + a/x) / 2
2.0
----

When +y == x+, we can stop. Here is a loop that starts with an initial estimate, +x+, and improves it until it stops changing:

[source,julia]
----
while true
    println(x)
    y = (x + a/x) / 2
    if y == x
        break
    end
    x = y
end
----

For most values of a this works fine, but in general it is dangerous to test float equality. Floating-point values are only approximately right: most rational numbers, like latexmath:[\(\frac{1}{3}\)], and irrational numbers, like latexmath:[\(\sqrt 2\)], can’t be represented exactly with a +Float64+.

Rather than checking whether +x+ and +y+ are exactly equal, it is safer to use the built-in function +abs+ to compute the absolute value, or magnitude, of the difference between them:
(((abs)))

[source,julia]
----
if abs(y-x) < ε
    break
end
----

Where +ε+ (*+\varepsilon TAB+*) has a value like +0.0000001+ that determines how close is close enough.


=== Algorithms

Newton’s method is an example of an _algorithm_: it is a mechanical process for solving a category of problems (in this case, computing square roots).
(((algorithm)))

To understand what an algorithm is, it might help to start with something that is not an algorithm. When you learned to multiply single-digit numbers, you probably memorized the multiplication table. In effect, you memorized 100 specific solutions. That kind of knowledge is not algorithmic.

But if you were “lazy”, you might have learned a few tricks. For example, to find the product of latexmath:[\(n\)] and 9, you can write latexmath:[\(n-1\)] as the first digit and latexmath:[\(10-n\)] as the second digit. This trick is a general solution for multiplying any single-digit number by 9. That’s an algorithm!

Similarly, the techniques you learned for addition with carrying, subtraction with borrowing, and long division are all algorithms. One of the characteristics of algorithms is that they do not require any intelligence to carry out. They are mechanical processes where each step follows from the last according to a simple set of rules.

Executing algorithms is boring, but designing them is interesting, intellectually challenging, and a central part of computer science.

Some of the things that people do naturally, without difficulty or conscious thought, are the hardest to express algorithmically. Understanding natural language is a good example. We all do it, but so far no one has been able to explain _how_ we do it, at least not in the form of an algorithm.


=== Debugging

As you start writing bigger programs, you might find yourself spending more time debugging. More code means more chances to make an error and more places for bugs to hide.
(((debugging)))

One way to cut your debugging time is “debugging by bisection”. For example, if there are 100 lines in your program and you check them one at a time, it would take 100 steps.
(((debugging by bisection)))

Instead, try to break the problem in half. Look at the middle of the program, or near it, for an intermediate value you can check. Add a print statement (or something else that has a verifiable effect) and run the program.
(((print statement)))

If the mid-point check is incorrect, there must be a problem in the first half of the program. If it is correct, the problem is in the second half.

Every time you perform a check like this, you halve the number of lines you have to search. After six steps (which is fewer than 100), you would be down to one or two lines of code, at least in theory.

In practice it is not always clear what the “middle of the program” is and not always possible to check it. It doesn’t make sense to count lines and find the exact midpoint. Instead, think about places in the program where there might be errors and places where it is easy to put a check. Then choose a spot where you think the chances are about the same that the bug is before or after the check.


=== Glossary

reassignment::
Assigning a new value to a variable that already exists.
(((reassignment)))

update::
An assignment where the new value of the variable depends on the old.
(((update)))

initialization::
An assignment that gives an initial value to a variable that will be updated.
(((initialization)))

increment::
An update that increases the value of a variable (often by one).
(((increment)))

decrement::
An update that decreases the value of a variable.
(((decrement)))

iteration::
Repeated execution of a set of statements using either a recursive function call or a loop.
(((iteration)))

while statement::
Statement that allows iterations controlled by a condition.
(((while statement)))

break statement::
Statement allowing to jump out of a loop.
(((break statement)))

continue statement::
Statement inside a loop that jumps to the beginning of the loop for the next iteration.
(((continue statement)))

infinite loop::
A loop in which the terminating condition is never satisfied.
(((infinite loop)))

algorithm::
A general process for solving a category of problems.
(((algorithm)))


=== Exercises

[[ex07-1]]
===== Exercise 7-2

Copy the loop from <<square_roots>> and encapsulate it in a function called +mysqrt+ that takes +a+ as a parameter, chooses a reasonable value of +x+, and returns an estimate of the square root of +a+.
(((mysqrt)))((("function", "programmer-defined", "mysqrt", see="mysqrt")))

To test it, write a function named +testsquareroot+ that prints a table like this:
(((testsquareroot)))((("function", "programmer-defined", "testsquareroot", see="testsquareroot")))

[source,@julia-eval]
----
using ThinkJulia
io = IOBuffer()
testsquareroot(io)
out = String(take!(io))
println(out)
----

The first column is a number, +a+; the second column is the square root of a computed with +mysqrt+; the third column is the square root computed by +sqrt+; the fourth column is the absolute value of the difference between the two estimates.

[[ex07-2]]
===== Exercise 7-3

The built-in function +Meta.parse+ takes a string and transforms it into an expression. This expression can be evaluated in Julia with the function +Core.eval+. For example:
(((parse)))((("function", "Meta", "parse", see="parse")))(((eval)))((("function", "Core", "eval", see="eval")))

[source,@julia-eval chap07]
----
import Base.eval
----

[source,@julia-repl-test chap07]
----
julia> expr = Meta.parse("1+2*3")
:(1 + 2 * 3)
julia> eval(expr)
7
julia> expr = Meta.parse("sqrt(π)")
:(sqrt(π))
julia> eval(expr)
1.7724538509055159
----

Write a function called +evalloop+ that iteratively prompts the user, takes the resulting input and evaluates it using +eval+, and prints the result. It should continue until the user enters +done+, and then return the value of the last expression it evaluated.

(((evalloop)))((("function", "programmer-defined", "evalloop", see="evalloop")))

[[ex07-3]]
===== Exercise 7-4

The mathematician Srinivasa Ramanujan found an infinite series that can be used to generate a numerical approximation of latexmath:[\(\frac{1}{\pi}\)]:

[latexmath]
++++
\begin{equation}
{\frac{1}{\pi}=\frac{2\sqrt2}{9801}\sum_{k=0}^\infty\frac{(4k)!(1103+26390k)}{(k!)^4 396^{4k}}}
\end{equation}
++++

Write a function called +estimatepi+ that uses this formula to compute and return an estimate of π. It should use a while loop to compute terms of the summation until the last term is smaller than +1e-15+ (which is Julia notation for latexmath:[\(10^{-15}\)]). You can check the result by comparing it to +π+.
(((estimatepi)))((("function", "programmer-defined", "estimatepi", see="estimatepi")))
