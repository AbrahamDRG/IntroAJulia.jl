[[chap04]]
== Estudio de Caso: Diseño de Interfaz

Este capítulo presenta un segundo estudio de caso, que muestra el proceso de diseñar funciones que trabajen en conjunto.

Se presentan gráficos turtle, que es una forma de crear dibujos a través de la programación. Los gráficos turtle no están incluidos en la Biblioteca Estándar, por lo que se debe agregar el módulo PiensaEnJulia a su configuración de Julia.

Los ejemplos de este capítulo se pueden ejecutar en un notebook gráfico en JuliaBox, el cual combina código, texto formateado, matemáticas y multimedia en un solo documento (vea <<juliabox>>).
(((JuliaBox, graphical notebook)))


=== Turtles

Un _modulo_ es un archivo que contiene una colección de funciones relacionadas. Julia proporciona algunos módulos en su Biblioteca Estándar. Además, es posible agregar más funciones a una gran cantidad de _paquetes_ (https://juliaobserver.com).
(((module)))(((package)))

Los paquetes se pueden instalar en REPL ingresando al modo Pkg REPL con la tecla +]+.
(((pass:[&#93;])))(((PiensaEnJulia)))((("module", "PiensaEnJulia", see="PiensaEnJulia")))

[source,jlcon]
----
(v1.2) pkg> add https://github.com/PiensaEnJulia/PiensaEnJulia.jl
----

Esto puede demorar un poco.

Antes de que podamos usar las funciones de un módulo, tenemos que importarlo con una sentencia +using+:
(((using)))((("keyword", "using", see="using")))(((using statement)))((("statement", "using", see="using statement")))

[source,@julia-repl-test]
----
julia> using PiensaEnJulia

julia> 🐢 = Turtle()
Luxor.Turtle(0.0, 0.0, true, 0.0, (0.0, 0.0, 0.0))
----

El módulo +PiensaEnJulia+ proporciona una función llamada +Turtle+ (tortuga en español) que crea un objeto +Luxor.Turtle+, el cual asignamos a una variable llamada +🐢+ (*+\:turtle: TAB+*).
(((Turtle)))((("type", "Luxor", "Turtle", see="Turtle")))

Una vez que crea una tortuga, puede llamar a una función para "moverla", y así hacer un dibujo con ella. Por ejemplo, para mover la tortuga hacia adelante (forward en inglés):
(((forward)))((("function", "PiensaEnJulia", "forward", see="forward")))

[source,julia]
----
@svg begin
    forward(🐢, 100)
end
----

[[fig04-1]]
.Moving the turtle forward
image::images/fig41.svg[]


La palabra reservada +@svg+ ejecuta una macro que dibuja una imagen SVG. Las macros son una característica importante pero avanzada de Julia.
(((@svg)))((("macro", "Luxor", "@svg", see="@svg")))(((macro)))(((SVG picture)))

Los argumentos de +forward+ son la tortuga y una distancia en píxeles, por lo que el tamaño real depende de su pantalla.

También es posible hacer girar a la tortuga con la función +turn+. Los argumentos de esta función son la tortuga y un ángulo en grados.
(((turn)))((("function", "PiensaEnJulia", "turn", see="turn")))

Además, cada tortuga está sosteniendo un lápiz, que puede estar hacia arriba o hacia abajo; si el lápiz está hacia abajo, la tortuga deja un rastro cuando se mueve. <<fig04-1>> muestra el rastro dejado por la tortuga. Las funciones +penup+ y +pendown+ significan "lápiz hacia arriba" y "lápiz hacia abajo".
(((penup)))((("function", "PiensaEnJulia", "penup", see="penup")))(((pendown)))((("function", "PiensaEnJulia", "pendown", see="pendown")))

Para dibujar un ángulo recto, modifique la llamada a la macro:

[source,julia]
----
🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end
----

==== Ejercicio 4-1

Ahora modifique la macro para que dibuje un cuadrado. ¡No sigas hasta haberlo terminado!


[[simple_repetition]]
=== Repetición Simple

Es probable que hayas escrito algo como esto:
(((repetition)))

[source,julia]
----
🐢 = Turtle()
@svg begin
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
    turn(🐢, -90)
    forward(🐢, 100)
end
----

Podemos hacer lo mismo de manera más concisa con una sentencia +for+:
(((for statement)))((("statement", "for", see="for statement)))(((for)))((("keyword", "for", see="for")))(((in)))((("keyword", "in", see="in")))

[source,@julia-repl-test]
----
julia> for i in 1:4
          println("¡Hola!")
       end
¡Hola!
¡Hola!
¡Hola!
¡Hola!
----

Este es el uso más simple de la sentencia +for+; veremos más usos después. Pero esto debería ser suficiente para reescribir su programa que dibuja un cuadrado. No continúes hasta que lo hagas.

Aquí hay una sentencia +for+ que dibuja un cuadrado:

[source,julia]
----
🐢 = Turtle()
@svg begin
    for i in 1:4
        forward(🐢, 100)
        turn(🐢, -90)
    end
end
----

La sintaxis de una sentencia +for+ es similar a la definición de una función. Tiene un encabezado y un cuerpo que termina con la palabra reservada +end+. El cuerpo puede contener el número de sentencias que desee.
(((end)))

Una sentencia +for+ también es llamada _bucle_ porque el flujo de ejecución recorre el cuerpo y luego vuelve a la parte superior. En este caso, ejecuta el cuerpo cuatro veces.
(((loop)))

Esta versión es en realidad un poco diferente del código anterior que dibujaba un cuadrado porque hace otro giro después de dibujar el último lado del cuadrado. El giro adicional lleva más tiempo, pero simplifica el código si hacemos lo mismo en cada iteración del ciclo. Esta versión también tiene el efecto de dejar a la tortuga nuevamente en la posición inicial, mirando hacia la dirección inicial.

=== Ejercicios

Los siguientes ejercicios usan tortugas. Son divertidos, pero también tienen un trasfondo. Mientras trabaja en ellos, piense cuál es este trasfondo.

[TIP]
====
Las siguientes secciones muestran las soluciones para estos ejercicios, así que no mire hasta que haya terminado (o al menos lo haya intentado).
====

[[ex04-1]]
==== Ejercicio 4-2

Escriba una función llamada +cuadrado+ que tome como parámetro a un turtle +t+. Debería usar este turtle para dibujar un cuadrado.

[[ex04-2]]
==== Ejercicio 4-3

Escriba una llamada a función que pase +t+ como argumento a +cuadrado+, y luego vuelva a ejecutar la macro.

[[ex04-3]]
==== Ejercicio 4-4

Agregue otro parámetro, llamado +lon+, a cuadrado. Modifique el cuerpo para que la longitud de los lados sea +lon+, y luego modifique la llamada a función agregando este segundo argumento. Ejecute la macro nuevamente. Prueba con un rango de valores para +lon+.

[[ex04-4]]
==== Ejercicio 4-5

Haga una copia de +cuadrado+ y cambie su nombre a +polígono+. Agregue otro parámetro llamado +n+ y modifique el cuerpo para que dibuje un polígono regular de latexmath:[\(n\)]-lados.

[TIP]
====
Los ángulos exteriores de un polígono regular de latexmath:[\(n\)]-lados son latexmath:[\(\frac{360}{n}\)] grados.
====

[[ex04-5]]
==== Ejercicio 4-6

Escriba una función llamada +círculo+ que tome un turtle +t+, y un radio +r+ como parámetros, y que dibuje un círculo aproximado llamando a +polígono+ con una longitud y número de lados apropiados. Pruebe su función con un rango de valores de +r+.

[TIP]
====
Calcule la circunferencia del círculo y asegúrese de que +len * n == circunferencia+.
====

[[ex04-6]]
==== Ejercicio 4-7

Haga una versión más general de +circulo+ llamada +arco+ que tome un parámetro adicional +angulo+, que determina qué fracción de un círculo dibujar. +angulo+ está en grados, entonces cuando +angulo= 360+, +arco+ debería dibujar un círculo completo.


=== Encapsulación

El primer ejercicio le pide que coloque el código que permite dibujar un cuadrado en una definición de función, y que luego llame a la función, pasando a turtle como parámetro. Aquí hay una solución:
(((square)))((("function", "programmer-defined", "square", see="square")))

[source,julia]
----
function cuadrado(t)
    for i in 1:4
        forward(t, 100)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    cuadrado(🐢)
end
----

Las sentencias más internas, +forward+ y +turn+ tienen doble sangría para mostrar que están dentro del bucle +for+, que a su vez está dentro de la definición de función.
(((indentation)))

Dentro de la función, +t+ se refiere a la misma tortuga +🐢+, entonces +turn(t, -90)+ tiene el mismo efecto que +turn(🐢, -90)+. En ese caso, ¿por qué no llamar al parámetro +🐢+? La razón es que +t+ puede ser cualquier tortuga, no solo +🐢+, por lo que podríamos crear una segunda tortuga y pasarla como argumento a +cuadrado+:

[source,julia]
----
🐫 = Turtle()
@svg begin
    cuadrado(🐫)
end
----

Colocar una porción de código en una función se denomina _encapsulación_. Uno de los beneficios de la encapsulación es que al ponerle un nombre al código, esto sirve como una especie de documentación. Otra ventaja es que si reutiliza el código, ¡es más conciso llamar a una función dos veces que copiar y pegar el cuerpo!
(((encapsulation)))


=== Generalización

El siguiente paso es agregar un parámetro +lon+ a +cuadrado+. Aquí hay una solución:
(((square)))

[source,julia]
----
function cuadrado(t, lon)
    for i in 1:4
        forward(t, lon)
        turn(t, -90)
    end
end
🐢 = Turtle()
@svg begin
    cuadrado(🐢, 100)
end
----

Agregar un parámetro a una función se llama _generalización_ porque hace que la función sea más general: en la versión anterior, el cuadrado siempre tenía el mismo tamaño; en esta versión puede ser de cualquier tamaño.
(((generalization)))

El siguiente paso también es una generalización. En vez de dibujar cuadrados, +poligono+ dibuja polígonos regulares con cualquier número de lados. Aquí hay una solución:
(((polygon)))((("function", "programmer-defined", "polygon", see="polygon")))

[source,julia]
----
function poligono(t, n, lon)
    angulo = 360 / n
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
🐢 = Turtle()
@svg begin
    poligono(🐢, 7, 70)
end
----

Este ejemplo dibuja un polígono de 7 lados, con una longitud de 70 por lado.


=== Diseño de Interfaz

El siguiente paso es escribir +circulo+, que toma un radio +r+ como parámetro. Aquí hay una solución simple que usa +poligono+ para dibujar un polígono de 50 lados:
(((circle)))((("function", "programmer-defined", "circle", see="circle")))

[source,julia]
----
function circulo(t, r)
    circunferencia = 2 * π * r
    n = 50
    len = circunferencia / n
    poligono(t, n, lon)
end
----

La primera línea calcula la circunferencia de un círculo con radio latexmath:[\(r\)] usando la fórmula latexmath:[\(2 \pi r\)]. +n+ es el número de segmentos de línea de nuestra aproximación a un círculo, y +len+ es la longitud de cada segmento. Por lo tanto, +polígono+ dibuja un polígono de 50 lados que se aproxima a un círculo de radio +r+.

Una limitante de esta solución es que +n+ es constante, lo que significa que para círculos muy grandes, los segmentos de línea son demasiado largos, y para círculos pequeños, perdemos tiempo dibujando segmentos muy pequeños. Una solución sería generalizar la función tomando +n+ como parámetro. Esto le daría al usuario (quien llama a círculo) más control, pero la interfaz sería menos pulcra.

La _interfaz_ de una función es un resumen de cómo se usa: ¿cuáles son los parámetros? ¿Qué hace la función? ¿Y cuál es el valor de retorno? Una interfaz es "pulcra" si le permite al usuario que la llama hacer lo que quiera sin tener que lidiar con detalles innecesarios.
(((interface)))

En este ejemplo, +r+ pertenece a la interfaz porque especifica el círculo a dibujar. +n+ es menos apropiado porque se refiere a los detalles de cómo se debe representar el círculo.

En lugar de saturar la interfaz, es mejor elegir un valor apropiado de +n+ dependiendo de la +circunferencia+:

[source,julia]
----
function circulo(t, r)
    circunferencia = 2 * π * r
    n = trunc(circunferencia / 3) + 3
    len = circunferencia / n
    poligono(t, n, len)
end
----

Ahora, el número de segmentos es un número entero cercano a +circunferencia/3+, por lo que la longitud de cada segmento es aproximadamente 3, que es lo suficientemente pequeño como para que los círculos se vean bien, pero lo suficientemente grandes como para ser eficientes y aceptables para cualquier círculo.

Agregar 3 a +n+ garantiza que el polígono tenga al menos 3 lados.


[[refactoring]]
=== Refactorización

Cuando escribimos +circulo+, pudimos reutilizar +poligono+ ya que un polígono de muchos lados es una buena aproximación de un círculo. Pero +arco+ no es tan versatil; no podemos usar +poligono+ o +circulo+ para dibujar un arco.

Una alternativa es comenzar con una copia de +poligono+ y transformarla en +arco+. El resultado podría verse así:
(((arc)))((("function", "programmer-defined", "arc", see="arc")))

[source,julia]
----
function arco(t, r, angulo)
    arco_lon = 2 * π * r * angulo / 360
    n = trunc(arco_lon / 3) + 1
    paso_lon = arco_lon / n
    paso_angulo = angulo / n
    for i in 1:n
        forward(t, paso_lon)
        turn(t, -paso_angulo)
    end
end
----

La segunda mitad de esta función se parece a +poligono+, pero no podemos reutilizar +poligono+ sin cambiar la interfaz. Podríamos generalizar +poligono+ para tomar un +angulo+ como tercer argumento, ¡pero entonces +poligono+ ya no sería un nombre apropiado! En su lugar, llamemos a esta función más general +polilinea+:
(((polyline)))((("function", "programmer-defined", "polyline", see="polyline")))

[source,julia]
----
function polilinea(t, n, lon, angulo)
    for i in 1:n
        forward(t, lon)
        turn(t, -angulo)
    end
end
----

Now we can rewrite +polygon+ and +arc+ to use +polyline+:
(((polygon)))(((arc)))

[source,julia]
----
function polygon(t, n, len)
    angle = 360 / n
    polyline(t, n, len, angle)
end

function arc(t, r, angle)
    arc_len = 2 * π * r * angle / 360
    n = trunc(arc_len / 3) + 1
    step_len = arc_len / n
    step_angle = angle / n
    polyline(t, n, step_len, step_angle)
end
----

Finally, we can rewrite +circle+ to use +arc+:
(((circle)))

[source,julia]
----
function circle(t, r)
    arc(t, r, 360)
end
----

This process—rearranging a program to improve interfaces and facilitate code re-use—is called _refactoring_. In this case, we noticed that there was similar code in +arc+ and +polygon+, so we “factored it out” into +polyline+.
(((refactoring)))

If we had planned ahead, we might have written +polyline+ first and avoided refactoring, but often you don’t know enough at the beginning of a project to design all the interfaces. Once you start coding, you understand the problem better. Sometimes refactoring is a sign that you have learned something.


=== A Development Plan

A _development plan_ is a process for writing programs. The process we used in this case study is “encapsulation and generalization”. The steps of this process are:
(((program development plan)))

. Start by writing a small program with no function definitions.

. Once you get the program working, identify a coherent piece of it, encapsulate the piece in a function and give it a name.

. Generalize the function by adding appropriate parameters.

. Repeat steps 1–3 until you have a set of working functions. Copy and paste working code to avoid retyping (and re-debugging).

. Look for opportunities to improve the program by refactoring. For example, if you have similar code in several places, consider factoring it into an appropriately general function.

This process has some drawbacks—we will see alternatives later—but it can be useful if you don’t know ahead of time how to divide the program into functions. This approach lets you design as you go along.


=== Docstring

A _docstring_ is a string before a function that explains the interface (“doc” is short for “documentation”). Here is an example:
(((docstring)))(((triple quotes)))((("pass:[&quot;&quot;&quot;]", see="triple quotes")))

[source,julia]
----
"""
polyline(t, n, len, angle)

Draws n line segments with the given length and
angle (in degrees) between them.  t is a turtle.
"""
function polyline(t, n, len, angle)
    for i in 1:n
        forward(t, len)
        turn(t, -angle)
    end
end
----

Documentation can be accessed in the REPL or in a notebook by typing ? followed by the name of a function or macro, and pressing +ENTER+:
(((help)))((("?", see="help")))

----
help?> polyline
search:

  polyline(t, n, len, angle)

  Draws n line segments with the given length and angle (in degrees) between them. t is a turtle.
----

Docstrings are often triple-quoted strings, also known as multiline strings because the triple quotes allow the string to span more than one line.

A docstring contains the essential information someone would need to use this function. It explains concisely what the function does (without getting into the details of how it does it). It explains what effect each parameter has on the behavior of the function and what type each parameter should be (if it is not obvious).

[TIP]
====
Writing this kind of documentation is an important part of interface design. A well-designed interface should be simple to explain; if you have a hard time explaining one of your functions, maybe the interface could be improved.
====


=== Debugging

An interface is like a contract between a function and a caller. The caller agrees to provide certain parameters and the function agrees to do certain work.
(((debugging)))

For example, +polyline+ requires four arguments: +t+ has to be a turtle; +n+ has to be an integer; +len+ should be a positive number; and +angle+ has to be a number, which is understood to be in degrees.

These requirements are called _preconditions_ because they are supposed to be true before the function starts executing. Conversely, conditions at the end of the function are _postconditions_. Postconditions include the intended effect of the function (like drawing line segments) and any side effects (like moving the turtle or making other changes).
(((precondition)))(((postcondition)))

Preconditions are the responsibility of the caller. If the caller violates a (properly documented!) precondition and the function doesn’t work correctly, the bug is in the caller, not the function.

If the preconditions are satisfied and the postconditions are not, the bug is in the function. If your pre- and postconditions are clear, they can help with debugging.


=== Glossary

module::
A file that contains a collection of related functions and other definitions.
(((module)))

package::
An external library with additional functionality.
(((package)))

using statement::
A statement that reads a module file and creates a module object.
(((using statement)))

loop::
A part of a program that can run repeatedly.
(((loop)))

encapsulation::
The process of transforming a sequence of statements into a function definition.
(((encapsulation)))

generalization::
The process of replacing something unnecessarily specific (like a number) with something appropriately general (like a variable or parameter).
(((generalization)))

interface::
A description of how to use a function, including the name and descriptions of the arguments and return value.
(((interface)))

refactoring::
The process of modifying a working program to improve function interfaces and other qualities of the code.
(((refactoring)))

development plan::
A process for writing programs.
(((program development plan)))

docstring::
A string that appears at the top of a function definition to document the function’s interface.
(((docstring)))

precondition::
A requirement that should be satisfied by the caller before a function starts.
(((precondition)))

postcondition::
A requirement that should be satisfied by the function before it ends.
(((postcondition)))


=== Exercises

[[ex04-7]]
==== Exercise 4-8

Enter the code in this chapter in a notebook.

. Draw a stack diagram that shows the state of the program while executing +circle(🐢, radius)+. You can do the arithmetic by hand or add print statements to the code.

. The version of +arc+ in <<refactoring>> is not very accurate because the linear approximation of the circle is always outside the true circle. As a result, the turtle ends up a few pixels away from the correct destination. My solution shows a way to reduce the effect of this error. Read the code and see if it makes sense to you. If you draw a diagram, you might see how it works.
(((arc)))

[source,julia]
----
"""
arc(t, r, angle)

Draws an arc with the given radius and angle:

    t: turtle
    r: radius
    angle: angle subtended by the arc, in degrees
"""
function arc(t, r, angle)
    arc_len = 2 * π * r * abs(angle) / 360
    n = trunc(arc_len / 4) + 3
    step_len = arc_len / n
    step_angle = angle / n

    # making a slight left turn before starting reduces
    # the error caused by the linear approximation of the arc
    turn(t, -step_angle/2)
    polyline(t, n, step_len, step_angle)
    turn(t, step_angle/2)
end
----

[[ex04-8]]
==== Exercise 4-9

Write an appropriately general set of functions that can draw flowers as in <<fig04-2>>.

[[fig04-2]]
.Turtle flowers
image::images/fig42.svg[]

[[ex04-9]]
==== Exercise 4-10

Write an appropriately general set of functions that can draw shapes as in <<fig04-3>>.

[[fig04-3]]
.Turtle pies
image::images/fig43.svg[]

[[ex04-10]]
==== Exercise 4-11

The letters of the alphabet can be constructed from a moderate number of basic elements, like vertical and horizontal lines and a few curves. Design an alphabet that can be drawn with a minimal number of basic elements and then write functions that draw the letters.

You should write one function for each letter, with names +draw_a+, +draw_b+, etc., and put your functions in a file named _letters.jl_.

[[ex04-11]]
==== Exercise 4-12

Read about spirals at https://en.wikipedia.org/wiki/Spiral; then write a program that draws an Archimedan spiral as in <<fig04-4>>.

[[fig04-4]]
.Archimedan spiral
image::images/fig44.svg[]
