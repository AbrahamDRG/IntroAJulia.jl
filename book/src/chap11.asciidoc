[[chap11]]
== Diccionarios

Este capítulo presenta otro tipo integrado llamado diccionario.


=== Un Diccionario es un Mapeo 

Un _diccionario_ es como una matriz, pero más general. En una matriz, los índices tienen que ser enteros; en un diccionario pueden ser (casi) de cualquier tipo.
(((dictionary)))

Un diccionario contiene una colección de índices, llamados _claves_, y una colección de valores. Cada clave está asociada a un solo valor. La asociación entre una clave y un valor se denomina _par clave-valor_ o, a veces, item.
(((key)))(((value)))(((key-value pair)))(((item)))

En lenguaje matemático, un diccionario representa un _mapeo_ de las claves a los valores, es decir, cada clave se asigna a un valor. A modo de ejemplo, crearemos un diccionario que asigne palabras en español a palabras en inglés. En este diccionario, las claves y los valores son cadenas.
(((mapping)))

La función +Dict+ crea un nuevo diccionario sin elementos. Como +Dict+ es el nombre de una función integrada de Julia, debe evitar usarla como nombre de variable.
(((Dict)))((("type", "Base", "Dict", see="Dict")))

[source,@julia-repl-test chap11]
----
julia> ing_a_esp = Dict()
Dict{Any,Any} with 0 entries
----

El tipo de este diccionario está compuesto por el tipo de las claves y de los valores. En este caso, las claves y los valores son de tipo +Any+.
(((curly braces)))((("{}", see="curly braces")))(((Any)))((("type", "Base", "Any", see="Any")))

El diccionario está vacio. Para agregar elementos a él, se pueden usar corchetes:
(((square brackets)))

[source,@julia-repl-test chap11]
----
julia> ing_a_esp["one"] = "uno";

----

Esta línea de código crea un elemento que asigna la clave "one" al valor "uno". Si imprimimos el diccionario nuevamente, vemos un par clave-valor con una flecha +pass:[=&gt;]+ entre la clave y el valor:
(((pass:[=&gt;])))

[source,@julia-repl-test chap11]
----
julia> ing_a_esp
Dict{Any,Any} with 1 entry:
  "one" => "uno"
----

Este formato de salida también es un formato de entrada. Por ejemplo, puedes crear un nuevo diccionario con tres items de la siguiente manera:

[source,@julia-repl-test chap11]
----
julia> ing_a_esp = Dict("one" => "uno", "two" => "dos", "three" => "tres")
Dict{String,String} with 3 entries:
  "two"   => "dos"
  "one"   => "uno"
  "three" => "tres"
----

Todas las claves y valores iniciales son cadenas, por lo que se crea un +Dict{String,String}+.

[WARNING]
====
El orden de los pares clave-valor podría no ser el mismo. Si escribe el mismo ejemplo en su computadora, podría obtener un resultado diferente. En general, el orden de los elementos en un diccionario es impredecible.
====

Esto no significa un problema ya que los elementos de un diccionario nunca se indexan con índices enteros. En lugar de ello, se utilizan las claves para buscar los valores correspondientes:

[source,@julia-repl-test chap11]
----
julia> ing_a_esp["two"]
"dos"
----

La clave "two" nos da el valor "dos", así que el orden de los items no importa.

Si la clave no está en el diccionario, recibimos un mensaje de error:
(((KeyError)))((("error", "Base", "KeyError", see="KeyError")))

[source,@julia-repl-test chap11]
----
julia> ing_a_esp["four"]
ERROR: KeyError: key "four" not found
----

La función +length+ también funciona con diccionarios; devuelve el número de pares clave-valor:
(((length)))

[source,@julia-repl-test chap11]
----
julia> length(ing_a_esp)
3
----

La función +keys+ devuelve una colección con las claves del diccionario:
(((keys)))((("function", "Base", "keys", see="keys")))

[source,@julia-repl-test chap11]
----
julia> ks = keys(ing_a_esp);

julia> print(ks)
["two", "one", "three"]
----

También se puede usar el operador +∈+ para ver si algo es una _clave_ en un diccionario:
(((in)))

[source,@julia-repl-test chap11]
----
julia> "one" ∈ ks
true
julia> "uno" ∈ ks
false
----

Para ver si algo es un valor en un diccionario, se puede usar la función +values+, que devuelve una colección de valores, y luego usar el operador +∈+:
(((values)))((("function", "Base", "values", see="values")))

[source,@julia-repl-test chap11]
----
julia> vs = values(ing_a_esp);

julia> "uno" ∈ vs
true
----

El operador +∈+ utiliza diferentes algoritmos para matrices y diccionarios. Para las matrices, busca los elementos de la matriz en orden, como en <<searching>>. El tiempo de búsqueda es directamente proporcional al largo de la matriz.

Para los diccionarios, Julia usa un algoritmo llamado _tabla hash_ que tiene una propiedad importante: el operador +∈+ toma aproximadamente la misma cantidad de tiempo sin importar cuántos elementos haya en el diccionario.
(((hash table)))

[[dictionary_collection_counters]]
=== Diccionario como una Colección de Frecuencias

Suponga que tienes una cadena y deseas contar cuántas veces aparece cada letra. Hay varias formas de hacerlo:

* Podrías crear 27 variables, una para cada letra del alfabeto. Luego, recorrer la cadena y, para cada carácter, incrementar el contador correspondiente, probablemente utilizando condiciones encadenadas.

* Podrías crear una matriz con 27 elementos. Luego, podrías convertir cada carácter en un número (usando la función integrada +Int+), usar el número como índice en la matriz e incrementar el contador apropiado.

* Puedes crear un diccionario con caracteres como claves y contadores como los valores correspondientes. La primera vez que veas un carácter, agregarías un elemento al diccionario. Después de eso, incrementarías el valor de un elemento existente.

Cada una de estas opciones realiza el mismo cálculo, pero la implementación es diferente.

Una _implementación_ es una forma de realizar un cálculo. Algunas implementaciones son mejores que otras, por ejemplo, una ventaja de la implementación del diccionario es que no tenemos que saber de antemano qué letras aparecen en la cadena y solo tenemos que agregar las letras que aparecen.
(((implementation)))

Así es como se vería el código:

[source,@julia-setup chap11]
----
function histograma(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end
----

La función se llama +histograma+, que es un término en estadística para una colección de frecuencias (o conteos).
(((histogram)))((("function", "programmer-defined", "histogram", see="histogram")))

La primera línea de la función crea un diccionario vacío. El ciclo +for+ recorre la cadena +s+. En cada iteración de este ciclo, si el carácter +c+ no está en el diccionario, se crea un nuevo elemento con la clave +c+ y el valor inicial +1+ (ya que hemos visto esta letra una vez). Si +c+ ya está en el diccionario, se incrementa +d[c]+.

Así es como funciona:

[source,@julia-repl-test chap11]
----
julia> h = histograma("brontosaurus")
Dict{Any,Any} with 8 entries:
  'n' => 1
  's' => 2
  'a' => 1
  'r' => 2
  't' => 1
  'o' => 2
  'u' => 2
  'b' => 1
----

El histograma indica que las letras +'a'+ y +'b'+ aparecen una vez; +'o'+ aparece dos veces, y así sucesivamente.

Los diccionarios tienen una función llamada +get+ que toma como argumentos un diccionario, una clave y un valor predeterminado. Si la clave aparece en el diccionario, +get+ devuelve el valor correspondiente; de lo contrario, devuelve el valor predeterminado. Por ejemplo:
(((get)))((("function", "Base", "get", see="get")))

[source,@julia-repl-test chap11]
----
julia> h = histograma("a")
Dict{Any,Any} with 1 entry:
  'a' => 1
julia> get(h, 'a', 0)
1
julia> get(h, 'b', 0)
0
----

==== Ejercicio 11-1

Use +get+ para escribir la función +histograma+ de manera más concisa. Debería poder eliminar la declaración +if+.

=== Iteración y Diccionarios 

Es posible recorrer las claves del diccionario con un ciclo +for+. Por ejemplo, +imprimirhist+ imprime cada clave y su valor correspondiente:
(((printhist)))((("function", "programmer-defined", "printhist", see="printhist")))

[source,@julia-setup chap11]
----
function imprimirhist(h)
    for c in keys(h)
        println(c, " ", h[c])
    end
end
----

Así es como se ve la salida:

[source,@julia-repl-test chap11]
----
julia> h = histograma("perros");

julia> imprimirhist(h)
e 1
r 2
p 1
o 1
s 1
----

Nuevamente, las claves no están en un orden particular. Para recorrer las claves en orden, puede usar +sort+ y +collect+:
(((sort)))(((collect)))

[source,@julia-repl-test chap11]
----
julia> for c in sort(collect(keys(h)))
           println(c, " ", h[c])
       end
e 1
o 1
p 1
r 2
s 1
----


=== Búsqueda inversa

Dado un diccionario +d+ y una clave +k+, es fácil encontrar el valor correspondiente +v = d[k]+. Esta operación se llama _búsqueda_.
(((lookup)))

Pero, ¿qué pasa si tenemos +v+ y queremos encontrar +k+? Existen dos problemas: primeramente, puede haber más de una clave asignada al valor +v+. Dependiendo de lo que queramos, es posible que podamos elegir una de estas claves, o que tengamos que hacer una matriz que las contenga a todas. En segundo lugar, no hay una sintaxis simple para hacer una búsqueda inversa; solo debemos buscar.
(((reverse lookup)))

A continuación se muestra una función que toma un valor y que devuelve la primera clave asignada a ese valor:

[source,@julia-setup chap11]
----
function busquedainversa(d, v)
    for k in keys(d)
        if d[k] == v
            return k
        end
    end
    error("Error de Busqueda")
end
----

Esta función es otro ejemplo del patrón de búsqueda, pero utiliza una función que no hemos visto antes: +error+. La función +error+ se usa para producir un +ErrorException+ que interrumpe el flujo normal. En este caso tiene el mensaje +"Error de Busqueda"+, que indica que no existe una clave.
(((error)))((("function", "Base", "error", see="error")))

Si llega al final del ciclo, eso significa que +v+ no aparece en el diccionario como un valor, por lo que se produce una excepción.

A continuación se muestra un ejemplo de una búsqueda inversa exitosa:

[source,@julia-repl-test chap11]
----
julia> h = histograma("perros");

julia> key = busquedainversa(h, 2)
'r': ASCII/Unicode U+0072 (category Ll: Letter, lowercase)
----

Y una no exitosa:

[source,@julia-repl-test chap11]
----
julia> key = busquedainversa(h, 3)
ERROR: Error de Busqueda
----

El efecto cuando generamos una excepción es el mismo que cuando Julia genera una: se imprime un trazado inverso y un mensaje de error.

Julia proporciona una forma optimizada de hacer una búsqueda inversa: +findall(isequal(3),h)+.
(((findall)))((("function", "Base", "findall", see="findall")))(((isequal)))((("function", "Base", "isequal", see="isequal")))

[WARNING]
====
Una búsqueda inversa es mucho más lenta que una búsqueda directa. Si tiene que hacer búsquedas inversas con frecuencia, o si el diccionario es muy grande, el rendimiento de su programa se verá afectado.
====


=== Diccionarios y Matrices

Las matrices pueden aparecer como valores en un diccionario. Por ejemplo, si tenemos un diccionario que asigna frecuencias a letras, y queremos invertirlo; es decir, tener un diccionario que asigne letras a frecuencias. Dado que pueden haber varias letras con la misma frecuencia, cada valor en el diccionario invertido debería ser una matriz de letras.

Aquí hay una función que invierte un diccionario:
(((invertdict)))((("function", "programmer-defined", "invertdict", see="invertdict")))

[source,@julia-setup chap11]
----
function invertirdic(d)
    inverso = Dict()
    for clave in keys(d)
        val = d[clave]
        if val ∉ keys(inverso)
            inverso[val] = [clave]
        else
            push!(inverso[val], clave)
        end
    end
    inverso
end
----

Cada vez que recorremos el bucle, se asigna a la variable +clave+ una clave de +d+, y a +val+ el valor correspondiente. Si +val+ no está en el diccionario +inverso+, significa que no hemos visto este valor antes, por lo que creamos un nuevo item y lo inicializamos con un _singleton_ (una matriz que contiene un solo elemento). De lo contrario, hemos visto este valor antes, por lo que agregamos la clave correspondiente a la matriz.
(((singleton)))

Aquí hay un ejemplo:

[source,@julia-repl-test chap11]
----
julia> hist = histograma("perros");

julia> inverso = invertirdic(hist)
Dict{Any,Any} with 2 entries:
  2 => ['r']
  1 => ['s', 'e', 'p', 'o']
----

[[fig11-1]]
.State diagram
image::images/fig111.svg[]

<<fig11-1>> es un diagrama de estado que muestra +hist+ e +inverso+. Un diccionario se representa como un cuadro con los pares clave-valor dentro. En este libro, si los valores son enteros, números de punto flotante o cadenas de texto, se dibujan dentro del cuadro, y las matrices (generalmente) se dibujan fuera del cuadro, solo para mantener el diagrama simple.
(((state diagram)))

[NOTE]
====
Anteriormente se mencionó que un diccionario se implementa usando una tabla hash (también llamada matriz asociativa, hashing, mapa hash, tabla de dispersión o tabla fragmentada), lo cual significa que las claves deben ser _hashable_.
(((hashable)))

Un _hash_ es una función que toma un valor (de cualquier tipo) y devuelve un entero. Los diccionarios usan estos enteros, llamados valores hash, para almacenar y buscar pares clave-valor.
(((hash)))
====

[[memos]]
=== Memos

Si jugaste con la función +fibonacci+ de <<one_more_example>>, es posible que hayas notado que cuanto más grande el argumento proporcionado, más tiempo tarda la función en ejecutarse. Además, el tiempo de ejecución aumenta rápidamente.
(((fibonnaci)))

Para entender por qué, considere <<fig11-2>>, que muestra el _call graph_ para la función +fibonacci+ con +n = 4+:
(((call graph)))((("diagram", "call graph", see="call graph")))

[[fig11-2]]
.Call graph
image::images/fig112.svg[]


A call graph shows a set of function frames, with lines connecting each frame to the frames of the functions it calls. At the top of the graph, +fibonacci+ with +n = 4+ calls +fibonacci+ with  +n = 3+ and +n = 2+. In turn, +fibonacci+ with +n = 3+ calls +fibonacci+ with +n = 2+ and +n = 1+. And so on.

Count how many times +fibonacci(0)+ and +fibonacci(1)+ are called. This is an inefficient solution to the problem, and it gets worse as the argument gets bigger.

One solution is to keep track of values that have already been computed by storing them in a dictionary. A previously computed value that is stored for later use is called a _memo_. Here is a “memoized” version of fibonacci:
(((memo)))

[source,@julia-setup]
----
known = Dict(0=>0, 1=>1)

function fibonacci(n)
    if n ∈ keys(known)
        return known[n]
    end
    res = fibonacci(n-1) + fibonacci(n-2)
    known[n] = res
    res
end
----

+known+ is a dictionary that keeps track of the Fibonacci numbers we already know. It starts with two items: +0+ maps to +0+ and +1+ maps to +1+.

Whenever +fibonacci+ is called, it checks +known+. If the result is already there, it can return immediately. Otherwise it has to compute the new value, add it to the dictionary, and return it.

If you run this version of +fibonacci+ and compare it with the original, you will find that it is much faster.

[[global_variables]]
=== Global Variables

In the previous example, known is created outside the function, so it belongs to the special frame called +Main+. Variables in +Main+ are sometimes called _global_ because they can be accessed from any function. Unlike local variables, which disappear when their function ends, global variables persist from one function call to the next.
(((global)))((("keyword", "global", see="global")))(((global variable)))

It is common to use global variables for _flags_; that is, boolean variables that indicate (“flag”) whether a condition is true. For example, some programs use a flag named +verbose+ to control the level of detail in the output:
(((flag)))

[source,@julia-setup]
----
verbose = true

function example1()
    if verbose
        println("Running example1")
    end
end
----

If you try to reassign a global variable, you might be surprised. The following example is supposed to keep track of whether the function has been called:

[source,@julia-setup]
----
been_called = false

function example2()
    been_called = true         # WRONG
end
----

But if you run it you will see that the value of +been_called+ doesn’t change. The problem is that +example2+ creates a new local variable named +been_called+. The local variable goes away when the function ends, and has no effect on the global variable.

To reassign a global variable inside a function you have to _declare_ the variable global before you use it:
(((declaration)))(((reassignment)))

[source,@julia-setup]
----
been_called = false

function example2()
    global been_called
    been_called = true
end
----

The _global statement_ tells the interpreter something like, “In this function, when I say +been_called+, I mean the global variable; don’t create a local one.”
(((global statement)))((("statement", "global", see="global statement")))

Here’s an example that tries to update a global variable:

[source,@julia-setup chap11]
----
count = 0

function example3()
    count = count + 1          # WRONG
end
----

If you run it you get:
(((UndefVarError)))

[source,@julia-repl-test chap11]
----
julia> example3()
ERROR: UndefVarError: count not defined
----

Julia assumes that +count+ is local, and under that assumption you are reading it before writing it. The solution, again, is to declare +count+ global.

[source,@julia-setup]
----
count = 0

function example3()
    global count
    count += 1
end
----

If a global variable refers to a mutable value, you can modify the value without declaring the variable global:

[source,@julia-setup]
----
known = Dict(0=>0, 1=>1)

function example4()
    known[2] = 1
end
----

So you can add, remove and replace elements of a global array or dictionary, but if you want to reassign the variable, you have to declare it global:

[source,@julia-setup]
----
known = Dict(0=>0, 1=>1)

function example5()
    global known
    known = Dict()
end
----

For performance reasons, you should declare a global variable constant. You can no longer reassign the variable but if it refers to a mutable value, you can modify the value. 
(((const)))((("keyword", "const", see="const")))(((constant global variable)))

[source,@julia-setup]
----
const known = Dict(0=>0, 1=>1)

function example4()
    known[2] = 1
end
----

[WARNING]
====
Global variables can be useful, but if you have a lot of them, and you modify them frequently, they can make programs hard to debug and perform badly.
====

=== Debugging

As you work with bigger datasets it can become unwieldy to debug by printing and checking the output by hand. Here are some suggestions for debugging large datasets:
(((debugging)))

* Scale down the input:
+
If possible, reduce the size of the dataset. For example if the program reads a text file, start with just the first 10 lines, or with the smallest example you can find which errors. You sould not edit the files themselves, but rather modify the program so it reads only the first latexmath:[\(n\)] lines.
(((scale down)))
+
If there is an error, you can reduce latexmath:[\(n\)] to the smallest value that manifests the error, and then increase it gradually as you find and correct errors.

* Check summaries and types:
+
Instead of printing and checking the entire dataset, consider printing summaries of the data: for example, the number of items in a dictionary or the total of an array of numbers.
(((check)))
+
A common cause of runtime errors is a value that is not the right type. For debugging this kind of error, it is often enough to print the type of a value.

* Write self-checks:
+
Sometimes you can write code to check for errors automatically. For example, if you are computing the average of an array of numbers, you could check that the result is not greater than the largest element in the array or less than the smallest. This is called a “sanity check”.
(((self-check)))(((sanity check)))
+
Another kind of check compares the results of two different computations to see if they are consistent. This is called a “consistency check”.
(((consistency check)))

* Format the output:
+
Formatting debugging output can make it easier to spot an error. We saw an example in <<deb06>>.
(((formatting)))
+
Again, time you spend building scaffolding can reduce the time you spend debugging.
(((scaffolding)))(((debugging)))


=== Glossary

mapping::
A relationship in which each element of one set corresponds to an element of another set.
(((mapping)))

dictionary::
A mapping from keys to their corresponding values.
(((dictionary)))

key-value pair::
The representation of the mapping from a key to a value.
(((key-value pair)))

item::
In a dictionary, another name for a key-value pair.
(((item)))

key::
An object that appears in a dictionary as the first part of a key-value pair.
(((key)))

value::
An object that appears in a dictionary as the second part of a key-value pair. This is more specific than our previous use of the word “value”.
(((value)))

implementation::
A way of performing a computation.
(((implementation)))

hash table::
The algorithm used to implement Julia dictionaries.
(((hash table)))

hash function::
A function used by a hash table to compute the location for a key.
(((hash function)))

hashable::
A type that has a hash function.
(((hashable)))

lookup::
A dictionary operation that takes a key and finds the corresponding value.
(((lookup)))

reverse lookup::
A dictionary operation that takes a value and finds one or more keys that map to it.
(((reverse lookup)))

singleton::
An array (or other sequence) with a single element.
(((singleton)))

call graph::
A diagram that shows every frame created during the execution of a program, with an arrow from each caller to each callee.
(((call graph)))

memo::
A computed value stored to avoid unnecessary future computation.
(((memo)))

global variable::
A variable defined outside a function. Global variables can be accessed from any function.
(((global variable)))

global statement::
A statement that declares a variable name global.
(((global statement)))

flag::
A boolean variable used to indicate whether a condition is true.
(((flag)))

declaration::
A statement like +global+ that tells the interpreter something about a variable.
(((declaration)))

constant global variable::
A global variable that can not be reassigned.
(((constant global variable)))


=== Exercises

[[ex11-1]]
==== Exercise 11-2

Write a function that reads the words in _palabras.txt_ and stores them as keys in a dictionary. It doesn’t matter what the values are. Then you can use the +∈+ operator as a fast way to check whether a string is in the dictionary.
(((in)))

If you did <<ex10-10>>, you can compare the speed of this implementation with the array +∈+ operator and the bisection search.

[[ex11-2]]
==== Exercise 11-3

Read the documentation of the dictionary function +get!+ and use it to write a more concise version of +invertdict+.
(((get!)))((("function", "Base", "get!", see="get!")))

[[ex11-3]]
==== Exercise 11-4

Memoize the Ackermann function from <<ex06-2>> and see if memoization makes it possible to evaluate the function with bigger arguments.
(((memo)))(((Ackermann function)))

[[ex11-4]]
==== Exercise 11-5

If you did <<ex10-7>>, you already have a function named +hasduplicates+ that takes an array as a parameter and returns +true+ if there is any object that appears more than once in the array.
(((hasduplicates)))

Use a dictionary to write a faster, simpler version of +hasduplicates+.

[[ex11-5]]
==== Exercise 11-6

Two words are “rotate pairs” if you can rotate one of them and get the other (see +rotateword+ in <<ex08-5>>).
(((rotateword)))

Write a program that reads a word array and finds all the rotate pairs.

[[ex11-6]]
==== Exercise 11-7

Here’s another Puzzler from Car Talk (https://www.cartalk.com/puzzler/browse):
(((Car Talk)))

[quote]
____
This was sent in by a fellow named Dan O’Leary. He came upon a common one-syllable, five-letter word recently that has the following unique property. When you remove the first letter, the remaining letters form a homophone of the original word, that is a word that sounds exactly the same. Replace the first letter, that is, put it back and remove the second letter and the result is yet another homophone of the original word. And the question is, what’s the word?

Now I’m going to give you an example that doesn’t work. Let’s look at the five-letter word, ‘wrack.’ W-R-A-C-K, you know like to ‘wrack with pain.’ If I remove the first letter, I am left with a four-letter word, ’R-A-C-K.’ As in, ‘Holy cow, did you see the rack on that buck! It must have been a nine-pointer!’ It’s a perfect homophone. If you put the ‘w’ back, and remove the ‘r,’ instead, you’re left with the word, ‘wack,’ which is a real word, it’s just not a homophone of the other two words.

But there is, however, at least one word that Dan and we know of, which will yield two homophones if you remove either of the first two letters to make two, new four-letter words. The question is, what’s the word?
____

You can use the dictionary from <<ex11-1>> to check whether a string is in the word array.

[TIP]
====
To check whether two words are homophones, you can use the CMU Pronouncing Dictionary. You can download it from http://www.speech.cs.cmu.edu/cgi-bin/cmudict.
====

Write a program that lists all the words that solve the Puzzler.

