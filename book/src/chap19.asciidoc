[[chap19]]
== Extra: Sintaxis

Uno de los objetivos de este libro es ense√±ar lo justo y necesario de Julia. Si hab√≠an dos formas de hacer algo, se elegi√≥ una y se evit√≥ mencionar la otra. En ocasiones, la segunda manera se dej√≥ como ejercicio al lector.

Ahora veremos algunas cosas que hemos dejado de lado, que s√≠ son √∫tiles. Julia proporciona una serie de caracter√≠sticas que no son realmente necesarias (se puede escribir un buen c√≥digo sin ellas), pero a veces permiten escribir un c√≥digo m√°s conciso, legible y/o eficiente.

En este cap√≠tulo y el siguiente se discute aquello que se ha omitido en los cap√≠tulos anteriores:

* m√°s sintaxis
* funciones, tipos y macros disponibles directamente de +Base+ 
(((Base)))
* funciones, tipos y macros de la Biblioteca Est√°ndar (Standard Library)
(((Standard Library)))

=== Tuplas con nombre

Es posible colocarle nombre a los componentes de una tupla, creando una tupla con nombre:

[source,@julia-repl-test]
----
julia> x = (a=1, b=1+1)
(a = 1, b = 2)
julia> x.a
1
----

En las tuplas con nombre, se puede acceder a los atributos con su nombre utilizando la sintaxis de punto +(x.a)+.
(((named tuple)))(((dot syntax)))


=== Funciones

La funci√≥n en Julia tambi√©n se puede definir mediante una sintaxis compacta.

[source,@julia-repl-test]
----
julia> f(x,y) = x + y
f (generic function with 1 method)
----

[[anonymous_functions]]
==== Funciones Anonimas

Podemos definir una funci√≥n sin especificar su nombre:

[source,@julia-repl-test]
----
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)
julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
----

Estos son ejemplos de _funciones an√≥nimas_. Las funciones an√≥nimas generalmente se usan como argumento de otra funci√≥n:
(((anonymous function)))(((Plots)))((("module", "Plots", see="Plots")))(((plot)))((("function", "Plots", "plot", see="plot")))

[source,jlcon]
----
julia> using Plots

julia> plot(x -> x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")

----

<<fig19-1>> muestra el resultado del comando plot (graficar en ingl√©s).

[[fig19-1]]
.Plot
image::images/fig191.svg[pdfwidth="10cm"]

==== Argumentos con nombre

Tambi√©n se puede poner nombre a los argumentos de una funci√≥n:

[source,@julia-repl-test]
----
julia> function migrafico(x, y; style="continua", width=1, color="negro")
           ###
       end
migrafico (generic function with 1 method)
julia> migrafico(0:10, 0:10, style="dotted", color="blue")

----

Los _argumentos con nombre_ en una funci√≥n se especifican despu√©s de un punto y coma en la especificaci√≥n, pero al llamar a la funci√≥n se pueden utilizar solo comas.
(((;)))(((keyword arguments)))

==== Clausuras

Una _clausura_ es una t√©cnica que permite que una funci√≥n capture una variable definida fuera del ambito de la funci√≥n.

[source,@julia-repl-test]
----
julia> foo(x) = ()->x
foo (generic function with 1 method)

julia> bar = foo(1)
#1 (generic function with 1 method)

julia> bar()
1
----

En este ejemplo, la funci√≥n +foo+ devuelve una funci√≥n an√≥nima que tiene acceso al argumento +x+ de la funci√≥n +foo+. +bar+ apunta a la funci√≥n an√≥nima y devuelve el valor del argumento de +foo+.


=== Bloques

Un _bloque_ es una forma de agrupar varias sentencias. Un bloque comienza con la palabra reservada +begin+ y termina con +end+.
(((begin)))((("keyword", "begin", see="begin")))(((end)))(((block)))

En <<chap04>> se present√≥ la macro +@svg+:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

En este ejemplo, la macro +@svg+ tiene un √∫nico argumento: un bloque, que agrupa 3 llamadas a funciones.

==== Bloques +let+ 

Un bloque +let+ es √∫til para crear nuevas ligaduras (o bindings), es decir, variables locales que pueden apuntar a valores.

[source,@julia-repl-test]
----
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia> @show x y z;
x = -1
y = -1
z = -1
----

En el ejemplo, la primera macro +@show+ muestra la variable local +x+, la variable global +y+ y la variable local indefinida +z+. Las variables globales se mantienen intactas.


==== Bloques +do+

En <<reading_and_writing>> cerramos el archivo despu√©s de terminar de escribir en √©l. Esto se puede hacer autom√°ticamente usando un _Bloque do_:
(((do)))((("keyword", "do", see="do")))

[source,@julia-repl-test chap19]
----
julia> datos = "El Cid convoca a sus vasallos;\n√©stos se destierran con √©l.\n"
"El Cid convoca a sus vasallos;\n√©stos se destierran con √©l.\n"
julia> open("salida.txt", "w") do fout
           write(fout, datos)
       end
61
----

En este ejemplo, +fout+ es el archivo stream utilizado para la salida.

Esto es equivalente a:

[source,@julia-repl-test chap19]
----
julia> f = fout -> begin
           write(fout, datos)
       end
#3 (generic function with 1 method)
julia> open(f, "salida.txt", "w")
61
----

La funci√≥n an√≥nima se utiliza como primer argumento de la funci√≥n +open+:
(((open)))

[source,julia]
----
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
----

Un bloque +do+ puede "capturar" variables de su alcance envolvente. Por ejemplo, la variable +datos+ en el ejemplo anterior de +open pass:[...] do+ se captura desde el √°mbito externo. 

A +do+ block can ‚Äúcapture‚Äù variables from its enclosing scope. For example, the variable +data+ in the above example of +open pass:[...] do+ is captured from the outer scope.


=== Control Flow

==== Operador ternario

El _operador ternario_, +?:+, puede utilizarse en vez de una sentencia +if-elseif+. Esta sentencia se usa cuando se necesita elegir entre diferentes expresiones con valor √∫nico.
(((?:)))((("operator", "Base", "?:", see="?:")))((("ternary operator", see="?:")))

[source,@julia-repl-test]
----
julia> a = 150
150
julia> a % 2 == 0 ? println("par") : println("impar")
even
----

La expresi√≥n que va antes de +?+ es una expresi√≥n de condici√≥n. Si la condici√≥n es +true+, se eval√∫a la expresi√≥n que va antes de +:+; de lo contrario, se eval√∫a la expresi√≥n que va despu√©s de +:+.

==== Evaluaci√≥n de cortocircuito

Los operadores +&&+ y +||+ realizan una _evaluaci√≥n de cortocircuito_, es decir, se eval√∫a el siguiente argumento solo cuando es necesario para determinar el valor final.
(((&&)))(((||)))(((short-circuit evaluation)))

Por ejemplo, una funci√≥n factorial recursiva podr√≠a definirse as√≠:
(((fact)))

[source,@julia-setup]
----
function fact(n::Integer)
    n >= 0 || error("n debe ser no negativo")
    n == 0 && return 1
    n * fact(n-1)
end
----

==== Tarea (o Corrutina)

Una _tarea_ es una estructura de control que puede ceder el control de forma cooperativa sin hacer return. En Julia, una tarea puede implementarse como una funci√≥n con un objeto +Channel+ como primer argumento. Se usa un channel para pasar valores de la funci√≥n a la sentencia que la llama.

El t√©rmino "cooperativo" alude a que los programas deben cooperar para que todo el esquema de programaci√≥n funcione.

La secuencia de Fibonnaci se puede generar mediante una tarea.
(((task)))(((Channel)))((("type", "Base", "Channel", see="Channel")))(((put!)))((("function", "Base", "put!", see="put!")))

[source,@julia-setup chap19]
----
function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end
----

+put!+ almacena valores en un objeto channel y +take!+ lee valores desde √©l:
(((take!)))((("function", "Base", "take!", see="take!")))

[source,@julia-repl-test chap19]
----
julia> fib_gen = Channel(fib);

julia> take!(fib_gen)
0
julia> take!(fib_gen)
1
julia> take!(fib_gen)
1
julia> take!(fib_gen)
2
julia> take!(fib_gen)
3
----

El constructor +Channel+ crea la tarea. La funci√≥n +fib+ se suspende despu√©s de cada llamada a +put!+ y se reanuda al llamar a +take!+. Por razones de rendimiento, se almacenan varios valores de la secuencia en el objeto channel durante un ciclo de reanudaci√≥n/suspensi√≥n.

Un objeto channel tambi√©n se puede usar como iterador:

[source,@julia-repl-test chap19]
----
julia> for val in Channel(fib)
           print(val, " ")
           val > 20 && break
       end
0 1 1 2 3 5 8 13 21
----


=== Tipos

==== Tipos Primitivos

Un tipo concreto compuesto por bits se llama _tipo primitivo_. A diferencia de la mayor√≠a de los lenguajes, en Julia podemos declarar nuestros propios tipos primitivos. Los tipos primitivos est√°ndar se definen de la misma manera:
(((primitive type)))((("keyword", "primitive type", see="primitive type")))

[source,julia]
----
primitive type Float64 <: AbstractFloat 64 end
primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end
primitive type Int64 <: Signed 64 end
----

El n√∫mero en las sentencias especifica cu√°ntos bits se requieren.

El siguiente ejemplo crea un tipo primitivo +Byte+ y un constructor:
(((Byte)))((("type", "programmer-defined", "Byte", see="Byte")))

[source,@julia-repl-test]
----
julia> primitive type Byte 8 end

julia> Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia> b = Byte(0x01)
Byte(0x01)
----

La funci√≥n +reinterpret+ se usa para almacenar los bits de un entero sin signo con 8 bits (+UInt8+) en el byte.
(((reinterpret)))((("function", "Base", "reinterpret", see="reinterpret")))(((UInt8)))((("type", "Base", "UInt8", see="UInt8")))

==== Tipos Param√©tricos

El sistema de tipos de Julia es _param√©trico_, lo que significa que los tipos pueden tener par√°metros.

Los par√°metros de un tipo se colocan despu√©s del nombre del tipo, entre llaves:
(((curly braces)))

[source,@julia-setup chap19]
----
struct Punto{T<:Real}
    x::T
    y::T
end
----

Con esto se define un nuevo tipo param√©trico, +Punto{T<:Real}+, que contiene dos "coordenadas" de tipo +T+, que puede ser cualquier tipo que tenga +Real+ como supertipo.

[source,@julia-repl-test chap19]
----
julia> Punto(0.0, 0.0)
Punto{Float64}(0.0, 0.0)
----

Adem√°s de los tipos compuestos, los tipos abstractos y los tipos primitivos tambi√©n pueden tener par√°metros.

[TIP]
====
Tener tipos concretos como atributos de una estructura es absolutamente recomendable por razones de rendimiento, por lo que esta es una buena manera de hacer que +Punto+ sea r√°pido y flexible.
====

==== Union de Tipo

Una _union de tipo_ es un tipo param√©trico abstracto que puede actuar como cualquiera de los tipos de sus argumentos:
(((type union)))(((Union)))((("type", "Base", "Union", see="Union")))

[source,@julia-repl-test]
----
julia> EnteroOCadena = Union{Int64, String}
Union{Int64, String}
julia> 150 :: EnteroOCadena
150
julia> "Julia" :: EnteroOCadena
"Julia"
----

Una uni√≥n de tipos es, en la mayor√≠a de los lenguajes inform√°ticos, una construcci√≥n interna para trabajar con tipos. Sin embargo, Julia expone esta caracter√≠stica a sus usuarios ya que permite generar un c√≥digo eficiente cuando la uni√≥n es entre pocos tipos. Esta caracter√≠stica le da una gran flexibilidad al programador de Julia para controlar el dispatch.

=== M√©todos

==== M√©todos Param√©tricos 

Las definiciones de m√©todos tambi√©n pueden tener par√°metros de tipo que limiten su especificaci√≥n:
(((signature)))

[source,@julia-repl-test chap19]
----
julia> espuntoentero(p::Punto{T}) where {T} = (T === Int64)
espuntoentero (generic function with 1 method)
julia> p = Punto(1, 2)
Punto{Int64}(1, 2)
julia> espuntoentero(p)
true
----

==== Objetos Similares a Funciones

Cualquier objeto arbitrario de Julia puede hacerse "invocable". Tales objetos "invocables" a veces se denominan _funtores_.
(((functor)))

[source,@julia-setup chap19]
----
struct Polinomio{R}
    coef::Vector{R}
end

function (p::Polinomio)(x)
    val = p.coeff[end]
    for coef in p.coef[end-1:-1:1]
        val = val * x + coef
    end
    val
end
----

Para evaluar el polinomio, simplemente debemos llamarlo:

[source,@julia-repl-test chap19]
----
julia> p = Polinomio([1,10,100])
Polynomi{Int64}([1, 10, 100])
julia> p(3)
931
----

=== Constructores

Los tipos param√©tricos se pueden construir expl√≠cita o impl√≠citamente:

[source,@julia-repl-test chap19]
----
julia> Punto(1,2)         # T implicito
Point{Int64}(1, 2)
julia> Punto{Int64}(1, 2) # T explicito
Point{Int64}(1, 2)
julia> Punto(1,2.5)       # T implicito
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
----

Se generan constructores internos y externos por defecto para cada +T+:
(((constructor)))

[source,julia]
----
struct Punto{T<:Real}
    x::T
    y::T
    Punto{T}(x,y) where {T<:Real} = new(x,y)
end

Punto(x::T, y::T) where {T<:Real} = Punto{T}(x,y);
----

y tanto +x+ como +y+ deben ser del mismo tipo. 

Cuando +x+ e +y+ son de tipos diferentes, se puede definir el siguiente constructor externo:

[source,@julia-setup chap19]
----
Punto(x::Real, y::Real) = Punto(promote(x,y)...);
----

La funci√≥n +promote+ se detalla en <<promoci√≥n>>.
(((promote)))((("function", "Base", "promote", see="promote")))

=== Conversi√≥n y Promoci√≥n

Julia tiene un sistema para convertir argumentos de diferentes tipos a un tipo com√∫n. Esto es llamado promoci√≥n, y aunque no es autom√°tico se puede realizar f√°cilmente.

==== Conversion

Un valor se puede convertir de un tipo a otro:
(((conversion)))(((convert)))((("function", "Base", "convert", see="convert")))

[source,@julia-repl-test]
----
julia> x = 12
12
julia> typeof(x)
Int64
julia> convert(UInt8, x)
0x0c
julia> typeof(ans)
UInt8
----

Podemos agregar nuestros propios m√©todos +convert+:
[source,@julia-repl-test chap19]
----
julia> Base.convert(::Type{Punto{T}}, x::Array{T, 1}) where {T<:Real} = Punto(x...)

julia> convert(Punto{Int64}, [1, 2])
Punto{Int64}(1, 2)
----

[[promotion]]
==== Promoci√≥n

_Promoci√≥n_ es la conversi√≥n de valores de diferentes tipos a un solo tipo com√∫n:
(((promotion)))(((promote)))

[source,@julia-repl-test]
----
julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)
----

Generalmente, los m√©todos para la funci√≥n +promote+ no se definen directamente, sino que se usa la funci√≥n auxiliar +promot_rule+ para especificar las reglas de la promoci√≥n:
(((promote_rule)))((("function", "Base", "promote_rule", see="promote_rule")))

[source,julia]
----
promote_rule(::Type{Float64}, ::Type{Int32}) = Float64
----

=== Metaprogramaci√≥n

El c√≥digo de Julia se puede representar como una estructura de datos del lenguaje en s√≠. Esto permite que un programa se transforme y genere su propio c√≥digo.
Julia code can be represented as a data structure of the language itself. This allows a program to transform and generate its own code. 

==== Expresiones

Cada programa de Julia comienza como una cadena:

[source,@julia-repl-test chap19]
----
julia> prog = "1 + 2"
"1 + 2"
----

El siguiente paso es analizar cada cadena en un objeto llamado _expresi√≥n_, representada por el tipo de Julia +Expr+:
(((expression)))(((Expr)))((("type", "Base", "Expr", see="Expr")))(((parse)))((("function", "Meta", "parse", see="parse")))

[source,@julia-repl-test chap19]
----
julia> ex = Meta.parse(prog)
:(1 + 2)
julia> typeof(ex)
Expr
julia> dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2
----

La funci√≥n +dump+ muestra objetos expr con anotaciones.
(((dump)))

Las expresiones se pueden construir directamente con el prefijo +:+ entre par√©ntesis o usando un bloque de comillas
Expressions can be constructed directly by prefixing with +:+ inside parentheses or using a quote block
(((:)))(((quote)))((("keyword", "quote", see="quote")))

[source,@julia-repl-test chap19]
----
julia> ex = quote
           1 + 2
       end;
----

==== +eval+

Julia puede evaluar un objeto de expresi√≥n usando +eval+:
(((eval)))((("function", "Core", "eval", see="eval")))

[source,@julia-eval chap19]
----
import Base.eval
----

[source,@julia-repl-test chap19]
----
julia> eval(ex)
3
----

Cada m√≥dulo tiene su propia funci√≥n +eval+ que eval√∫a las expresiones de su √°mbito.

[WARNING]
====
When you are using a lot of calls to the function +eval+, often this means that something is wrong. +eval+ is considered ‚Äúevil‚Äù.
====

==== Macros

Macros can include generated code in a program. A _macro_ maps a tuple of +Expr+ objects directly to a compiled expression:
(((macro)))

Here is a simple macro:
(((@containervariable)))((("macro", "programmer-defined", "@containervariable", see="@containervariable")))

[source,@julia-setup chap19]
----
macro containervariable(container, element)
    return esc(:($(Symbol(container,element)) = $container[$element]))
end
----

Macros are called by prefixing their name with the +@+ (at-sign). The macro call +@containervariable letters 1+ is replaced by:
(((@)))

[source,julia]
----
:(letters1 = letters[1])
----

+@macroexpand @containervariable letters 1+  returns this expression which is extremely useful for debugging.
(((@macroexpand)))((("macro", "Base", "@macroexpand", see="@macroexpand")))

This example illustrates how a macro can access the name of its arguments, something a function can‚Äôt do. The return expression needs to be ‚Äúescaped‚Äù with +esc+ because it has to be resolved in the macro call environment.
(((esc)))((("function", "Base", "esc", see="esc")))

[NOTE]
====
Why macros?

Macros generate and include fragments of customized code during parse time, thus _before_ the full program is run.
====

==== Generated Functions

The macro +@generated+ creates specialized code for methods depending on the types of the arguments:
(((generated functions)))(((@generated)))((("macro", "Base", "@generated", see="@generated")))

[source,@julia-setup chap19]
----
@generated function square(x)
    println(x)
    :(x * x)
end
----

The body returns a quoted expression like a macro.

For the caller, the _generated function_ behaves as a regular function:

[source,@julia-repl-test chap19]
----
julia> x = square(2); # note: output is from println() statement in the body
Int64
julia> x              # now we print x
4
julia> y = square("spam");
String
julia> y
"spamspam"
----

=== Missing Values

_Missing values_ can be represented via the +missing+ object, which is the singleton instance of the type +Missing+.
(((missing values)))(((missing)))(((Missing)))((("type", "Base", "Missing", see="Missing")))

Arrays can contain missing values:

[source,@julia-repl-test chap19]
----
julia> a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing
----

The element type of such an array is +Union{Missing, T}+, with +T+ the type of the non-missing values.

Reduction functions return +missing+ when called on arrays which contain missing values

[source,@julia-repl-test chap19]
----
julia> sum(a)
missing
----

In this situation, use the +skipmissing+ function to skip missing values:
(((skipmissing)))((("function", "Base", "skipmissing", see="skipmissing")))

[source,@julia-repl-test chap19]
----
julia> sum(skipmissing([1, missing]))
1
----


=== Calling C and Fortran Code

A lot of code is written in C or Fortran. Reusing tested code is often better than writing your own version of an algorithm. Julia can call directly existing C or Fortran libraries using the +ccall+ syntax.
(((ccall)))((("function", "Base", "ccall", see="ccall")))

In <<databases>> we introduced a Julia interface to the GDBM library of database functions. The library is written in C. To close the database a function call to +close(db)+ has to be made:

[source,julia]
----
Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end
----

A dbm object has a field +handle+ of +Ptr{Cvoid}+ type. This field holds a C pointer that refers to the database. To close the database the C function +gdbm_close+ has to be called having as only argument the C pointer pointing to the database and no return value. Julia does this directly with the +ccall+ function having as arguments:
(((Ptr)))((("type", "Base", "Ptr", see="Ptr")))

* a tuple consisting of a symbol holding the name of the function we want to call: +:gdbm_close+ and the shared library specified as a string: +"libgdm"+,

* the return type: +Cvoid+,

* a tuple of argument types: +(Ptr{Cvoid},)+ and

* the argument values: +handle+.

The complete mapping of the GDBM library can be found as an example in the PiensaEnJulia sources.

=== Glossary

closure::
Function that captures variables from its defining scope.
(((closure)))

let block::
Block allocating new variable bindings.
(((let block)))

anonymous function::
Function defined without being given a name.
(((anonymous function)))

named tuple::
Tuple with named components.
(((named tuple)))

keyword arguments::
Arguments identified by name instead of only by position.
(((keyword arguments)))

do block::
Syntax construction used to define and call an anonymous function which looks like a normal code block.
(((do block)))

ternary operator::
Control flow operator taking three operands to specify a condition, an expression to be executed when the condition yields +true+ and an expression to be executed when the condition yields +false+.
(((ternary operator)))

short-circuit evaluation::
Evaluation of a boolean operator for which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression.
(((short-circuit evaluation)))

task (aka coroutine)::
Control flow feature that allows computations to be suspended and resumed in a flexible manner.
(((task)))

primitive type::
Concrete type whose data consists of plain old bits.
(((primitive type)))

type union::
Type which includes as objects all instances of any of its type parameters.
(((type union)))

parametric type::
Type that is parameterized.
(((parametric type)))

functor::
Object with an associated method, so that it is callable.
(((functor)))

conversion::
Conversion allows to convert a value from one type to another.
(((conversion)))

promotion::
Converting values of mixed types to a single common type.
(((promotion)))

expression::
Julia type that holds a language construct.
(((expression)))

macro::
Way to include generated code in the final body of a program.
(((macro)))

generated functions::
Functions capable of generating specialized code depending on the types of the arguments.
(((generated functions)))

missing values::
Instances that represent data points with no value.
(((missing values)))
