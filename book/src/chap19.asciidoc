[[chap19]]
== Extra: Sintaxis

Uno de los objetivos de este libro es ense√±ar lo justo y necesario de Julia. Si hab√≠an dos formas de hacer algo, se eleg√≠a una y se evitaba mencionar la otra. O a veces, la segunda manera se dejaba como ejercicio al lector.

Ahora veremos algunas cosas que dejamos de lado, que s√≠ son √∫tiles. Julia proporciona una serie de caracter√≠sticas que no son realmente necesarias (se puede escribir un buen c√≥digo sin ellas), pero a veces permiten escribir un c√≥digo m√°s conciso, legible y/o eficiente.

Este cap√≠tulo y el siguiente discuten aquello que se ha omitido en los cap√≠tulos anteriores:

* m√°s sintaxis
* funciones, tipos y macros disponibles directamente de +Base+ 
(((Base)))
* funciones, tipos y macros de la Biblioteca Est√°ndar (Standard Library)
(((Standard Library)))

=== Tuplas con nombre

Es posible nombrar los componentes de una tupla, creando una tupla con nombre:

[source,@julia-repl-test]
----
julia> x = (a=1, b=1+1)
(a = 1, b = 2)
julia> x.a
1
----

En las tuplas con nombre, se puede acceder a los atributos con su nombre utilizando la sintaxis de punto +(x.a)+.
(((named tuple)))(((dot syntax)))


=== Funciones

La funci√≥n en Julia tambi√©n se puede definir mediante una sintaxis compacta.

[source,@julia-repl-test]
----
julia> f(x,y) = x + y
f (generic function with 1 method)
----

[[anonymous_functions]]
==== Funciones Anonimas

Podemos definir una funci√≥n sin especificar su nombre:

[source,@julia-repl-test]
----
julia> x -> x^2 + 2x - 1
#1 (generic function with 1 method)
julia> function (x)
           x^2 + 2x - 1
       end
#3 (generic function with 1 method)
----

Estos son ejemplos de _funciones an√≥nimas_. Las funciones an√≥nimas generalmente se usan como argumento de otra funci√≥n:
(((anonymous function)))(((Plots)))((("module", "Plots", see="Plots")))(((plot)))((("function", "Plots", "plot", see="plot")))

[source,jlcon]
----
julia> using Plots

julia> plot(x -> x^2 + 2x - 1, 0, 10, xlabel="x", ylabel="y")

----

<<fig19-1>> muestra el resultado del comando plot (graficar en ingl√©s).

[[fig19-1]]
.Plot
image::images/fig191.svg[pdfwidth="10cm"]

==== Argumentos con nombre

Tambi√©n se puede poner nombre a los argumentos de una funci√≥n:

[source,@julia-repl-test]
----
julia> function migrafico(x, y; style="continua", width=1, color="negro")
           ###
       end
migrafico (generic function with 1 method)
julia> migrafico(0:10, 0:10, style="dotted", color="blue")

----

Los _argumentos con nombre_ en una funci√≥n se especifican despu√©s de un punto y coma en la especificaci√≥n, pero al llamar a la funci√≥n se pueden utilizar solo comas.
(((;)))(((keyword arguments)))

==== Clausuras

Una _clausura_ es una t√©cnica que permite que una funci√≥n capture una variable definida fuera del ambito de la funci√≥n.

[source,@julia-repl-test]
----
julia> foo(x) = ()->x
foo (generic function with 1 method)

julia> bar = foo(1)
#1 (generic function with 1 method)

julia> bar()
1
----

En este ejemplo, la funci√≥n +foo+ devuelve una funci√≥n an√≥nima que tiene acceso al argumento +x+ de la funci√≥n +foo+. +bar+ apunta a la funci√≥n an√≥nima y devuelve el valor del argumento de +foo+.


=== Bloques

Un _bloque_ es una forma de agrupar varias sentencias. Un bloque comienza con la palabra reservada +begin+ y termina con +end+.
(((begin)))((("keyword", "begin", see="begin")))(((end)))(((block)))

En <<chap04>> se present√≥ la macro +@svg+:

[source,julia]
----
üê¢ = Turtle()
@svg begin
    forward(üê¢, 100)
    turn(üê¢, -90)
    forward(üê¢, 100)
end
----

En este ejemplo, la macro +@svg+ tiene un √∫nico argumento: un bloque, que agrupa 3 llamadas a funciones.

==== Bloques +let+ 

Un bloque +let+ es √∫til para crear nuevos enlaces, es decir, ubicaciones que pueden referirse a valores.
A +let+ block is useful to create new bindings, i.e. locations that can refer to values.

[source,@julia-repl-test]
----
julia> x, y, z = -1, -1, -1;

julia> let x = 1, z
           @show x y z;
       end
x = 1
y = -1
ERROR: UndefVarError: z not defined
julia> @show x y z;
x = -1
y = -1
z = -1
----

En el ejemplo, la primera macro +@show+ muestra la variable local +x+, la variable global +y+ y la variable local indefinida +z+. Las variables globales se mantienen intactas.


==== Bloques +do+

En <<reading_and_writing>> cerramos el archivo despu√©s de terminar de escribir en √©l. Esto se puede hacer autom√°ticamente usando un _Bloque do_:
(((do)))((("keyword", "do", see="do")))

[source,@julia-repl-test chap19]
----
julia> datos = "El Cid convoca a sus vasallos;\n√©stos se destierran con √©l.\n"
"El Cid convoca a sus vasallos;\n√©stos se destierran con √©l.\n"
julia> open("salida.txt", "w") do fout
           write(fout, datos)
       end
61
----

En este ejemplo, +fout+ es el archivo stream utilizado para la salida.

Esto es equivalente a:

[source,@julia-repl-test chap19]
----
julia> f = fout -> begin
           write(fout, datos)
       end
#3 (generic function with 1 method)
julia> open(f, "salida.txt", "w")
61
----

La funci√≥n an√≥nima se utiliza como primer argumento de la funci√≥n +open+:
(((open)))

[source,julia]
----
function open(f::Function, args...)
    io = open(args...)
    try
        f(io)
    finally
        close(io)
    end
end
----

Un bloque +do+ puede "capturar" variables de su alcance envolvente. Por ejemplo, la variable +datos+ en el ejemplo anterior de +open pass:[...] do+ se captura desde el √°mbito externo. 

A +do+ block can ‚Äúcapture‚Äù variables from its enclosing scope. For example, the variable +data+ in the above example of +open pass:[...] do+ is captured from the outer scope.


=== Control Flow

==== Operador ternario

El _operador ternario_, +?:+, puede utilizarse en vez de una sentencia +if-elseif+. Esta sentencia se usa cuando se necesita elegir entre diferentes expresiones con valor √∫nico.
(((?:)))((("operator", "Base", "?:", see="?:")))((("ternary operator", see="?:")))

[source,@julia-repl-test]
----
julia> a = 150
150
julia> a % 2 == 0 ? println("par") : println("impar")
even
----

La expresi√≥n que va antes de +?+ es una expresi√≥n de condici√≥n. Si la condici√≥n es +true+, eval√∫an la expresi√≥n que va antes de +:+; de lo contrario, se eval√∫a la expresi√≥n que va despu√©s de +:+.

==== Evaluaci√≥n de cortocircuito

Los operadores +&&+ y +||+ realizan una _evaluaci√≥n de cortocircuito_, es decir, se eval√∫a el siguiente argumento solo cuando es necesario para determinar el valor final.
(((&&)))(((||)))(((short-circuit evaluation)))

Por ejemplo, una funci√≥n factorial recursiva podr√≠a definirse as√≠:
(((fact)))

[source,@julia-setup]
----
function fact(n::Integer)
    n >= 0 || error("n debe ser no negativo")
    n == 0 && return 1
    n * fact(n-1)
end
----

==== Tarea (o Corrutina)

Una _tarea_ es una estructura de control que puede ceder el control de forma cooperativa sin hacer return. En Julia, una tarea puede implementarse como una funci√≥n con un objeto +Channel+ como primer argumento. Se usa un channel para pasar valores de la funci√≥n a la sentencia que la llama.

El t√©rmino "cooperativo" alude a que los programas deben cooperar para que todo el esquema de programaci√≥n funcione.

La secuencia de Fibonnaci se puede generar mediante una tarea.
(((task)))(((Channel)))((("type", "Base", "Channel", see="Channel")))(((put!)))((("function", "Base", "put!", see="put!")))

[source,@julia-setup chap19]
----
function fib(c::Channel)
    a = 0
    b = 1
    put!(c, a)
    while true
        put!(c, b)
        (a, b) = (b, a+b)
    end
end
----

+put!+ almacena valores en un objeto channel y +take!+ lee valores desde √©l:
(((take!)))((("function", "Base", "take!", see="take!")))

[source,@julia-repl-test chap19]
----
julia> fib_gen = Channel(fib);

julia> take!(fib_gen)
0
julia> take!(fib_gen)
1
julia> take!(fib_gen)
1
julia> take!(fib_gen)
2
julia> take!(fib_gen)
3
----

El constructor +Channel+ crea la tarea. La funci√≥n +fib+ se suspende despu√©s de cada llamada a +put!+ y se reanuda al llamar a +take!+. Por razones de rendimiento, se almacenan varios valores de la secuencia en el objeto channel durante un ciclo de reanudaci√≥n/suspensi√≥n.

Un objeto channel tambi√©n se puede usar como iterador:

[source,@julia-repl-test chap19]
----
julia> for val in Channel(fib)
           print(val, " ")
           val > 20 && break
       end
0 1 1 2 3 5 8 13 21
----


=== Tipos

==== Tipos Primitivos

Un tipo concreto compuesto por bits se llama _tipo primitivo_. A diferencia de la mayor√≠a de los lenguajes, en Julia podemos declarar nuestros propios tipos primitivos. Los tipos primitivos est√°ndar se definen de la misma manera:
(((primitive type)))((("keyword", "primitive type", see="primitive type")))

[source,julia]
----
primitive type Float64 <: AbstractFloat 64 end
primitive type Bool <: Integer 8 end
primitive type Char <: AbstractChar 32 end
primitive type Int64 <: Signed 64 end
----

El n√∫mero en las sentencias especifica cu√°ntos bits se requieren.

El siguiente ejemplo crea un tipo primitivo +Byte+ y un constructor:
(((Byte)))((("type", "programmer-defined", "Byte", see="Byte")))

[source,@julia-repl-test]
----
julia> primitive type Byte 8 end

julia> Byte(val::UInt8) = reinterpret(Byte, val)
Byte
julia> b = Byte(0x01)
Byte(0x01)
----

La funci√≥n +reinterpret+ se usa para almacenar los bits de un entero sin signo con 8 bits (+UInt8+) en el byte.
(((reinterpret)))((("function", "Base", "reinterpret", see="reinterpret")))(((UInt8)))((("type", "Base", "UInt8", see="UInt8")))

==== Tipos Param√©tricos

El sistema de tipos de Julia es _param√©trico_, lo que significa que los tipos pueden tener par√°metros.

Los par√°metros de un tipo se colocan despu√©s del nombre del tipo, entre llaves:
(((curly braces)))

[source,@julia-setup chap19]
----
struct Punto{T<:Real}
    x::T
    y::T
end
----

Con esto se define un nuevo tipo param√©trico, +Punto{T<:Real}+, que contiene dos "coordenadas" de tipo +T+, que puede ser cualquier tipo que tenga +Real+ como supertipo.

[source,@julia-repl-test chap19]
----
julia> Punto(0.0, 0.0)
Punto{Float64}(0.0, 0.0)
----

Adem√°s de los tipos compuestos, los tipos abstractos y los tipos primitivos tambi√©n pueden tener par√°metros.

[TIP]
====
Tener tipos concretos como atributos de estructuras es absolutamente recomendable por razones de rendimiento, por lo que esta es una buena manera de hacer que +Punto+ sea r√°pido y flexible.
Having concrete types for struct fields is absolutely recommended for performance reasons, so this is a good way to make +Point+ both fast and flexible.
====

==== Type Unions

A _type union_ is an abstract parametric type that can act as any of its argument types:
(((type union)))(((Union)))((("type", "Base", "Union", see="Union")))

[source,@julia-repl-test]
----
julia> IntOrString = Union{Int64, String}
Union{Int64, String}
julia> 150 :: IntOrString
150
julia> "Julia" :: IntOrString
"Julia"
----

A type union is in most computer language an internal construct for reasoning about types. Julia however exposes this feature to its users because efficient code can be generated when the type union has a small number of types. This feature gives the Julia programmer a tremendous flexibility for controlling dispatch.

=== Methods

==== Parametric Methods

Method definitions can also have type parameters qualifying their signature:
(((signature)))

[source,@julia-repl-test chap19]
----
julia> isintpoint(p::Point{T}) where {T} = (T === Int64)
isintpoint (generic function with 1 method)
julia> p = Point(1, 2)
Point{Int64}(1, 2)
julia> isintpoint(p)
true
----

==== Function-like Objects

Any arbitrary Julia object can be made ‚Äúcallable‚Äù. Such ‚Äúcallable‚Äù objects are sometimes called _functors_.
(((functor)))

[source,@julia-setup chap19]
----
struct Polynomial{R}
    coeff::Vector{R}
end

function (p::Polynomial)(x)
    val = p.coeff[end]
    for coeff in p.coeff[end-1:-1:1]
        val = val * x + coeff
    end
    val
end
----

To evaluate the polynomial, we simply have to call it:

[source,@julia-repl-test chap19]
----
julia> p = Polynomial([1,10,100])
Polynomial{Int64}([1, 10, 100])
julia> p(3)
931
----

=== Constructors

Parametric types can be explicitly or implicitly constructed:

[source,@julia-repl-test chap19]
----
julia> Point(1,2)         # implicit T
Point{Int64}(1, 2)
julia> Point{Int64}(1, 2) # explicit T
Point{Int64}(1, 2)
julia> Point(1,2.5)       # implicit T
ERROR: MethodError: no method matching Point(::Int64, ::Float64)
----

Default inner and outer constructors are generated for each +T+:
(((constructor)))

[source,julia]
----
struct Point{T<:Real}
    x::T
    y::T
    Point{T}(x,y) where {T<:Real} = new(x,y)
end

Point(x::T, y::T) where {T<:Real} = Point{T}(x,y);
----

and both +x+ and +y+ have to be of the same type.

When +x+ and +y+ have a different type, the following outer constructor can be defined:

[source,@julia-setup chap19]
----
Point(x::Real, y::Real) = Point(promote(x,y)...);
----

The +promote+ function is detailed in <<promotion>>.
(((promote)))((("function", "Base", "promote", see="promote")))

=== Conversion and Promotion

Julia has a system for promoting arguments to a common type. This is not done automatically but can be easily extended.

==== Conversion

A value can be converted from one type to another:
(((conversion)))(((convert)))((("function", "Base", "convert", see="convert")))

[source,@julia-repl-test]
----
julia> x = 12
12
julia> typeof(x)
Int64
julia> convert(UInt8, x)
0x0c
julia> typeof(ans)
UInt8
----

We can add our own +convert+ methods:
[source,@julia-repl-test chap19]
----
julia> Base.convert(::Type{Point{T}}, x::Array{T, 1}) where {T<:Real} = Point(x...)

julia> convert(Point{Int64}, [1, 2])
Point{Int64}(1, 2)
----

[[promotion]]
==== Promotion

_Promotion_ is the conversion of values of mixed types to a single common type:
(((promotion)))(((promote)))

[source,@julia-repl-test]
----
julia> promote(1, 2.5, 3)
(1.0, 2.5, 3.0)
----

Methods for the +promote+ function are normally not directly defined, but the auxiliary function +promote_rule+ is used to specify the rules for promotion:
(((promote_rule)))((("function", "Base", "promote_rule", see="promote_rule")))

[source,julia]
----
promote_rule(::Type{Float64}, ::Type{Int32}) = Float64
----

=== Metaprogramming

Julia code can be represented as a data structure of the language itself. This allows a program to transform and generate its own code. 

==== Expressions

Every Julia program starts as a string:

[source,@julia-repl-test chap19]
----
julia> prog = "1 + 2"
"1 + 2"
----

The next step is to parse each string into an object called an _expression_, represented by the Julia type +Expr+:
(((expression)))(((Expr)))((("type", "Base", "Expr", see="Expr")))(((parse)))((("function", "Meta", "parse", see="parse")))

[source,@julia-repl-test chap19]
----
julia> ex = Meta.parse(prog)
:(1 + 2)
julia> typeof(ex)
Expr
julia> dump(ex)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 2
----

The +dump+ function displays expr objects with annotations.
(((dump)))

Expressions can be constructed directly by prefixing with +:+ inside parentheses or using a quote block
(((:)))(((quote)))((("keyword", "quote", see="quote")))

[source,@julia-repl-test chap19]
----
julia> ex = quote
           1 + 2
       end;
----

==== +eval+

Julia can evaluate an expression object using +eval+:
(((eval)))((("function", "Core", "eval", see="eval")))

[source,@julia-eval chap19]
----
import Base.eval
----

[source,@julia-repl-test chap19]
----
julia> eval(ex)
3
----

Every module has its own +eval+ function that evaluates expressions in its scope.

[WARNING]
====
When you are using a lot of calls to the function +eval+, often this means that something is wrong. +eval+ is considered ‚Äúevil‚Äù.
====

==== Macros

Macros can include generated code in a program. A _macro_ maps a tuple of +Expr+ objects directly to a compiled expression:
(((macro)))

Here is a simple macro:
(((@containervariable)))((("macro", "programmer-defined", "@containervariable", see="@containervariable")))

[source,@julia-setup chap19]
----
macro containervariable(container, element)
    return esc(:($(Symbol(container,element)) = $container[$element]))
end
----

Macros are called by prefixing their name with the +@+ (at-sign). The macro call +@containervariable letters 1+ is replaced by:
(((@)))

[source,julia]
----
:(letters1 = letters[1])
----

+@macroexpand @containervariable letters 1+  returns this expression which is extremely useful for debugging.
(((@macroexpand)))((("macro", "Base", "@macroexpand", see="@macroexpand")))

This example illustrates how a macro can access the name of its arguments, something a function can‚Äôt do. The return expression needs to be ‚Äúescaped‚Äù with +esc+ because it has to be resolved in the macro call environment.
(((esc)))((("function", "Base", "esc", see="esc")))

[NOTE]
====
Why macros?

Macros generate and include fragments of customized code during parse time, thus _before_ the full program is run.
====

==== Generated Functions

The macro +@generated+ creates specialized code for methods depending on the types of the arguments:
(((generated functions)))(((@generated)))((("macro", "Base", "@generated", see="@generated")))

[source,@julia-setup chap19]
----
@generated function square(x)
    println(x)
    :(x * x)
end
----

The body returns a quoted expression like a macro.

For the caller, the _generated function_ behaves as a regular function:

[source,@julia-repl-test chap19]
----
julia> x = square(2); # note: output is from println() statement in the body
Int64
julia> x              # now we print x
4
julia> y = square("spam");
String
julia> y
"spamspam"
----

=== Missing Values

_Missing values_ can be represented via the +missing+ object, which is the singleton instance of the type +Missing+.
(((missing values)))(((missing)))(((Missing)))((("type", "Base", "Missing", see="Missing")))

Arrays can contain missing values:

[source,@julia-repl-test chap19]
----
julia> a = [1, missing]
2-element Array{Union{Missing, Int64},1}:
 1
  missing
----

The element type of such an array is +Union{Missing, T}+, with +T+ the type of the non-missing values.

Reduction functions return +missing+ when called on arrays which contain missing values

[source,@julia-repl-test chap19]
----
julia> sum(a)
missing
----

In this situation, use the +skipmissing+ function to skip missing values:
(((skipmissing)))((("function", "Base", "skipmissing", see="skipmissing")))

[source,@julia-repl-test chap19]
----
julia> sum(skipmissing([1, missing]))
1
----


=== Calling C and Fortran Code

A lot of code is written in C or Fortran. Reusing tested code is often better than writing your own version of an algorithm. Julia can call directly existing C or Fortran libraries using the +ccall+ syntax.
(((ccall)))((("function", "Base", "ccall", see="ccall")))

In <<databases>> we introduced a Julia interface to the GDBM library of database functions. The library is written in C. To close the database a function call to +close(db)+ has to be made:

[source,julia]
----
Base.close(dbm::DBM) = gdbm_close(dbm.handle)

function gdbm_close(handle::Ptr{Cvoid})
    ccall((:gdbm_close, "libgdbm"), Cvoid, (Ptr{Cvoid},), handle)
end
----

A dbm object has a field +handle+ of +Ptr{Cvoid}+ type. This field holds a C pointer that refers to the database. To close the database the C function +gdbm_close+ has to be called having as only argument the C pointer pointing to the database and no return value. Julia does this directly with the +ccall+ function having as arguments:
(((Ptr)))((("type", "Base", "Ptr", see="Ptr")))

* a tuple consisting of a symbol holding the name of the function we want to call: +:gdbm_close+ and the shared library specified as a string: +"libgdm"+,

* the return type: +Cvoid+,

* a tuple of argument types: +(Ptr{Cvoid},)+ and

* the argument values: +handle+.

The complete mapping of the GDBM library can be found as an example in the PiensaEnJulia sources.

=== Glossary

closure::
Function that captures variables from its defining scope.
(((closure)))

let block::
Block allocating new variable bindings.
(((let block)))

anonymous function::
Function defined without being given a name.
(((anonymous function)))

named tuple::
Tuple with named components.
(((named tuple)))

keyword arguments::
Arguments identified by name instead of only by position.
(((keyword arguments)))

do block::
Syntax construction used to define and call an anonymous function which looks like a normal code block.
(((do block)))

ternary operator::
Control flow operator taking three operands to specify a condition, an expression to be executed when the condition yields +true+ and an expression to be executed when the condition yields +false+.
(((ternary operator)))

short-circuit evaluation::
Evaluation of a boolean operator for which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression.
(((short-circuit evaluation)))

task (aka coroutine)::
Control flow feature that allows computations to be suspended and resumed in a flexible manner.
(((task)))

primitive type::
Concrete type whose data consists of plain old bits.
(((primitive type)))

type union::
Type which includes as objects all instances of any of its type parameters.
(((type union)))

parametric type::
Type that is parameterized.
(((parametric type)))

functor::
Object with an associated method, so that it is callable.
(((functor)))

conversion::
Conversion allows to convert a value from one type to another.
(((conversion)))

promotion::
Converting values of mixed types to a single common type.
(((promotion)))

expression::
Julia type that holds a language construct.
(((expression)))

macro::
Way to include generated code in the final body of a program.
(((macro)))

generated functions::
Functions capable of generating specialized code depending on the types of the arguments.
(((generated functions)))

missing values::
Instances that represent data points with no value.
(((missing values)))
