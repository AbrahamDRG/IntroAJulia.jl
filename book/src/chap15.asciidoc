[[chap15]]
== Estructuras y Objetos

A esta altura, ya debe saber cómo usar funciones para tener un código más organizado, y cómo usar los tipos integrados de Julia para organizar sus datos. El siguiente paso es aprender a construir sus propios tipos para organizar tanto el código como los datos. Este es un gran tema, y por lo tanto tomará un par de capítulos abarcar todo.

=== Tipos Compuestos

Hemos utilizado muchos tipos integrados en Julia; ahora vamos a definir un nuevo tipo. A modo de ejemplo, crearemos un tipo llamado +Punto+ que represente un punto en un espacio bidimensional.
(((type)))(((Point)))((("type", "programmer-defined", "Point", see="Point")))

En notación matemática, los puntos suelen escribirse entre paréntesis con una coma que separa las coordenadas. Por ejemplo, latexmath:[\(\left(0,0\right)\)] representa el origen, y latexmath:[\(\left(x,y\right)\)] representa el punto localizado latexmath:[\(x\)] unidades a la derecha y latexmath:[\(y\)] unidades hacia arriba del origen.

Hay varias formas en que podríamos representar puntos del plano cartesiano en Julia:

* Podríamos almacenar las coordenadas por separado en dos variables, +x+ e +y+.

* Podríamos almacenar las coordenadas como elementos de una matriz o tupla.

* Podríamos crear un nuevo tipo para representar puntos como objetos.

Crear un nuevo tipo exige un poco más de esfuerzo que las otras opciones, pero tiene algunas ventajas que veremos pronto.

Un _tipo compuesto_ definido por el programador también se denomina _estructura_ (struct en inglés). La definición de +estructura+ de un punto se ve así:
(((composite type)))(((struct)))((("keyword", "struct", see="struct")))(((end)))

[source,@julia-setup chap15]
----
struct Punto
    x
    y
end
----

El encabezado indica que la nueva estructura se llama +Punto+. El cuerpo define los _atributos_ o _campos_ de la estructura. La estructura de +Punto+ tiene dos campos: +x+ e +y+.
(((attribute)))((("field", see="attribute")))

Una estructura es como una fábrica que crea objetos. Para crear un punto, debes llamar a +Punto+ como si fuera una función que tiene como argumentos los valores de los campos. Cuando +Punto+ se usa como una función, se llama _constructor_.
(((constructor)))

[source,@julia-repl-test chap15]
----
julia> p = Punto(3.0, 4.0)
Punto(3.0, 4.0)
----

El valor de retorno es una referencia a un objeto +Punto+, el cual asignamos a +p+.
(((reference)))

La creación de un nuevo objeto se llama _instanciación_, y el objeto creado es una _instancia_ del tipo.
(((instatiation)))(((instance)))

Cuando imprime una instancia, Julia le dice a qué tipo pertenece y cuáles son los valores de los atributos.

Cada objeto es una instancia de algún tipo, por lo que "objeto" e "instancia" son intercambiables. Pero en este capítulo se utiliza "instancia" para indicar que hablamos de un tipo definido por el programador.

Un diagrama de estado que muestra un objeto y sus campos se denomina _diagrama de objeto_; ver <<fig15-1>>.
(((object diagram)))((("diagram", "object", see="object diagram")))

[[fig15-1]]
.Object diagram
image::images/fig151.svg[]


=== Las Estructuras son Inmutables

Puede obtener los valores de los campos utilizando la notación +.+:
(((.)))((("dot notation", see=".")))

[source,@julia-repl-test chap15]
----
julia> x = p.x
3.0
julia> p.y
4.0
----

La expresión +p.x+ significa: "Ve al objeto al que se refiere +p+ y obtén el valor de +x+". En el ejemplo, asignamos ese valor a una variable llamada +x+. No hay conflicto entre la variable +x+ y el campo +x+.

Puede usar esa notación de punto como parte de cualquier expresión. Por ejemplo:

[source,@julia-repl-test chap15]
----
julia> distancia = sqrt(p.x^2 + p.y^2)
5.0
----

Sin embargo, las estructuras son inmutables por defecto, después de la construcción los campos no pueden cambiar su valor:
(((immutable)))

[source,@julia-repl-test chap15]
----
julia> p.y = 1.0
ERROR: setfield! immutable struct of type Point cannot be changed
----

Esto puede parecer extraño al principio, pero tiene varias ventajas:

* Puede ser más eficiente.

* No es posible violar las invariantes (requisitos que deberían cumplirse en todos los objetos, en todo momento) de los constructores de un tipo compuesto (ver <<constructor>>).

* El código que usa objetos inmutables puede ser más fácil de entender.


=== Estructuras Mutables

De ser necesario, se pueden declarar tipos compuestos mutables con la palabra reservada +mutable struct+. A continuación se muestra la definición de un punto mutable:
(((mutable composite type)))(((mutable struct)))((("keyword", "mutable struct", see="mutable struct")))(((MPoint)))((("type", "programmer-defined", "MPoint", see="MPoint")))

[source,@julia-setup chap15]
----
mutable struct MPunto
    x
    y
end
----

Puede asignar valores a una instancia de una estructura mutable utilizando notación de punto (.):
(((.)))

[source,@julia-repl-test chap15]
----
julia> blanco = MPunto(0.0, 0.0)
MPunto(0.0, 0.0)
julia> blanco.x = 3.0
3.0
julia> blanco.y = 4.0
4.0
----


=== Rectángulos

A veces, decidir cuáles deberían ser los campos de un objeto es fácil, pero en otros casos no. Por ejemplo, imagine que queremos un tipo que represente un rectángulo. ¿Qué campos usarías para especificar la ubicación y el tamaño de un rectángulo? Puedes ignorar el ángulo. Para simplificar las cosas, supongamos que el rectángulo es vertical u horizontal.

Hay al menos dos posibilidades:

* Puede especificar una esquina del rectángulo (o el centro), el ancho y la altura.

* Podría especificar dos esquinas opuestas.

Es difícil decir que una opción es mejor que la otra, por lo que implementaremos la primera, a modo de ejemplo.
(((Rectangle)))((("type", "programmer-defined", "Rectangle", see="Rectangle")))

[source,@julia-setup chap15]
----
"""
Representa un rectángulo.

atributos: ancho, alto, esquina. 
"""
struct Rectangle
    ancho
    alto
    esquina
end
----

El texto escrito entre triples comillas dentro del programa permite documentar, y es llamado cadena de documentación (o docstring). Por otra parte, la documentación es el acto de comentar convenientemente cada una de las partes que tiene el programa.

En este ejemplo, la cadena de documentación (o docstring) enumera los atributos. Los atributos ancho y alto son números, y esquina es un objeto +Punto+ que especifica la esquina inferior izquierda.
(((docstring)))

Para representar un rectángulo, debe crear una instancia del tipo +Rectangulo+:

[source,@julia-repl-test chap15]
----
julia> origen = MPunto(0.0, 0.0)
MPunto(0.0, 0.0)
julia> caja = Rectangulo(100.0, 200.0, origen)
Rectangulo(100.0, 200.0, MPunto(0.0, 0.0))
----

<<fig15-2>> muestra el estado de este objeto. Un objeto es _embebido_ si es atributo de otro objeto. Debido a que el atributo +esquina+ se refiere a un objeto mutable, se dibuja fuera del objeto +Rectangulo+.
(((embedded)))(((object diagram)))

[[fig15-2]]
.Object diagram
image::images/fig152.svg[]


=== Instancias como Argumentos

Podemos pasar una instancia como argumento de la manera habitual. Por ejemplo:
(((printpoint)))((("function", "programmer-defined", "printpoint", see="printpoint")))

[source,@julia-setup chap15]
----
function imprimirpunto(p)
    println("($(p.x), $(p.y))")
end
----

+imprimirpunto+ toma un +Punto+ como argumento y lo muestra en notación matemática. Puede llamar a imprimirpunto con un argumento +p+:

[source,@julia-repl-test chap15]
----
julia> imprimirpunto(blanco)
(3.0, 4.0)
----

==== Ejercicio 15-1

Escriba una función llamada +distanciaentrepuntos+ que tome dos puntos como argumentos y devuelva la distancia entre ellos.
(((distancebetweenpoints)))((("function", "programmer-defined", "distancebetweenpoints", see="distancebetweenpoints")))

Si un objeto de estructura mutable se pasa a una función como argumento, la función puede modificar los campos del objeto. Por ejemplo, +moverpunto!+ toma un objeto mutable +Punto+ y dos números, +dx+ y +dy+, los cuales suma a los atributos +x+ e +y+ de +Punto+, respectivamente:
(((movepoint!)))((("function", "programmer-defined", "movepoint!", see="movepoint!")))

[source,@julia-setup chap15]
----
function moverpunto!(p, dx, dy)
    p.x += dx
    p.y += dy
    nothing
end
----

Aquí hay un ejemplo que muestra como funciona:

[source,@julia-repl-test chap15]
----
julia> origen = MPunto(0.0, 0.0)
MPunto(0.0, 0.0)
julia> moverpunto!(origen, 1.0, 2.0)

julia> origen
MPoint(1.0, 2.0)
----

Dentro de la función, +p+ es un alias de +origen+, por lo que cuando la función modifica +p+, +origen+ también cambia.
(((aliasing)))

Al pasar un objeto inmutable +Punto+ a +moverpunto!+ se produce un error:

[source,@julia-repl-test chap15]
----
julia> moverpunto!(p, 1.0, 2.0)
ERROR: setfield! immutable struct of type Point cannot be changed
----

Sin embargo, puede modificar el valor de un atributo mutable de un objeto inmutable. Por ejemplo, +moverrectangulo!+ tiene como argumentos un objeto +Rectangulo+ y dos números, +dx+ y +dy+. Esta función usa +moverpunto!+ para mover la esquina del rectángulo:

[source,@julia-setup chap15]
----
function moverrectangulo!(rect, dx, dy)
  moverpunto!(rect.esquina, dx, dy)
end
----

Ahora +p+ en +moverpunto!+ es un alias para +rect.esquina+, por lo que cuando +p+ se modifica, +rect.esquina+ también cambia:

Now +p+ in +movepoint!+ is an alias for +rect.corner+, so when +p+ is modified, +rect.corner+ changes also:

[source,@julia-repl-test chap15]
----
julia> caja
Rectangulo(100.0, 200.0, MPunto(0.0, 0.0))
julia> moverrectangulo!(caja, 1.0, 2.0)

julia> caja
Rectangulo(100.0, 200.0, MPunto(1.0, 2.0))
----

[WARNING]
====
You cannot reassign a mutable attribute of an immutable object:
(((reassignment)))

[source,@julia-repl-test chap15]
----
julia> box.corner = MPoint(1.0, 2.0)
ERROR: setfield! immutable struct of type Rectangle cannot be changed
----
====

=== Instances as Return Values

Functions can return instances. For example, +findcenter+ takes a +Rectangle+ as an argument and returns a +Point+ that contains the coordinates of the center of the rectangle:
(((findcenter)))((("function", "programmer-defined", "findcenter", see="findcenter")))

[source,@julia-setup chap15]
----
function findcenter(rect)
    Point(rect.corner.x + rect.width / 2, rect.corner.y + rect.height / 2)
end
----

The expression +rect.corner.x+ means, “Go to the object +rect+ refers to and select the field named +corner+; then go to that object and select the field named +x+.”

Here is an example that passes +box+ as an argument and assigns the resulting +Point+ to +center+:

[source,@julia-repl-test chap15]
----
julia> center = findcenter(box)
Point(51.0, 102.0)
----


=== Copying

Aliasing can make a program difficult to read because changes in one place might have unexpected effects in another place. It is hard to keep track of all the variables that might refer to a given object.
(((aliasing)))

Copying an object is often an alternative to aliasing. Julia provides a function called +deepcopy+ that can duplicate any object:
(((copying)))(((deepcopy)))((("function", "Base", "deepcopy", see="deepcopy")))(((deep copy)))

[source,@julia-repl-test chap15]
----
julia> p1 = MPoint(3.0, 4.0)
MPoint(3.0, 4.0)
julia> p2 = deepcopy(p1)
MPoint(3.0, 4.0)
julia> p1 ≡ p2
false
julia> p1 == p2
false
----

The +≡+ operator indicates that +p1+ and +p2+ are not the same object, which is what we expected. But you might have expected +==+ to yield +true+ because these points contain the same data. In that case, you will be disappointed to learn that for mutable objects, the default behavior of the +==+ operator is the same as the +===+ operator; it checks object identity, not object equivalence. That’s because for mutable composite types, Julia doesn’t know what should be considered equivalent. At least, not yet.
(((==)))(((≡)))

==== Exercise 15-2

Create a +Point+ instance, make a copy of it and check the equivalence and the egality of both. The result can surprise you but it explains why aliasing is a non issue for an immutable object.


=== Debugging

When you start working with objects, you are likely to encounter some new exceptions. If you try to access a field that doesn’t exist, you get:
(((debugging)))

[source,@julia-repl-test chap15]
----
julia> p = Point(3.0, 4.0)
Point(3.0, 4.0)
julia> p.z = 1.0
ERROR: type Point has no field z
----

If you are not sure what type an object is, you can ask:
(((typeof)))

[source,@julia-repl-test chap15]
----
julia> typeof(p)
Point
----

You can also use +isa+ to check whether an object is an instance of a type:
(((isa)))((("operator", "Base", "isa", see="isa")))

[source,@julia-repl-test chap15]
----
julia> p isa Point
true
----

If you are not sure whether an object has a particular attribute, you can use the built-in function +fieldnames+:
(((deepcopy)))((("function", "Base", "deepcopy", see="deepcopy")))

[source,@julia-repl-test chap15]
----
julia> fieldnames(Point)
(:x, :y)
----

or the function +isdefined+:
(((isdefined)))((("function", "Base", "isdefined", see="isdefined")))

[source,@julia-repl-test chap15]
----
julia> isdefined(p, :x)
true
julia> isdefined(p, :z)
false
----

The first argument can be any object; the second argument is a symbol, +:+ followed by the name of the field.
(((:)))(((Symbol)))((("type", "Base", "Symbol", see="Symbol")))

=== Glossary

struct::
A composite type. 
(((struct)))

constructor::
A function with the same name as a type that creates instances of the type.
(((constructor)))

instance::
An object that belongs to a type.
(((instance)))

instantiate::
To create a new object.
(((instantiate)))

attribute or field::
One of the named values associated with an object.
(((attribute)))

embedded object::
An object that is stored as a field of another object.
(((embedded object)))

deep copy::
To copy the contents of an object as well as any embedded objects, and any objects embedded in them, and so on; implemented by the +deepcopy+ function.
(((deep copy)))

object diagram::
A diagram that shows objects, their fields, and the values of the fields.
(((object diagram)))


=== Exercises

[[ex15-1]]
==== Exercise 15-3

. Write a definition for a type named +Circle+ with fields +center+ and +radius+, where +center+ is a +Point+ object and +radius+ is a number.
(((Circle)))((("type", "programmer-defined", "Circle", see="Circle")))

. Instantiate a circle object that represents a circle with its center at latexmath:[\(\left(150, 100\right)\)] and radius 75.

. Write a function named +pointincircle+ that takes a +Circle+ object and a +Point+ object and returns +true+ if the point lies in or on the boundary of the circle.
(((pointincircle)))((("function", "programmer-defined", "pointincircle", see="pointincircle")))

. Write a function named +rectincircle+ that takes a +Circle+ object and a +Rectangle+ object and returns +true+ if the rectangle lies entirely in or on the boundary of the circle.
(((rectincircle)))((("function", "programmer-defined", "rectincircle", see="rectincircle")))

. Write a function named +rectcircleoverlap+ that takes a +Circle+ object and a +Rectangle+ object and returns +true+ if any of the corners of the rectangle fall inside the circle. Or as a more challenging version, return +true+ if any part of the rectangle falls inside the circle.
(((rectcircleoverlap)))((("function", "programmer-defined", "rectcircleoverlap", see="rectcircleoverlap")))

[[ex15-2]]
==== Exercise 15-4

. Write a function called +drawrect+ that takes a turtle object and a +Rectangle+ object and uses the turtle to draw the rectangle. See Chapter 4 for examples using +Turtle+ objects.
(((drawrect)))((("function", "programmer-defined", "drawrect", see="drawrect")))

. Write a function called +drawcircle+ that takes a +Turtle+ object and a +Circle+ object and draws the circle.
(((drawcircle)))((("function", "programmer-defined", "drawcircle", see="drawcircle")))

