[[chap21]]
== Depuración

Al depurar, es necesario distinguir entre los diferentes tipos de errores para rastrearlos más rápidamente:

* Los errores de sintaxis se descubren cuando el intérprete traduce el código fuente a código de bytes. Estos errores indican que hay una falla en la estructura del programa. Por ejemplo, omitir la palabra reservada +end+ al final de un bloque de funciones genera el mensaje +ERROR: LoadError: syntax: incomplete: function requires end+.
(((syntax error)))

* Los errores en tiempo de ejecución se presentan si algo falla mientras se ejecuta el programa. La mayoría de los mensajes de error en tiempo de ejecución indican dónde ocurrió el error y qué funciones se estaban ejecutando. Ejemplo: Una recursión infinita eventualmente causa el error en tiempo de ejecución +ERROR: StackOverflowError+.
(((runtime error)))

* Los errores semánticos ocurren cuando un programa se ejecuta sin generar mensajes de error pero no hace lo que debería. Por ejemplo: una expresión puede no evaluarse en el orden esperado, generando un resultado incorrecto.
(((semantic error)))

El primer paso en la depuración es averiguar el tipo de error al que se enfrenta. Aunque las siguientes secciones están organizadas por tipo de error, algunas técnicas son aplicables en más de una situación.


=== Errores de Sintaxis

Los errores de sintaxis suelen ser fáciles de corregir una vez que se descubre cuáles son. Desafortunadamente, muchas veces los mensajes de error no son útiles. Los mensajes más comunes son +ERROR: LoadError: syntax: incomplete: premature end of input+ y +ERROR: LoadError: syntax: unexpected "="+, los cuales no son muy informativos.

Por otro lado, el mensaje indica en qué parte del programa se produjo el problema. En realidad, indica dónde Julia notó que había un problema, que no es necesariamente dónde está el error. A veces, el error es anterior a la ubicación del mensaje de error, generalmente en la línea anterior.

Si está programando incrementalmente, debería tener casi localizado el error. Estará en la última línea que agregó.

Si está copiando código de un libro, comience comparando su código con el código del libro. Verifique cada letra. Al mismo tiempo, recuerde que el libro puede contener errores, por lo que si ve algo que parece un error de sintaxis, es posible que lo sea.

Aquí hay algunas formas de evitar los errores de sintaxis más comunes:

. Asegúrese de no estar usando una palabra reservada de Julia en un nombre de variable.

. Compruebe que tiene la palabra reservada +end+ al final de cada sentencia compuesta, incluyendo los bloques +for+, +while+, +if+ y +function+.

. Asegúrese de que las cadenas tengan su par de comillas de apertura y cierre. Asegúrese de que todas las comillas sean "comillas rectas", y no otro tipo de "comillas".

. Si tiene cadenas que ocupan varias líneas con triples comillas, asegúrese de que ha terminado la cadena correctamente. Una cadena sin terminar puede provocar un error invalid token al final de su programa, o puede hacer que la siguiente parte del programa sea tratada como una cadena hasta llegar a la siguiente cadena. ¡El segundo caso podría no presentar mensaje de error!

. Un paréntesis sin cerrar —+(+, +{+, or +[+— hace que Julia continúe con la línea siguiente como parte de la sentencia actual. Generalmente, se produce un error casi inmediatamente en la siguiente línea.

. Verifique el clásico error que se produce al ocupar +=+ en lugar de +==+ dentro de un condicional.

. Si tiene caracteres que no son ASCII en el código (incluidas cadenas y comentarios), esto podría causar un problema, aunque Julia generalmente maneja caracteres no ASCII. Tenga cuidado si pega texto de una página web u otra fuente.

Si nada funciona, pase a la siguiente sección ...


==== Sigo haciendo cambios y no hay diferencia

Si el REPL dice que hay un error y usted no lo ve, podría deberse a que usted y el REPL no están viendo el mismo código. Verifique su entorno de programación para asegurarse de que el programa que está editando es el que Julia está tratando de ejecutar.

Si no está seguro, intente poner un error de sintaxis obvio y deliberado al comienzo del programa. Ahora ejecútelo de nuevo. Si REPL no encuentra el nuevo error, no está ejecutando el nuevo código.

Estas son algunas de las posibles razones:

* Editó el archivo y olvidó guardar los cambios antes de ejecutarlo nuevamente. Algunos entornos de programación hacen esto por usted, pero otros no.

* Cambió el nombre del archivo, pero aún está ejecutando el archivo con el nombre anterior.

* Algo en su entorno de desarrollo está configurado incorrectamente.

* Si está escribiendo un módulo y está usando +using+, asegúrese de no darle a su módulo el mismo nombre que uno de los módulos estándar de Julia.

* Si está usando +using+ para importar un módulo, recuerde que debe reiniciar REPL cuando modifique el código en el módulo. Si vuelve a importar el módulo, no ocurre nada.

Si se queda atascado y no puede darse cuenta de lo que está sucediendo, un enfoque es comenzar de nuevo con un nuevo programa como "¡Hola, Mundo!" y asegurarse de que puede ejecutar este programa ya conocido. Luego, puede agregar gradualmente las piezas del programa original al nuevo.


=== Errores en Tiempo de Ejecución

Una vez que su programa es sintácticamente correcto, Julia puede leerlo y al menos comenzar a ejecutarlo. ¿Qué podría salir mal?

==== Mi programa no hace absolutamente nada

Este problema es común cuando su archivo consta de funciones y clases, pero en realidad no llama a ninguna función para iniciar la ejecución. Esto puede ser intencional si solo se busca importar este módulo para suministrar clases y funciones.

Si no es intencional, asegúrese de que haya una llamada a la función en el programa, y asegúrese de que el flujo de ejecución pase por esta llamada (vea <<flow_of_execution>>).
(((flow of execution)))


==== Mi programa se congela

Si un programa se detiene y parece no estar haciendo nada, está "congelado". Generalmente eso significa que está atrapado en un bucle infinito o en una recursión infinita.

* Si hay un bucle en particular que le resulta sospechoso de provocar el pproblema, agregue una sentencia de impresión justo antes del bucle que diga "entrando al bucle" y otra inmediatamente posterior que diga "saliendo del bucle".
+
Ejecute el programa. Si recibe el primer mensaje y no el segundo, tiene un bucle infinito. Vea <<infinite_loop>>.
(((infinite loop)))

* La mayoría de las veces, una recursión infinita hará que el programa se ejecute por un rato y luego produzca un error +ERROR: LoadError: StackOverflowError+. Si eso sucede, vea <<infinite_recursion>>.
+
Si no obtiene este error pero sospecha que hay un problema con un método o función recursiva, igual puede utilizar las técnicas de <<infinite_recursion>>.
(((infinite recursion)))

* Si ninguno de esos pasos funciona, comience a probar otros bucles, y otras funciones y métodos recursivos.

* Si esto no funciona, quizás es porque no entiendes el flujo de ejecución de tu programa. Vea <<flow_of_execution>>.


[[infinite_loop]]
===== Bucle Infinito

Si crees que tienes un bucle infinito y crees saber cuál es, añada una sentencia de impresión que imprima los valores de las variables de la condición al final del bucle junto con el valor de la condición.

Por ejemplo:

[source,julia]
----
while x > 0 && y < 0
    # hacer algo con x
    # hacer algo con y
    @debug "variables" x y
    @debug "condicion" x > 0 && y < 0
end
----

Ahora, cuando ejecute el programa en modo de depuración, verá el valor de las variables y la condición en cada iteración. En la última iteración, la condición debe ser +false+. Si el ciclo continúa, podrá ver los valores de +x+ e +y+, y podrá averiguar por qué no
se actualizan correctamente.

[[infinite_recursion]]
===== Infinite Recursion

La mayoría de las veces, una recursión infinita hace que el programa se ejecute durante un tiempo y luego produzca un error +ERROR: LoadError: StackOverflowError+.
(((StackOverflowError)))

Si sospecha que una función o un método está causando una recursión infinita, comience por asegurarse de que hay un caso base. En otras palabras, debería haber una condición que haga que la función devuelva un valor sin hacer otra llamada recursiva. Si no, necesita revisar el algoritmo y encontrar ese caso base.

Si hay un caso base pero el programa no parece llegar hasta él, añada una sentencia de impresión al inicio de la función que imprima los parámetros. Ahora, cuando ejecute el programa, verá unas pocas líneas cada vez que se llame la función, y allí verá los parámetros. Si los parámetros no se acercan al caso base, eso le dará alguna idea de por qué no lo hace.

[[flow_of_execution]]
===== Flujo de Ejecución

Si no está seguro del flujo de ejecución en su programa, añada sentencias de impresión al principio de cada función con mensajes como “entrando a la función fun”, donde fun sea el nombre de la función.

Ahora, cuando ejecute el programa, se imprimirá una mensaje en cada función a medida que estas sean llamadas.

==== Cuando ejecuto el programa recibo una excepción.

Si algo sale mal durante la ejecución, Julia imprime un mensaje que incluye el nombre de la excepción, la línea del programa donde sucedió el problema y un trazado inverso.

El trazado inverso identifica la función que se está ejecutando y la función que la llamó, y luego la función que llamó a esa, y así sucesivamente. En otras palabras, traza la ruta de las llamadas a las funciones que le llevaron a donde se encuentra. También incluye los numeros de las líneas de su archivo donde suceden todas esas llamadas.

El primer paso es examinar el lugar del programa donde ocurrió el error y ver si puede adivinar lo que sucedió. Estos son algunos de los errores en tiempo de ejecución más comunes:

ArgumentError:: 
Uno de los argumentos para llamar a una función no tiene la forma esperada.
(((ArgumentError)))

BoundsError::
Una operación de indexación en un arreglo intentó acceder a un elemento fuera de los límites.
An indexing operation into an array tried to access an out-of-bounds element.
(((BoundsError)))

DomainError::
El argumento de una función o constructor no pertenece al dominio válido.
(((DomainError)))((("error", "Core", "DomainError", see="DomainError")))

DivideError:: 
Se intentó dividir un entero por 0.
(((DivideError)))((("error", "Core", "DivideError", see="DivideError")))

EOFError:: 
No había más datos disponibles para leer desde un archivo o stream.
(((EOFError)))((("error", "Base", "EOFError", see="EOFError")))

InexactError::
No se puede convertir a un tipo.
(((InexactError)))((("error", "Core", "InexactError", see="InexactError")))

KeyError::
Se está tratando de acceder o eliminar un elemento inexistente de un objeto +AbstractDict+ (+Dict+) o +Set+.
(((KeyError)))

MethodError:: 
No existe un método con la especificación de tipo requerida en la función genérica dada. Alternativamente, no existe un método único más específico.
(((MethodError)))

OutOfMemoryError:: 
Una operación asignó demasiada memoria para que el sistema o el recolector de basura opere correctamente.
(((OutOfMemoryError)))((("error", "Core", "OutOfMemoryError", see="OutOfMemoryError")))

OverflowError:: 
El resultado de una expresión es demasiado grande para el tipo especificado y provocará una envoltura.
The result of an expression is too large for the specified type and will cause a wraparound.
(((OverflowError)))((("error", "Core", "OverflowError", see="OverflowError")))

StackOverflowError:: 
La llamada a la función creció más allá del tamaño de la pila de llamadas. Esto generalmente ocurre cuando una llamada se repite infinitamente.
The function call grew beyond the size of the call stack. This usually happens when a call recurses infinitely.
(((StackOverflowError)))

StringIndexError::
Se produjo un error al intentar acceder a un índice inválido de una cadena.
(((StringIndexError)))

SystemError::
Una llamada al sistema falló con un código de error.
A system call failed with an error code.
(((SystemError)))

TypeError::
A type assertion failure, or calling an intrinsic function with an incorrect argument type.
(((TypeError)))

UndefVarError:: 
A symbol in the current scope is not defined.
(((UndefVarError)))

==== I added so many print statements I get inundated with output

One of the problems with using print statements for debugging is that you can end up buried in output. There are two ways to proceed: simplify the output or simplify the program.

To simplify the output, you can remove or comment out print statements that aren’t helping, or combine them, or format the output so it is easier to understand.

To simplify the program, there are several things you can do. First, scale down the problem the program is working on. For example, if you are searching a list, search a small list. If the program takes input from the user, give it the simplest input that causes the problem.

Second, clean up the program. Remove dead code and reorganize the program to make it as easy to read as possible. For example, if you suspect that the problem is in a deeply nested part of the program, try rewriting that part with simpler structure. If you suspect a large function, try splitting it into smaller functions and testing them separately.
(((dead code)))

Often the process of finding the minimal test case leads you to the bug. If you find that a program works in one situation but not in another, that gives you a clue about what is going on.

Similarly, rewriting a piece of code can help you find subtle bugs. If you make a change that you think shouldn’t affect the program, and it does, that can tip you off.


=== Semantic Errors

In some ways, semantic errors are the hardest to debug, because the interpreter provides no information about what is wrong. Only you know what the program is supposed to do.

The first step is to make a connection between the program text and the behavior you are seeing. You need a hypothesis about what the program is actually doing. One of the things that makes that hard is that computers run so fast.

You will often wish that you could slow the program down to human speed. Inserting a few well-placed print statements is often quicker than setting up a debugger, inserting and removing breakpoints, and “stepping” the program to where the error is occurring.

==== My program doesn’t work

You should ask yourself these questions:

* Is there something the program was supposed to do but which doesn’t seem to be happening? Find the section of the code that performs that function and make sure it is executing when you think it should.

* Is something happening that shouldn’t? Find code in your program that performs that function and see if it is executing when it shouldn’t.

* Is a section of code producing an effect that is not what you expected? Make sure that you understand the code in question, especially if it involves functions or methods in other Julia modules. Read the documentation for the functions you call. Try them out by writing simple test cases and checking the results.

In order to program, you need a mental model of how programs work. If you write a program that doesn’t do what you expect, often the problem is not in the program; it’s in your mental model.
(((mental model)))

The best way to correct your mental model is to break the program into its components (usually the functions and methods) and test each component independently. Once you find the discrepancy between your model and reality, you can solve the problem.

Of course, you should be building and testing components as you develop the program. If you encounter a problem, there should be only a small amount of new code that is not known to be correct.

==== I’ve got a big hairy expression and it doesn’t do what I expect

Writing complex expressions is fine as long as they are readable, but they can be hard to debug. It is often a good idea to break a complex expression into a series of assignments to temporary variables.

For example:

[source,julia]
----
addcard(game.hands[i], popcard(game.hands[findneighbor(game, i)]))
----

This can be rewritten as:

[source,julia]
----
neighbor = findneighbor(game, i)
pickedcard = popcard(game.hands[neighbor])
addcard(game.hands[i], pickedcard)
----

The explicit version is easier to read because the variable names provide additional documentation, and it is easier to debug because you can check the types of the intermediate variables and display their values.

Another problem that can occur with big expressions is that the order of evaluation may not be what you expect. For example, if you are translating the expression latexmath:[\(\frac{x}{2\pi}\)] into Julia, you might write:

[source,julia]
----
y = x / 2 * π
----

That is not correct because multiplication and division have the same precedence and are evaluated from left to right. So this expression computes latexmath:[\(\frac{x\pi}{2}\)].

A good way to debug expressions is to add parentheses to make the order of evaluation explicit:

[source,julia]
----
y = x / (2 * π)
----

Whenever you are not sure of the order of evaluation, use parentheses. Not only will the program be correct (in the sense of doing what you intended), it will also be more readable for other people who haven’t memorized the order of operations.

==== I’ve got a function that doesn’t return what I expect

If you have a return statement with a complex expression, you don’t have a chance to print the result before returning. Again, you can use a temporary variable. For example, instead of:
(((temporary variable)))

[source,julia]
----
return removematches(game.hands[i])
----

you could write:

[source,julia]
----
count = removematches(game.hands[i])
return count
----

Now you have the opportunity to display the value of +count+ before returning.

==== I’m really, really stuck and I need help

First, try getting away from the computer for a few minutes. Working with a computer can cause these symptoms:

* Frustration and rage.

* Superstitious beliefs (“the computer hates me”) and magical thinking (“the program only works when I wear my hat backward”).

* Random walk programming (the attempt to program by writing every possible program and choosing the one that does the right thing).

If you find yourself suffering from any of these symptoms, get up and go for a walk. When you are calm, think about the program. What is it doing? What are some possible causes of that behavior? When was the last time you had a working program, and what did you do next?

Sometimes it just takes time to find a bug. I often find bugs when I am away from the computer and let my mind wander. Some of the best places to find bugs are trains, showers, and in bed, just before you fall asleep.

==== No, I really need help

It happens. Even the best programmers occasionally get stuck. Sometimes you work on a program so long that you can’t see the error. You need a fresh pair of eyes.

Before you bring someone else in, make sure you are prepared. Your program should be as simple as possible, and you should be working on the smallest input that causes the error. You should have print statements in the appropriate places (and the output they produce should be comprehensible). You should understand the problem well enough to describe it concisely.

When you bring someone in to help, be sure to give them the information they need:

* If there is an error message, what is it and what part of the program does it indicate?

* What was the last thing you did before this error occurred? What were the last lines of code that you wrote, or what is the new test case that fails?

* What have you tried so far, and what have you learned?

When you find the bug, take a second to think about what you could have done to find it faster. Next time you see something similar, you will be able to find the bug more quickly.

Remember, the goal is not just to make the program work. The goal is to learn how to make the program work.

