[[chap20]]
== Extra: Base y Librería Estándar

Julia viene con pilas incluidas. El módulo +Base+ contiene las funciones, tipos y macros más útiles. Los cuales están disponibles directamente en Julia.
(((Base)))

Julia también posee una gran cantidad de módulos especializados en su Biblioteca Estándar (módulos para Fechas, Computación Distribuida, Álgebra Lineal, Perfiles, Números Aleatorios, entre otros). Las funciones, los tipos y las macros definidos en la Biblioteca estándar deben importarse antes de poder usarse:

* +import _Module_+ importa el modulo, y +_Module.fn_(x)+ llama a la función +_fn_+
(((import)))((("keyword", "import", see="import")))
* +using _Module_+ importa todas las funciones, tipos y macros exportadas de +_Module_+.
(((using)))

Además, es posible agregar más funciones a una gran cantidad de paquetes (https://juliaobserver.com).

Este capítulo no es un reemplazo de la documentación oficial de Julia. Solo se dan algunos ejemplos para ilustrar lo que es posible hacer, sin ser exhaustivo. Las funciones ya vistas no están incluidas. Se puede encontrar una explicación más completa en https://docs.julialang.org.


=== Midiendo el Rendimiento

Hemos visto que algunos algoritmos funcionan mejor que otros. +fibonnaci+ en <<memos>> es mucho más rápido que +fib+ en <<one_more_example>>. La macro +@time+ permite cuantificar la diferencia:
(((@time)))((("macro", "Base", "@time", see="@time")))

[source,jlcon]
----
julia> fib(1)
1
julia> fibonacci(1)
1
julia> @time fib(40)
  0.567546 seconds (5 allocations: 176 bytes)
102334155
julia> @time fibonacci(40)
  0.000012 seconds (8 allocations: 1.547 KiB)
102334155
----

+@time+ imprime el tiempo que tardó en ejecutarse la función, el número de asignaciones (allocations) y la memoria asignada antes de devolver el resultado. La función fibonacci (que guardaba resultados previos) es mucho más rápida pero necesita más memoria.

[quote]
____
El teorema "No free lunch" dice que no existe un modelo que funcione mejor en todos los casos.
____

[TIP]
====

Una función en Julia se compila la primera vez que se ejecuta. Por lo tanto, para comparar dos algoritmos, estos deben implementarse como funciones para poder compilarlas, y la primera vez que se llama a estas funciones debe ser excluida de la medición de rendimiento; de lo contrario, también se mediría el tiempo de compilación.

El paquete +BenchmarkTools+ (https://github.com/JuliaCI/BenchmarkTools.jl) proporciona la macro +@btime+ que realiza una evaluación comparativa de la manera correcta. ¡Así que úsela!
====


[[collections_and_data_structures]]
=== Colecciones y Estructuras de Datos

En <<dictionary_subtraction>> usamos diccionarios para encontrar las palabras que aparecían en un documento y que no aparecían en una matriz de palabras. La función que escribimos tomaba +d1+, que contenía las palabras del documento como claves, y +d2+, que contenía la matriz de palabras. Y devolvía un diccionario que contenía las claves de +d1+ que no estaban en +d2+. 
(((subtract)))

[source,@julia-setup]
----
function subtract(d1, d2)
    res = Dict()
    for key in keys(d1)
        if key ∉ keys(d2)
            res[key] = nothing
        end
    end
    res
end
----


En todos estos diccionarios, los valores son +nothing+ porque nunca los usamos. Con esto estamos desperdiciando espacio de almacenamiento.

Julia proporciona otro tipo integrado llamado conjunto, que se comporta como una colección de claves de diccionario sin valores. Agregar elementos a un conjunto es rápido; también lo es verificar si un elemento forma parte de él. Además, los conjuntos proporcionan funciones y operadores para calcular operaciones comunes de conjuntos.
(((Set)))((("type", "Base", "Set", see="Set")))

Por ejemplo, la resta de conjuntos está disponible como una función llamada +setdiff+. Entonces reescribiendo +restar+:
(((setdiff)))((("function", "Base", "setdiff", see="setdiff")))

[source,@julia-setup]
----
function subtract(d1, d2)
    setdiff(d1, d2)
end
----

El resultado es un conjunto en vez de un diccionario.

Algunos de los ejercicios en este libro se pueden hacer de manera eficiente y concisa con conjuntos. Por ejemplo, a continuación se muestra una solución para +hasduplicates+, de <<ex10-7>>, que usa un diccionario:
(((hasduplicates)))

[source,@julia-setup]
----
function hasduplicates(t)
    d = Dict()
    for x in t
        if x ∈ d
            return true
        end
        d[x] = nothing
    end
    false
end
----

Cuando un elemento aparece por primera vez, se agrega al diccionario. Si el mismo elemento aparece nuevamente, la función devuelve +true+.

Usando conjuntos, podemos escribir la misma función:

[source,@julia-setup]
----
function hasduplicates(t)
    length(Set(t)) < length(t)
end
----

Un elemento solo puede aparecer en un conjunto una vez, por lo que si un elemento en +t+ aparece más de una vez, el conjunto será más pequeño que +t+. Si no hay duplicados, el conjunto tendrá el mismo tamaño que +t+.

También podemos usar conjuntos para hacer algunos de los ejercicios de <<chap09>>. Por ejemplo, aquí hay una versión de +usesonly+ con un bucle:
(((usesonly)))

[source,@julia-setup]
----
function usesonly(word, available)
    for letter in word
        if letter ∉ available
            return false
        end
    end
    true
end
----

+usesonly+ comprueba si todas las letras en +word+ están en +disponible+. Podemos reescribir esta función:

[source,@julia-setup]
----
function usesonly(word, available)
    Set(word) ⊆ Set(available)
end
----

El operador +⊆+ (*+\subseteq TAB+*) verifica si un conjunto es un subconjunto de otro, incluida la posibilidad de que sean iguales, lo cual es cierto si todas las letras en +word+ aparecen en +available+.
(((⊆)))((("operator", "Base", "⊆", see="⊆")))

==== Exercise 20-1

Reescriba +avoids+ usando conjuntos.
(((avoids)))


=== Matemáticas

También se pueden usar números complejos en Julia. La constante global +im+ está asociada al número complejo latexmath:[$\mathrm{i}$], que representa la raíz cuadrada principal de latexmath:[$-1$].
(((complex numbers)))(((im)))

Ahora podemos verificar la identidad de Euler,
(((Euler's identity)))

[source,@julia-repl-test]
----
julia> ℯ^(im*π)+1
0.0 + 1.2246467991473532e-16im
----

El símbolo +ℯ+ (*+\euler TAB+*) es la base de los logaritmos naturales.
(((ℯ))) 

Analicemos la naturaleza compleja de las funciones trigonométricas:

[latexmath]
++++
\begin{equation}
{\cos\left(x\right)=\frac{\mathrm{e}^{\mathrm{i}x}+\mathrm{e}^{-\mathrm{i}x}}{2}\,.}
\end{equation}
++++

Podemos probar esta fórmula para diferentes valores de latexmath:[\(x\)].

[source,@julia-repl-test]
----
julia> x = 0:0.1:2π
0.0:0.1:6.2
julia> cos.(x) == 0.5*(ℯ.^(im*x)+ℯ.^(-im*x))
true
----

Aquí se muestra otro ejemplo del operador punto. Julia también permite usar literales numéricos con identificadores como coeficientes como en +2π+.

Here, another example of the dot operator is shown. Julia also allows numeric literals to be juxtaposed with identifiers as coefficients as in +2π+.

=== Cadenas

En <<chap08>> y <<chap09>>, realizamos algunas búsquedas en objetos de cadenas. Además, Julia puede usar expresiones compatibles con Perl (_regexes_), lo que facilita la tarea de encontrar patrones complejos en objetos de cadena.
(((regex)))

La función +usasolo+ se puede implementar como un expresión regular (o regex):
(((usesonly)))(((Regex)))((("type", "Base", "Regex", see="Regex")))(((occursin)))((("function", "Base", "occursin", see="occursin")))

[source,@julia-setup chap20]
----
function usasolo(palabra, disponible)
  r = Regex("[^$(disponible)]")
  !occursin(r, palabra)
end
----

La expresión regular busca un carácter que no está en la cadena +disponible+ y +occursin+ devuelve +true+ si el patrón se encuentra en +palabra+.

[source,@julia-repl-test chap20]
----
julia> usasolo("banana", "abn")
true
julia> usasolo("bananas", "abn")
false
----

Las expresiones regulares también se pueden construir como literales de cadena no estándar con el prefijo +r+:
Regexes can also be constructed as non-standard string literals prefixed with +r+:
(((string)))(((match)))((("function", "Base", "match", see="match")))

[source,@julia-repl-test chap20]
----
julia> match(r"[^abn]", "banana")

julia> m = match(r"[^abn]", "bananas")
RegexMatch("s")
----

En este caso, la interpolación de cadenas no está permitida. La función +match+ devuelve nothing si no se encuentra el patrón (un comando) y, de lo contrario, devuelve un objeto regexmatch.
(((string interpolation)))(((RegexMatch)))((("type", "Base", "RegexMatch", see="RegexMatch")))

Podemos extraer la siguiente información de un objeto regexmatch:

* toda la subcadena coincide: + m.match +
* las subcadenas capturadas como una matriz de cadenas: + m.captures +
* el desplazamiento en el que comienza todo el partido: + m.offset +
* las compensaciones de las subcadenas capturadas como una matriz: + m.offsets +

* the entire substring matched: +m.match+
* the captured substrings as an array of strings: +m.captures+
* the offset at which the whole match begins: +m.offset+
* the offsets of the captured substrings as an array: +m.offsets+

[source,@julia-repl-test chap20]
----
julia> m.match
"s"
julia> m.offset
7
----

Regexes are extremely powerful and the PERL manpage http://perldoc.perl.org/perlre.html provides all the details to construct the most exotic searches.

=== Arrays

In <<chap10>> we used an array object as a one-dimensional container with an index to address its elements. In Julia however, arrays are multi-dimensional collections.

Let's create a 2-by-3 zero _matrix_:
(((zeros)))((("function", "Base", "zeros", see="zeros")))(((matrix)))

[source,@julia-repl-test chap20]
----
julia> z = zeros(Float64, 2, 3)
2×3 Array{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0
julia> typeof(z)
Array{Float64,2}
----

The type of this matrix is an array holding floating points and having 2 dimensions.
(((dimension)))

The +size+ function returns a tuple with as elements the number of elements in each dimension:
(((size)))((("function", "Base", "size", see="size")))

[source,@julia-repl-test chap20]
----
julia> size(z)
(2, 3)
----

The function +ones+ constructs a matrix with unit value elements:
(((ones)))((("function", "Base", "ones", see="ones")))

[source,@julia-repl-test chap20]
----
julia> s = ones(String, 1, 3)
1×3 Array{String,2}:
 ""  ""  ""
----

The string unit element is an empty string.

[WARNING]
====
+s+ is not a one-dimensional array:

[source,@julia-repl-test chap20]
----
julia> s ==  ["", "", ""]
false
----

+s+ is a row matrix and +["", "", ""]+ is a column matrix.
====

A matrix can be entered directly using a space to separate elements in a row and a semicolon +;+ to separate rows:
(((;)))

[source,@julia-repl-test chap20]
----
julia> a = [1 2 3; 4 5 6]
2×3 Array{Int64,2}:
 1  2  3
 4  5  6
----

You can use square brackets to address individual elements:
(((square brackets)))

[source,@julia-repl-test chap20]
----
julia> z[1,2] = 1
1
julia> z[2,3] = 1
1
julia> z
2×3 Array{Float64,2}:
 0.0  1.0  0.0
 0.0  0.0  1.0
----

Slices can be used for each dimension to select a subgroup of elements:
(((slice)))

[source,@julia-repl-test chap20]
----
julia> u = z[:,2:end]
2×2 Array{Float64,2}:
 1.0  0.0
 0.0  1.0
----

The +.+ operator broadcasts to all dimensions:
(((.)))

[source,@julia-repl-test chap20]
----
julia> ℯ.^(im*u)
2×2 Array{Complex{Float64},2}:
 0.540302+0.841471im       1.0+0.0im
      1.0+0.0im       0.540302+0.841471im
----

=== Interfaces

Julia specifies some informal interfaces to define behaviors, i.e. methods with a specific goal. When you extend such a method for a type, objects of that type can be used to build upon these behaviors.
(((interface)))

[quote]
____
If it looks like a duck, swims like a duck, and quacks like a duck, then it probably _is_ a duck.
____

In <<one_more_example>> we implemented the +fib+ function returning the latexmath:[\(n\)]th element of the Fibonnaci sequence.

Looping over the values of a collection, called iteration, is such an interface. Let's make an iterator that returns lazily the Fibonacci sequence:
(((iterator)))(((Fibonacci)))((("type", "programmer-defined", "Fibonacci", see="Fibonacci")))(((iterate)))((("function", "Base", "iterate", see="iterate")))

[source,@julia-setup chap20]
----
struct Fibonacci{T<:Real} end
Fibonacci(d::DataType) = d<:Real ? Fibonacci{d}() : error("No Real type!")

Base.iterate(::Fibonacci{T}) where {T<:Real} = (zero(T), (one(T), one(T)))
Base.iterate(::Fibonacci{T}, state::Tuple{T, T}) where {T<:Real} = (state[1], (state[2], state[1] + state[2]))
----

We implemented a parametric type with no fields +Fibonacci+, an outer constructor and two methods +iterate+. The first is called to initialize the iterator and returns a tuple consisting of the first value, 0, and a state. The state in this case is a tuple containing the second and the third value, 1 and 1.

The second is called to get the next value of the Fibonacci sequence and returns a tuple having as first element the next value and as second element the state which is a tuple with the two following values.

We can use +Fibonacci+ now in a +for+ loop:
(((for statement)))

[source,@julia-repl-test chap20]
----
julia> for e in Fibonacci(Int64)
           e > 100 && break
           print(e, " ")
       end
0 1 1 2 3 5 8 13 21 34 55 89
----

It looks like magic has happened but the explanation is simple. A +for+ loop in Julia

[source,julia]
----
for i in iter
    # body
end
----

is translated into:

[source,julia]
----
next = iterate(iter)
while next !== nothing
    (i, state) = next
    # body
    next = iterate(iter, state)
end
----

This is a great example how a well defined interface allows an implementation to use all the functions that are aware of the interface.


=== Interactive Utilities

We have already met the +InteractiveUtils+ module in <<interactive>>. The +@which+ macro is only the tip of the iceberg.
(((InteractiveUtils)))(((@which)))

Julia code is transformed by the LLVM library to machinecode in multiple steps. We can directly visualize the output of each stage.

Let's give a simple example:
(((squaresum)))((("function", "programmer-defined", "squaresum", see="squaresum")))

[source,@julia-setup chap20]
----
function squaresum(a::Float64, b::Float64)
    a^2 + b^2
end
----

The first step is to look at the lowered code:
(((@code_lowered)))((("macro", "InteractiveUtils", "@code_lowered", see="@code_lowered")))

[source,@julia-repl-test chap20]
----
julia> using InteractiveUtils

julia> @code_lowered squaresum(3.0, 4.0)
CodeInfo(
1 ─ %1 = Core.apply_type(Base.Val, 2)
│   %2 = (%1)()
│   %3 = Base.literal_pow(:^, a, %2)
│   %4 = Core.apply_type(Base.Val, 2)
│   %5 = (%4)()
│   %6 = Base.literal_pow(:^, b, %5)
│   %7 = %3 + %6
└──      return %7
)
----

The +@code_lowered+ macro returns an array of an _intermediate representation_ of the code that is used by the compiler to generate optimised code.
(((intermediate representation)))

The next step adds type information:
(((@code_typed)))((("macro", "InteractiveUtils", "@code_typed", see="@code_typed")))

[source,@julia-repl-test chap20]
----
julia> @code_typed squaresum(3.0, 4.0)
CodeInfo(
1 ─ %1 = Base.mul_float(a, a)::Float64
│   %2 = Base.mul_float(b, b)::Float64
│   %3 = Base.add_float(%1, %2)::Float64
└──      return %3
) => Float64
----

We see that the type of the intermediate results and the return value is correctly inferred.

This representation of the code is transformed into LLVM code:
(((LLVM code)))(((@code_llvm)))((("macro", "InteractiveUtils", "@code_llvm", see="@code_llvm")))

[source,@julia-repl chap20]
----
@code_llvm squaresum(3.0, 4.0)
----

And finally the _machine code_ is generated:
(((machine code)))(((@code_native)))((("macro", "InteractiveUtils", "@code_native", see="@code_native")))

[source,@julia-repl-test chap20]
----
julia> @code_native squaresum(3.0, 4.0)
	.section	__TEXT,__text,regular,pure_instructions
; ┌ @ none:2 within `squaresum'
; │┌ @ intfuncs.jl:244 within `literal_pow'
; ││┌ @ none:2 within `*'
	vmulsd	%xmm0, %xmm0, %xmm0
	vmulsd	%xmm1, %xmm1, %xmm1
; │└└
; │┌ @ float.jl:395 within `+'
	vaddsd	%xmm1, %xmm0, %xmm0
; │└
	retq
	nopl	(%rax)
; └
----

=== Debugging

The +Logging+ macros provide an alternative to scaffolding with print statements:
(((@warn)))((("macro", "Base", "@warn", see="@warn")))(((debugging)))

[source,jlcon]
----
julia> @warn "Abandon printf debugging, all ye who enter here!"
┌ Warning: Abandon printf debugging, all ye who enter here!
└ @ Main REPL[1]:1
----

The debug statements don't have to be removed from the source. For example, in contrast to the +@warn+ above
(((debug statement)))(((@debug)))((("macro", "Base", "@debug", see="@debug")))

[source,jlcon]
----
julia> @debug "The sum of some values $(sum(rand(100)))"

----

will produce no output by default. In this case +sum(rand(100))+ will never be evaluated unless _debug logging_ is enabled.
(((debug logging)))

The level of logging can be selected by an environment variable +JULIA_DEBUG+:
(((environment variable)))

[source]
----
$ JULIA_DEBUG=all julia -e '@debug "The sum of some values $(sum(rand(100)))"'
┌ Debug: The sum of some values 47.116520814555024
└ @ Main none:1
----

Here, we have used +all+ to get all debug information, but you can also choose to generate only output for a specific file or module.


=== Glossary

regex::
Regular expression, a sequence of characters that define a search pattern.
(((regex)))

matrix::
Two-dimensional array.
(((matrix)))

intermediate representation::
Data structure used internally by a compiler to represent source code.
(((intermediate representation)))

machine code::
Language instructions that can be executed directly by a computer's central processing unit.
(((machine code)))

debug logging::
Storing debug messages in a log.
(((debug logging)))
