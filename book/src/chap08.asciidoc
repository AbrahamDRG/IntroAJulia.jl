[[chap08]]
== Cadenas

Las cadenas son diferentes de los n√∫meros enteros, flotantes y booleanos. Una cadena es una _secuencia_, es decir, es una colecci√≥n ordenada de valores. En este cap√≠tulo veremos c√≥mo acceder a los caracteres que forman una cadena, y conoceremos algunas funciones integradas en Julia relacionadas con cadenas.
(((string)))(((sequence)))

[[characters]]
=== Caracteres

Los hispanohablantes est√°n familiarizados con algunos caracteres, tales como las letras del alfabeto (A, B, C, ...), los n√∫meros y los signos de puntuaci√≥n comunes. Estos caracteres est√°n estandarizados en el c√≥digo _ASCII_ (C√≥digo Est√°ndar Estadounidense para el Intercambio de Informaci√≥n).
(((ASCII standard)))

Por supuesto hay muchos otros caracteres utilizados en idiomas distintos del espa√±ol que no est√°n en el c√≥digo _ASCII_, tales como aquellos usados en los idiomas griego, √°rabe, chino, hebreo, hindi, japon√©s y coreano.

Definir qu√© es un car√°cter es altamente complejo. La _norma Unicode_ permite abordar este problema, y se considera como el est√°ndar definitivo para ello. Esta norma funciona asignando un n√∫mero √∫nico para cada car√°cter a nivel global.
(((Unicode standard)))

Un valor +Char+ representa un √∫nico car√°cter y est√° entre comillas simples:
(((Char)))((("type", "Base", "Char", see="Char")))

[source,@julia-repl-test]
----
julia> 'x'
'x': ASCII/Unicode U+0078 (category Ll: Letter, lowercase)
julia> 'üçå'
'üçå': Unicode U+01f34c (category So: Symbol, other)
julia> typeof('x')
Char
----

Incluso los emojis son parte del est√°ndar Unicode. (*+\:banana: TAB+*)
(((emoji)))


=== Una Cadena es una Secuencia

Una cadena es una secuencia de caracteres. Se puede acceder a un car√°cter con el operador corchete:
(((string)))(((String)))(((sequence)))(((bracket operator)))((("[]", see="bracket operator")))((("operator", "Base", "[]", see="bracket operator")))

[source,@julia-repl-test chap08]
----
julia> fruta = "banana"
"banana"
julia> letra = fruta[1]
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
----

La segunda sentencia selecciona el car√°cter n√∫mero 1 de +fruta+ y la asigna a la variable +letra+. 

La expresi√≥n entre corchetes se llama _indice_. El √≠ndice indica el car√°cter de la secuencia a obtener (de ah√≠ el nombre).
(((index)))

La indexaci√≥n en Julia es base 1, es decir, el primer elemento de cualquier objeto indexado con enteros est√° en el √≠ndice 1, y el √∫ltimo en el √≠ndice +end+:
(((end)))

[source,@julia-repl-test chap08]
----
julia> fruta[end]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
----

Como √≠ndice se pueden usar expresiones que contengan variables y operadores:

[source,@julia-repl-test chap08]
----
julia> i = 1
1
julia> fruta[i+1]
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia> fruta[end-1]
'n': ASCII/Unicode U+006e (category Ll: Letter, lowercase)
----

Pero el valor del √≠ndice tiene que ser un n√∫mero entero. De lo contrario se obtiene:
(((MethodError)))((("error", "Core", "MethodError", see="MethodError")))

[source,@julia-repl-test chap08]
----
julia> letra = fruta[1.5]
ERROR: MethodError: no method matching getindex(::String, ::Float64)
----


=== +length+

+length+ es una funci√≥n integrada que devuelve el n√∫mero de caracteres de una cadena:
(((length)))

[source,@julia-repl-test chap08]
----
julia> frutas = "üçå üçé üçê"
"üçå üçé üçê"
julia> len = length(frutas)
5
----

Para obtener la √∫ltima letra de una cadena, puede sentirse tentado a probar algo como esto:

[source,@julia-repl-test chap08]
----
julia> last = frutas[len]
' ': ASCII/Unicode U+0020 (category Zs: Separator, space)
----

Pero con esto no se obtiene el resultado esperado.

Las cadenas se codifican usando _codificaci√≥n UTF-8_. UTF-8 es una codificaci√≥n de longitud variable, lo que significa que no todos los caracteres est√°n codificados con el mismo n√∫mero de bytes.
(((UTF-8 encoding)))

La funci√≥n +sizeof+ devuelve el n√∫mero de bytes de una cadena:
(((sizeof)))((("function", "Base", "sizeof", see="sizeof")))

[source,@julia-repl-test chap08]
----
julia> sizeof("üçå")
4
----

Dado que un emoji est√° codificado en 4 bytes y la indexaci√≥n de cadenas est√° basada en bytes, el quinto elemento de +frutas+ es un +ESPACIO+.
(((emoji)))

Esto significa que no todos los √≠ndices de byte de una cadena UTF-8 son necesariamente √≠ndices v√°lidos para un car√°cter. Si en una cadena se indexa con un √≠ndice de bytes no v√°lido, se genera un error:
(((StringIndexError)))((("error", "Base", "StringIndexError", see="StringIndexError")))

[source,@julia-repl-test chap08]
----
julia> frutas[2]
ERROR: StringIndexError("üçå üçé üçê", 2)
----

En el caso de +frutas+, el car√°cter +üçå+ es un car√°cter de cuatro bytes, por lo que los √≠ndices 2, 3 y 4 no son v√°lidos y el √≠ndice del siguiente car√°cter es 5; el siguiente √≠ndice v√°lido se puede calcular con +nextind(frutas, 1)+, el subsiguiente con +nextind(frutas,5)+ y as√≠ sucesivamente.
(((nextind)))((("function", "Base", "nextind", see="nextind")))


=== Recorrido

Muchos c√°lculos implican procesar una cadena car√°cter por car√°cter. A menudo empiezan por el principio, seleccionan cada car√°cter por turno, hacen algo con √©l y contin√∫an hasta el final. Este patr√≥n de proceso se llama _recorrido_. Una forma de escribir un recorrido es con una sentencia while:
(((traversal)))(((while statement)))

[source,@julia-setup chap08]
----
indice = primerindice(frutas)
while indice <= sizeof(frutas)
    letra = frutas[indice]
    println(letra)
    global indice = nextind(frutas, indice)
end
----

Este bucle recorre la cadena y muestra cada letra en una l√≠nea distinta. La condici√≥n del bucle es +index pass:[&lt;=] sizeof(fruta)+, de modo que cuando el indice es mayor al n√∫mero de bytes en la cadena, la condici√≥n es +falsa+, y no se ejecuta el cuerpo del bucle.

La funci√≥n +primerindice+ devuelve el primer √≠ndice de bytes v√°lido. La palabra reservada +global+ antes de +indice+ indica que queremos reasignar la variable +indice+ definida en +Main+ (ver <<variables_globales>>).
(((global)))(((firstindex)))((("function", "Base", "firstindex", see="firstindex")))

==== Ejercicio 8-1

Escriba una funci√≥n que tome una cadena como argumento y que muestre las letras desde la √∫ltima a la primera, una por l√≠nea.

Otra forma de escribir un recorrido es con un bucle +for+:
(((for statement)))(((in)))

[source,@julia-setup chap08]
----
for letra in frutas
    println(letra)
end
----

Cada vez que recorremos el bucle, se asigna a la variable +letra+ el siguiente car√°cter de la cadena. El bucle contin√∫a hasta que no quedan m√°s caracteres.

El ejemplo siguiente muestra c√≥mo usar la concatenaci√≥n (multiplicaci√≥n de cadenas) y un bucle for para generar una serie abecedaria (es decir, una serie con elementos en orden alfab√©tico). Por ejemplo, en el libro de Robert McCloskey _Make Way for Ducklings_, los nombres de los patitos son Jack, Kack, Lack, Mack, Nack, Ouack, Pack, y Quack. Este bucle muestra esos nombres en orden:

[source,@julia chap08-3]
----
prefijos = "JKLMNOPQ"
sufijos = "ack"

for letra in prefijos
    println(letra * sufijo)
end
----

Por supuesto, esto no es del todo correcto, porque ‚ÄúOuack‚Äù y ‚ÄúQuack‚Äù no est√°n correctamente escritos.

==== Ejercicio 8-2

Modifique este programa para solucionar este error.

=== Porciones de Cadenas

A la subcadena de una cadena se le llama _porci√≥n_. La selecci√≥n de una porci√≥n es similar a la selecci√≥n de un car√°cter:
(((slice)))

[source,@julia-repl-test chap08]
----
julia> str = "Julio Cesar";

julia> str[1:6]
"Julio"
----

El operador +[n:m]+ devuelve la parte de la cadena desde el +n+-√©simo byte hasta el +m+-√©simo. Por lo tanto, se siguen las mismas reglas que para la indexaci√≥n simple.
(((bracket operator)))

La palabra reservada +end+ se puede usar para indicar al √∫ltimo byte de la cadena:
(((end)))

[source,@julia-repl-test chap08]
----
julia> str[8:end]
"Cesar"
----

Si el primer √≠ndice es mayor que el segundo, el resultado es una _cadena vac√≠a_, representada por dos comillas:
(((empty string)))((("&quot;&quot;", see="empty string")))

[source,@julia-repl-test chap08]
----
julia> str[8:7]
""
----

Una cadena vac√≠a no contiene caracteres y tiene una longitud de 0, pero aparte de eso es igual a cualquier otra cadena.

==== Ejercicio 8-3

Continuando este ejemplo, ¬øqu√© crees que significa +str[:]+? Prueba y ver√°s.

=== Las Cadenas son Inmutables

Es tentador usar el operador +[]+ en el lado izquierdo de una asignaci√≥n, con la intenci√≥n de cambiar un car√°cter en una cadena. Por ejemplo:
(((bracket operator)))(((MethodError)))

[source,@julia-repl-test chap08]
----
julia> saludo = "¬°Hola, mundo!"
"¬°Hola, mundo!"
julia> saludo[3] = 'J'
ERROR: MethodError: no method matching setindex!(::String, ::Char, ::Int64)
----
Nota del traductor: De acuerdo con la codificaci√≥n de caracteres en utf-8 √≥ latin-1, el car√°cter de exclamaci√≥n ‚Äò¬°‚Äô, en la variable saludo ocupa dos posiciones, de ah√≠ que la letra ‚ÄòH‚Äô est√© localizada en el √≠ndice 3.

La raz√≥n del error es que las cadenas son _inmutables_, lo que significa que no se puede cambiar una cadena existente. Lo m√°s que puedes hacer es crear una nueva cadena que sea una variaci√≥n de la original:
(((immutable)))

[source,@julia-repl-test chap08]
----
julia> saludo = "J" * saludo[4:end]
"¬°Jola, mundo!"
----

Este ejemplo concatena la apertura del signo de exclamaci√≥n y una nueva primera letra a una porci√≥n de saludo. Esta operaci√≥n no tiene efecto sobre la cadena original.

=== Interpolaci√≥n de Cadenas

Construir cadenas usando concatenaci√≥n puede ser un poco engorroso. Para disminuir la necesidad de las llamadas a +string+ o multiplicaciones repetidas, Julia permite la _interpolaci√≥n de cadenas_ usando +$+:
(((string interpolation)))((("$", see="string interpolation")))

[source,@julia-repl-test]
----
julia> saludo = "¬°Hola"
"Hello"
julia> paraquien = "mundo"
"World"
julia> "$saludo, $(paraquien)!"
"¬°Hola, mundo!"
----

Esto es m√°s entendible y conveniente que la concatenaci√≥n de cadenas: +pass:[saludo * ", " * paraquien * "!"]+

La expresi√≥n inmediatamente siguiente a +$+ se toma como la expresi√≥n cuyo valor se va a interpolar en la cadena. Por lo tanto, puedes interpolar cualquier expresi√≥n en una cadena usando par√©ntesis:

[source,@julia-repl-test]
----
julia> "1 + 2 = $(1 + 2)"
"1 + 2 = 3"
----

[[searching]]
=== Buscar

¬øQu√© hace la siguiente funci√≥n?
(((find)))((("function", "programmer-defined", "find", see="find")))

[source,@julia-setup]
----
function buscar(palabra, letra)
    indice = primerindice(palabra)
    while indice <= sizeof(palabra)
        if palabra[indice] == letra
            return indice
        end
        indice = nextind(palabra, indice)
    end
    -1
end
----

En cierto sentido, la funcion buscar es lo contrario del operador +[]+. En lugar de tomar un √≠ndice y extraer el car√°cter correspondiente, toma un car√°cter y encuentra el √≠ndice donde aparece el car√°cter. Si el car√°cter no se encuentra, la funci√≥n devuelve -1.

Este es el primer ejemplo que hemos visto de una sentencia return dentro de un bucle. Si +palabra[indice] == letra+, la funci√≥n devuelve inmediatamente el √≠ndice, escapando del bucle prematuramente.

Si el car√°cter no aparece en la cadena, entonces el programa sale del bucle normalmente y devuelve -1.

Este patr√≥n de computaci√≥n se llama a veces un recorrido _eureka_ porque tan pronto como encontramos lo que buscamos, podemos gritar ‚Äú¬°Eureka! ‚Äù y dejar de buscar.
(((search)))

==== Ejercicio 8-4
Para encontrar las posiciones de la segunda o tercera ocurrencia de un car√°cter en una cadena, podemos modificar la funci√≥n encuentra, agregando un tercer par√°metro para la posici√≥n inicial en la cadena de b√∫squeda:

Modifique la funci√≥n +buscar+ para que tenga un tercer par√°metro: el √≠ndice de +palabra+ donde deber√≠a comenzar a buscar.

[[looping_and_counting]]
=== Iterando y contando

El siguiente programa cuenta el n√∫mero de veces que aparece la letra +a+ en una cadena:

[source,@julia-setup]
----
palabra = "banana"
contador = 0
for letra in palabra
    if letra == 'a'
        global contador = contador + 1
    end
end
println(contador)
----

Este programa es otro ejemplo del patr√≥n de computaci√≥n llamada _conteo_.  La variable +contador+ se inicializa en 0 y se incrementa cada vez que encuentra la letra +a+. Cuando termina el bucle, +contador+ contiene el resultado (el n√∫mero total de letras +a+).
(((counter)))

==== Ejercicio 8-5

Coloque este c√≥digo en una funci√≥n llamada +conteo+, y general√≠celo de tal manera que tome como argumentos una cadena y una letra.

Luego, vuelva a escribir la funci√≥n para que, en vez de revisar toda la cadena, utilice la funci√≥n +buscar+ de tres par√°metros de la secci√≥n anterior.

=== Librer√≠a con cadenas

Julia tiene funciones integradas que realizan una variedad de operaciones √∫tiles en cadenas. Por ejemplo, la funci√≥n +uppercase+ toma una cadena y devuelve una nueva cadena con todas las letras may√∫sculas.
(((uppercase)))((("function", "Base", "uppercase", see="uppercase")))

[source,@julia-repl-test]
----
julia> uppercase("¬°Hola, mundo!")
"¬°HOLA, MUNDO!"
----

Existe una funci√≥n llamada +findfirst+ que es notablemente similar a la funci√≥n +buscar+ que escribimos:
(((findfirst)))((("function", "programmer-defined", "findfirst", see="findfirst")))

[source,@julia-repl-test]
----
julia> findfirst("a", "banana")
2:2
----

La funci√≥n +findfirst+ es m√°s general que nuestra funci√≥n; puede encontrar subcadenas, no solo caracteres:

[source,@julia-repl-test]
----
julia> findfirst("na", "banana")
3:4
----

Por defecto, +findfirst+ comienza la b√∫squeda al comienzo de la cadena, pero la funci√≥n +findnext+ toma un tercer argumento: el +indice+ donde deber√≠a comenzar:
(((findnext)))((("function", "programmer-defined", "findnext", see="findnext")))

[source,@julia-repl-test]
----
julia> findnext("na", "banana", 4)
5:6
----


===  El operador +‚àà+

El operador +‚àà+ (*+\in TAB+*) es un operador booleano que toma un car√°cter y una cadena, y devuelve +true+ si el primero aparece en el segundo:
((("‚àà", see="in")))((("operator", "Base", "in", see="in")))((("operator", "Base", "‚àà", see="in")))

[source,@julia-repl-test]
----
julia> 'a' ‚àà "banana"    # 'a' en "banana"
true
----

Por ejemplo, la siguiente funci√≥n imprime todas las letras de palabra1 que tambi√©n aparecen en palabra2:
(((inboth)))((("function", "programmer-defined", "inboth", see="inboth")))

[source,@julia-setup chap08-2]
----
function ambas(palabra1, palabra2)
    for letra in palabra1
        if letra ‚àà palabra2
            print(letra, " ")
        end
    end
end
----

Una  buena elecci√≥n de nombres de variables permite que Julia se pueda leer como el espa√±ol. Este bucle puede leerse como: "para (cada) letra en (la primera) palabra, si (la) letra es un elemento de (la segunda) palabra, imprima (la) letra".

Esto es lo que se obtiene si se compara +"manzanas"+ y +"naranjas"+:

[source,@julia-repl-test chap08-2]
----
julia> ambas("manzanas", "naranjas")
a n a n a s
----


=== Comparaci√≥n de Cadenas

Los operadores de comparaci√≥n trabajan sobre cadenas. Para ver si dos cadenas son iguales:
(((string comparison)))(((==)))

[source,@julia-setup chap08]
----
palabra = "Pi√±a"
if palabra == "banana"
    println("¬°Tenemos bananas!")
end
----

Otras operaciones de comparaci√≥n son √∫tiles para poner palabras en orden alfab√©tico:
(((alphabetical order)))

[source,@julia-setup chap08]
----
if palabra < "banana"
    println("Su palabra, $word, va antes de banana.")
elseif word > "banana"
    println("Su palabra, $word, va antes de banana.")
else
    println("¬°Tenemos bananas!")
end
----

Julia no maneja las letras may√∫sculas y min√∫sculas como lo hace la gente. Todas las letras may√∫sculas van antes de las letras min√∫sculas. Por lo tanto:

[source,@julia-eval chap08]
----
Su palabra, Pi√±a, va antes de banana.
----

[TIP]
====

Una forma com√∫n de abordar este problema es convertir las cadenas a un formato est√°ndar, como pueden ser las min√∫sculas, antes de realizar la comparaci√≥n. 

====


[[deb08]]
=== Depuraci√≥n

Cuando se usan √≠ndices para recorrer los valores en una secuencia, es dif√≠cil acceder al principio y al final del recorrido. Aqu√≠ hay una funci√≥n que compara dos palabras y devuelve +true+ si una de las palabras es el reverso de la otra, pero contiene dos errores:
(((debugging)))(((traversal)))(((isreverse)))((("function", "programmer-defined", "isreverse", see="isreverse")))

[source,@julia-setup chap08]
----
function esreverso(palabra1, palabra2)
    if length(palabra1) != length(palabra2)
        return false
    end
    i = firstindex(palabra1)
    j = lastindex(palabra2)
    while j >= 0
        j = prevind(palabra2, j)
        if palabra1[i] != palabra2[j]
            return false
        end
        i = nextind(palabra1, i)
    end
    true
end
----

La primera sentencia +if+ verifica si las palabras tienen la misma longitud. Si no, se devuelve +false+ inmediatamente. De lo contrario, para el resto de la funci√≥n, podemos suponer que las palabras tienen la misma longitud. Este es un ejemplo del patr√≥n guardi√°n.

+i+ y +j+ son √≠ndices: +i+ recorre +palabra1+ hacia adelante mientras que +j+ recorre +palabra2+ hacia atr√°s. Si dos letras no coinciden, se devuelve +false+ inmediatamente. Si el ciclo termina y todas las letras coinciden, se devuelve +true+.

La funci√≥n +lastindex+ devuelve el √∫ltimo √≠ndice de bytes v√°lido de una cadena y +prevind+ el √≠ndice v√°lido anterior a un car√°cter.

Si probamos esta funci√≥n con las palabras "amor" y "roma", esperamos el valor de retorno +true+, pero obtenemos +false+:

[source,@julia-repl-test chap08]
----
julia> esreverso("amor", "roma")
false
----

Para depurar este tipo de error, primeramente imprimamos los valores de los √≠ndices:

[source,julia]
----
    while j >= 0
        j = prevind(palabra2, j)
        @show i j
        if palabra1[i] != palabra2[j]
----

[source,@julia-eval chap08]
----
function esreverso(palabra1, palabra2)
    if length(palabra1) != length(palabra2)
        return false
    end
    i = firstindex(palabra1)
    j = lastindex(palabra2)
    while j >= 0
        j = prevind(palabra2, j)
        @show i j
        if palabra1[i] != palabra2[j]
            return false
        end
        i = nextind(palabra1, i)
    end
    true
end;
----

Ahora, al ejecutar el programa, se obtiene m√°s informaci√≥n:

[source,@julia-repl-test chap08]
----
julia> esreverso("amor", "roma")
i = 1 
j = 3
false
----

En la primera iteraci√≥n del bucle, el valor de +j+ es 3, pero tendr√≠a que ser 4. Esto se puede solucionar trasladando la l√≠nea +j = prevind (palabra2, j)+ al final del ciclo +while+.

Si se soluciona ese error y se ejecuta el programa nuevamente, se obtiene:

[source,@julia-eval chap08]
----
function esreverso(palabra1, palabra2)
    if length(palabra1) != length(palabra2)
        return false
    end
    i = firstindex(palabra1)
    j = lastindex(palabra2)
    while j >= 0
        @show i j
        if palabra1[i] != palabra2[j]
            return false
        end
        i = nextind(palabra1, i)
        j = prevind(palabra2, j)
    end
    true
end;
----

[source,@julia-repl-test chap08]
----
julia> esreverso("amor", "roma")
i = 1
j = 4
i = 2
j = 3
i = 3
j = 2
i = 4
j = 1
i = 5
j = 0
ERROR: BoundsError: attempt to access "amor"
  at index [5]
----

Esta vez se ha producido un + BoundsError +. El valor de + i + es 5, que est√° fuera del rango de la cadena + "potes" +.
This time a +BoundsError+ has been thrown. The value of +i+ is 5, which is out a range for the string +"pots"+.
(((BoundsError)))((("error", "Core", "BoundsError", see="BoundsError")))

==== Exercise 8-6

Run the program on paper, changing the values of +i+ and +j+ during each iteration. Find and fix the second error in this function.


=== Glossary

sequence::
An ordered collection of values where each value is identified by an integer index.
(((sequence)))

ASCII standard::
A character encoding standard for electronic communication specifying 128 characters.
(((ASCII standard)))

Unicode standard::
A computing industry standard for the consistent encoding, representation, and handling of text expressed in most of the world's writing systems.
(((Unicode standard)))

index::
An integer value used to select an item in a sequence, such as a character in a string. In Julia indices start from 1.
(((index)))

UTF-8 encoding::
A variable width character encoding capable of encoding all 1112064 valid code points in Unicode using one to four 8-bit bytes.
(((UTF-8 encoding)))

traverse::
To iterate through the items in a sequence, performing a similar operation on each.
(((traversal)))

slice::
A part of a string specified by a range of indices.
(((slice)))

empty string::
A string with no characters and length 0, represented by two quotation marks.
(((empty string)))

immutable::
The property of a sequence whose items cannot be changed.
(((immutable)))

string interpolation::
The process of evaluating a string containing one or more placeholders, yielding a result in which the placeholders are replaced with their corresponding values.
(((string interpolation)))

search::
A pattern of traversal that stops when it finds what it is looking for.
(((search)))

counter::
A variable used to count something, usually initialized to zero and then incremented.
(((counter)))


=== Exercises

[[ex08-1]]
==== Exercise 8-7

Read the documentation of the string functions at https://docs.julialang.org/en/v1/manual/strings/. You might want to experiment with some of them to make sure you understand how they work. +strip+ and +replace+ are particularly useful.

The documentation uses a syntax that might be confusing. For example, in +search(string::AbstractString, chars::Chars, [start::Integer])+, the brackets indicate optional arguments. So +string+ and +chars+ are required, but +start+ is optional.
(((search)))((("function", "Base", "search", see="search")))

[[ex08-2]]
==== Exercise 8-8

There is a built-in function called +count+ that is similar to the function in <<looping_and_counting>>. Read the documentation of this function and use it to count the number of +a+‚Äôs in "banana".
(((count)))((("function","Base", "count", see="count")))

[[ex08-3]]
==== Exercise 8-9

A string slice can take a third index. The first specifies the start, the third the end and the second the ‚Äústep size‚Äù; that is, the number of spaces between successive characters. A step size of 2 means every other character; 3 means every third, etc.
(((slice)))

[source,@julia-repl-test]
----
julia> fruit = "banana"
"banana"
julia> fruit[1:2:6]
"bnn"
----

A step size of -1 goes through the word backwards, so the slice +[end:-1:1]+ generates a reversed string.

Use this idiom to write a one-line version of +ispalindrome+ from <<ex06-3>>.
(((ispalindrome)))

[[ex08-4]]
==== Exercise 8-10

The following functions are all _intended_ to check whether a string contains any lowercase letters, but at least some of them are wrong. For each function, describe what the function actually does (assuming that the parameter is a string).

[source,@julia-setup]
----
function anylowercase1(s)
    for c in s
        if islowercase(c)
            return true
        else
            return false
        end
    end
end

function anylowercase2(s)
    for c in s
        if islowercase('c')
            return "true"
        else
            return "false"
        end
    end
end

function anylowercase3(s)
    for c in s
        flag = islowercase(c)
    end
    flag
end

function anylowercase4(s)
    flag = false
    for c in s
        flag = flag || islowercase(c)
    end
    flag
end

function anylowercase5(s)
    for c in s
        if !islowercase(c)
            return false
        end
    end
    true
end
----

[[ex08-5]]
==== Exercise 8-11

A Caesar cypher is a weak form of encryption that involves ‚Äúrotating‚Äù each letter by a fixed number of places. To rotate a letter means to shift it through the alphabet, wrapping around to the beginning if necessary, so +‚ÄôA‚Äô+ rotated by 3 is +‚ÄôD‚Äô+ and +‚ÄôZ‚Äô+ rotated by 1 is +‚ÄôA‚Äô+.
(((Caesar cypher)))

To rotate a word, rotate each letter by the same amount. For example, +"cheer"+ rotated by 7 is +"jolly"+ and +"melon"+ rotated by -10 is +"cubed"+. In the movie _2001: A Space Odyssey, the ship computer_ is called HAL, which is IBM rotated by -1.

Write a function called +rotateword+ that takes a string and an integer as parameters, and returns a new string that contains the letters from the original string rotated by the given amount.
(((rotateword)))((("function","programmer-defined", "rotateword", see="rotateword")))

[TIP]
====
You might want to use the built-in function +Int+, which converts a character to a numeric code, and +Char+, which converts numeric codes to characters. Letters of the alphabet are encoded in alphabetical order, so for example:
(((Int)))(((Char)))

[source,@julia-repl-test]
----
julia> Int('c') - Int('a')
2
----

Because +'c'+ is the third letter of the alphabet. But beware: the numeric codes for uppercase letters are different.

[source,@julia-repl-test]
----
julia> Char(Int('A') + 32)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
----
====

Potentially offensive jokes on the Internet are sometimes encoded in ROT13, which is a Caesar cypher with rotation 13. If you are not easily offended, find and decode some of them.
