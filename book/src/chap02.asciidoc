[[chap02]]
== Variables, expresiones y sentencias

Una de las características más poderosas de un lenguaje de programación es la capacidad de manipular _variables_. Una variable es un nombre que se refiere a un valor.
(((variable)))(((valor)))


=== Sentencias de asignación

Una _sentencia de asignación_ crea una nueva variable y le asigna un valor:
(((sentencia de asignación)))((("sentencia", "asignación", see="sentencia de asignación")))(((pass:[=], see="sentencia de asignación"))) (((pi)))((("π", see = "pi")))

[source,@julia-repl-test chap02]
----
julia> mensaje = "Y ahora, algo completamente diferente"
"Y ahora, algo completamente diferente"
julia> n = 17
17
julia> π_val = 3.141592653589793
3.141592653589793
----

Este ejemplo hace tres asignaciones. La primera asigna una cadena a una nueva variable llamada +mensaje+; la segunda le asigna a +n+ el entero +17+; el tercero asigna el valor (aproximado) de latexmath:[\(\pi\)] a +π_val+ (*+\pi TAB+*).

Una forma común de representar variables en papel es escribir el nombre de la variable con una flecha apuntando a su valor. Este tipo de figura se llama "diagrama de estado" porque muestra en qué estado se encuentra cada una de las variables. <<fig02-1>> muestra el resultado del ejemplo anterior.
(((diagrama de estado)))((("diagrama", "estado", see="diagrama de estado")))

[[fig02-1]]
.Diagrama de estado
image::images/fig21.svg[]


=== Nombres de variables
(((variable)))

Los programadores generalmente eligen nombres significativos para sus variables, es decir, los nombres explican para qué se usa la variable.

Los nombres de las variables pueden ser tan largos como desee. Pueden contener casi todos los caracteres Unicode (consulte <<caracteres>>), pero no pueden comenzar con un número. Es válido usar letras mayúsculas, pero lo común es usar solo minúsculas para los nombres de variables.

Los caracteres Unicode se pueden ingresar mediante autocompletado por tabulación de las abreviaturas tipo LaTeX en el Julia REPL.
(((Carácter Unicode)))

El carácter guión bajo, +_+, puede aparecer en un nombre. A menudo se usa en nombres con varias palabras, como +tu_nombre+ o +velocidad_aerodinámica_de_una_golondrina_sin_cargamento+.
(((carácter guión bajo)))(((abreviaturas tipo LaTeX)))

Si le das un nombre inválido a una variable, tendrás un error de sintaxis:
(((error de sintaxis)))((("error", "sintaxis", see="error de sintaxis")))

[source, jlcon]
----
julia> 76trombones = "un gran desfile"
ERROR: syntax: "76" is not a valid function argument name (ERROR: sintaxis: "76" no es un nombre de argumento de función válido)
julia> mas@ = 1000000
ERROR: syntax: extra token "@" after end of expression (ERROR: sintaxis: componente léxico adicional "@" después del final de la expresión)
julia> struct = "Química avanzada"
ERROR: syntax: unexpected "=" (ERROR: sintaxis: "=" inesperado)
----

+76trombones+ es un nombre inválido porque comienza con un número. +mas@+ es inválido porque contiene un carácter inválido: +@+. Pero, ¿qué hay de malo con +struct+?

Resulta que +struct+ es una de las _palabras clave_ de Julia. El REPL usa palabras clave para reconocer la estructura del programa, y no se pueden usar como nombres de variables.
(((palabra clave)))

Julia tiene estas palabras clave:
----
abstract type    baremodule   begin      break       catch
const            continue     do         else        elseif      
end              export       finally    for         function
global           if           import     importall   in         
let              local        macro      module      mutable struct
primitive type   quote        return     try         using            
struct           where        while
----

No hay necesidad de memorizar esta lista. En la mayoría de los entornos de desarrollo, las palabras clave se muestran en un color diferente; por lo tanto, si intenta usar una como nombre de variable, lo sabrá.


=== Expresiones y sentencias

Una _expresión_ es una combinación de valores, variables y operadores. Un valor en sí mismo se considera una expresión, al igual que una variable, por lo que las siguientes son todas expresiones válidas:
(((expresión)))

[source,@julia-repl-test chap02]
----
julia> 42
42
julia> n
17
julia> n + 25
42
----

Cuando escribe una expresión en el prompt, REPL la _evalúa_, lo que significa que encuentra el valor de la expresión. En este ejemplo, +n+ tiene el valor 17 y +n+25+ tiene el valor 42.
(((evaluar)))

Una sentencia es una unidad de código que tiene un efecto, tal como crear una variable o mostrar un valor.
(((sentencia)))

[source,@julia-repl-test chap02]
----
julia> n = 17
17
julia> println(n)
17
----

La primera línea es una sentencia de asignación que le da un valor a +n+. La segunda línea es una sentencia de impresión que muestra el valor de +n+.

Cuando escribe una sentencia, REPL la ejecuta, es decir, hace lo que dice la sentencia.
(((ejecutar)))


=== Modo script

Hasta ahora hemos ejecutado Julia en _modo interactivo_, lo que significa que hemos interactuado directamente con el REPL. El modo interactivo es una buena manera de comenzar, pero si está trabajando con más de unas pocas líneas de código, puede ser difícil.
(((modo interactivo)))

Una alternativa es guardar el código en un archivo llamado _script_ y luego ejecutar Julia en _modo script_ para ejecutar el script. Por convención, los scripts de Julia tienen nombres que terminan en _.jl_.
(((script)))(((modo script)))

Si sabe cómo crear y ejecutar un script en su computadora, está listo para comenzar. De lo contrario, recomiendo usar JuliaBox nuevamente. Abra un archivo de texto, escriba el script y guárdelo con una extensión _.jl_. El script se puede ejecutar en una terminal con el comando *+julia name_of_the_script.jl+*.
(((extension, .jl)))(((JuliaBox)))

Debido a que Julia proporciona ambos modos, puede probar bits de código en modo interactivo antes de colocarlos en un script. Pero hay diferencias entre el modo interactivo y el modo de script que pueden ser confusos.

Por ejemplo, si está utilizando a Julia como calculadora, puede escribir

[source,@julia-repl-test]
----
julia> millas = 26.2
26,2
julia> millas * 1.61
42,182
----

La primera línea asigna un valor a + millas + y muestra el valor. La segunda línea es una expresión, por lo que REPL la evalúa y muestra el resultado. Resulta que una maratón es de unos 42 kilómetros.

Pero si escribe el mismo código en un script y lo ejecuta, no obtendrá ningún resultado. En el modo de secuencia de comandos, una expresión, por sí sola, no tiene ningún efecto visible. Julia realmente evalúa la expresión, pero no muestra el valor a menos que se lo indique:

[fuente, julia]
----
millas = 26.2
println (millas * 1.61)
----

Este comportamiento puede ser confuso al principio.

Un script generalmente contiene una secuencia de declaraciones. Si hay más de una declaración, los resultados aparecen uno a la vez a medida que se ejecutan las declaraciones.

Por ejemplo, el guión

[fuente, julia]
----
println (1)
x = 2
println (x)
----

produce la salida

[fuente, @ julia-eval]
----
println (1)
x = 2
println (x)
----

La declaración de asignación no produce salida.

===== Ejercicio 2-1

Para verificar su comprensión, escriba las siguientes declaraciones en Julia REPL y vea lo que hacen:

[fuente, julia]
----
5 5
x = 5
x + 1
----

Ahora ponga las mismas declaraciones en un script y ejecútelo. ¿Cuál es el resultado? Modifique el script transformando cada expresión en una declaración de impresión y luego ejecútela de nuevo.

=== Precedencia del operador

Cuando una expresión contiene más de un operador, el orden de evaluación depende de la _precedencia del operador_. Para los operadores matemáticos, Julia sigue la convención matemática. El acrónimo _PEMDAS_ es una forma útil de recordar las reglas:
(((precedencia de operador))) (((PEMDAS)))

* __P__rentheses tienen la mayor precedencia y se pueden utilizar para forzar una expresión a evaluar en el orden que desee. Dado que las expresiones entre paréntesis se evalúan primero, + 2 * (3-1) + es 4, y + pass: [(1 + 1) ^ (5-2)] + es 8. También puede usar paréntesis para hacer una expresión más fácil de leer, como en + (minuto * 100) / 60+, incluso si no cambia el resultado.
(((paréntesis)))

* __E__xponentiation tiene la siguiente precedencia más alta, por lo que + pass: [1 + 2 ^ 3] + es 9, no 27, y + 2 * 3 ^ 2 + es 18, no 36.
(((pase: [^])))

* __M__ultiplicación y __D__ivisión tienen mayor precedencia que __A__ddition y __S__ubtraction. Entonces + 2 * 3-1 + es 5, no 4, y + pasa: [6 + 4/2] + es 8, no 5.
(((pase: [*]))) (((pase: [/]))) (((pase: [+]))) (((pase: [-])))

* Los operadores con la misma precedencia se evalúan de izquierda a derecha (excepto la exponenciación). Entonces, en la expresión + grados / 2 * π +, la división ocurre primero y el resultado se multiplica por + π +. Para dividir entre latexmath: [\ (2 \ pi \)], puede usar paréntesis, escribir + grados / 2 / π + o + grados / 2π +.

[PROPINA]
====
No trabajo mucho para recordar la precedencia de los operadores. Si no puedo verlo mirando la expresión, uso paréntesis para hacerlo obvio.
====

=== Operaciones de cadena

En general, no puede realizar operaciones matemáticas en cadenas, incluso si las cadenas parecen números, por lo que lo siguiente es ilegal:
(((operación de cadena))) (((operador, cadena)))

[fuente, julia]
----
"2" - "1" "huevos" / "fácil" "tercero" + "un encanto"
----

Pero hay dos excepciones, + * + y + pass: [^] +.
(((pase: [*]))) (((pase: [^])))

El operador + pass: [*] + realiza _concatenación de cadenas_, lo que significa que une las cadenas uniéndolas de extremo a extremo. Por ejemplo:
((("string", "concatenation", see = "concatenate"))) ((("concatenate")))

[fuente, @ julia-repl-test]
----
julia> first_str = "garganta"
"garganta"
julia> second_str = "curruca"
"curruca"
julia> first_str * second_str
"enrojecedor"
----

El operador + ^ + también funciona en cadenas; Realiza la repetición. Por ejemplo, pase "Spam" +: [^] 3+ es + "SpamSpamSpam" +. Si uno de los valores es una cadena, el otro tiene que ser un número entero.
((("cadena", "repetición", ver = "repetición"))) ((("repetición")))

Este uso de + pass: [*] + y + ^ + tiene sentido por analogía con multiplicación y exponenciación. Así como + 4pass: [^] 3+ es equivalente a + 4 * 4 * 4 +, esperamos que el pase + "Spam": [^] 3+ sea el mismo que el pase +: ["Spam" * "Spam" * "Spam"] +, y lo es.


=== Comentarios

A medida que los programas se hacen más grandes y más complicados, se vuelven más difíciles de leer. Los lenguajes formales son densos, y a menudo es difícil mirar un código y descubrir qué está haciendo o por qué.

Por esta razón, es una buena idea agregar notas a sus programas para explicar en lenguaje natural lo que está haciendo el programa. Estas notas se llaman _comments_, y comienzan con el símbolo + # +:
(((comentario))) ((("pasar: [#]", ver = "comentario")))

[fuente, julia]
----
# calcular el porcentaje de la hora que ha transcurrido
porcentaje = (minuto * 100) / 60
----

En este caso, el comentario aparece en una línea por sí mismo. También puede poner comentarios al final de una línea:

[fuente, julia]
----
porcentaje = (minuto * 100) / 60 # porcentaje de una hora
----

Todo, desde el + # + hasta el final de la línea, se ignora, no tiene ningún efecto en la ejecución del programa.

Los comentarios son más útiles cuando documentan características no obvias del código. Es razonable suponer que el lector puede averiguar qué hace el código; Es más útil explicar _por qué_.

Este comentario es redundante con el código e inútil:

[fuente, julia]
----
v = 5 # asigna 5 a v
----

Este comentario contiene información útil que no está en el código:

[fuente, julia]
----
v = 5 # velocidad en metros / segundo.
----

[ADVERTENCIA]
====
Los buenos nombres de variables pueden reducir la necesidad de comentarios, pero los nombres largos pueden hacer que las expresiones complejas sean difíciles de leer, por lo que existe una compensación.
====


=== Depuración

Se pueden producir tres tipos de errores en un programa: errores de sintaxis, errores de tiempo de ejecución y errores semánticos. Es útil distinguirlos para rastrearlos más rápidamente.
(((depuración)))

Error de sintaxis::
"Sintaxis" se refiere a la estructura de un programa y las reglas sobre esa estructura. Por ejemplo, los paréntesis tienen que venir en pares coincidentes, por lo que + (1 + 2) + es legal, pero +8) + es un error de sintaxis.
+
Si hay un error de sintaxis en cualquier parte de su programa, Julia muestra un mensaje de error y se cierra, y no podrá ejecutar el programa. Durante las primeras semanas de su carrera de programación, puede pasar mucho tiempo rastreando errores de sintaxis. A medida que gane experiencia, cometerá menos errores y los encontrará más rápido.
(((error de sintaxis))) (((mensaje de error)))

Error de tiempo de ejecución::
El segundo tipo de error es un error de tiempo de ejecución, llamado así porque el error no aparece hasta después de que el programa ha comenzado a ejecutarse. Estos errores también se denominan _excepciones_ porque generalmente indican que ha sucedido algo excepcional (y malo).
+
Los errores de tiempo de ejecución son raros en los programas simples que verá en los primeros capítulos, por lo que puede pasar un tiempo antes de que encuentre uno.
(((error de tiempo de ejecución))) ((("error", "tiempo de ejecución", ver = "error de tiempo de ejecución"))) (((excepción, ver = "error de tiempo de ejecución")))

Error semántico ::
El tercer tipo de error es "semántico", que significa relacionado con el significado. Si hay un error semántico en su programa, se ejecutará sin generar mensajes de error, pero no hará lo correcto. Hará algo más. Específicamente, hará lo que usted le dijo que hiciera.
+
Identificar errores semánticos puede ser complicado porque requiere que trabajes hacia atrás mirando la salida del programa e intentando descubrir qué está haciendo.
(((error semántico))) ((("error", "semántico", ver = "error semántico")))

=== Glosario

variable::
Un nombre que se refiere a un valor.
(((variable)))

asignación::
Una declaración que asigna un valor a una variable
(((asignación)))

diagrama de estado::
Una representación gráfica de un conjunto de variables y los valores a los que se refieren.
(((diagrama de estado)))

palabra clave::
Una palabra reservada que se utiliza para analizar un programa; no puede usar palabras clave como + if +, + function + y + while + como nombres de variables.
(((palabra clave)))

operando ::
Uno de los valores en los que opera un operador.
(((operando)))

expresión::
Una combinación de variables, operadores y valores que representa un solo resultado.
(((expresión)))

evaluar::
Para simplificar una expresión realizando las operaciones para obtener un valor único.
(((evaluar)))

declaración::
Una sección de código que representa un comando o acción. Hasta ahora, las declaraciones que hemos visto son asignaciones y declaraciones impresas.
(((declaración)))

ejecutar::
Para ejecutar una declaración y hacer lo que dice.
(((ejecutar)))

modo interactivo::
Una forma de utilizar Julia REPL escribiendo código en el indicador.
(((modo interactivo)))

modo de secuencia de comandos ::
Una forma de usar Julia para leer el código de un script y ejecutarlo.
(((modo script)))

guión::
Un programa almacenado en un archivo.
(((guión)))

precedencia del operador ::
Reglas que rigen el orden en que se evalúan las expresiones que involucran múltiples operadores matemáticos y operandos.
(((precedencia del operador)))

concatenar::
Para unir dos cadenas de extremo a extremo.
(((concatenación de cadenas)))

comentario::
Información en un programa que está destinada a otros programadores (o cualquier persona que lea el código fuente) y no tiene ningún efecto en la ejecución del programa.
(((comentario)))

error de sintaxis::
Un error en un programa que hace que sea imposible de analizar (y, por lo tanto, imposible de interpretar).
(((error de sintaxis)))

error de tiempo de ejecución o excepción ::
Un error que se detecta mientras se ejecuta el programa.
(((Error de tiempo de ejecución)))

semántica::
El significado de un programa.
(((semántica)))

error semántico ::
Un error en un programa que hace que haga algo diferente a lo que pretendía el programador.
(((error semántico)))


=== Ejercicios

[[ex02-1]]
===== Ejercicio 2-2

Repitiendo mi consejo del capítulo anterior, cada vez que aprenda una nueva característica, debe probarla en modo interactivo y cometer errores a propósito para ver qué sale mal.

. Hemos visto que + n = 42+ es legal. ¿Qué pasa con +42 = n +?

. ¿Qué tal + x = y = 1+?

. En algunos idiomas, cada declaración termina con un punto y coma, +; +. ¿Qué sucede si pones un punto y coma al final de una declaración de Julia?
(((pasar:[;])))

. ¿Qué pasa si pone un punto al final de una declaración?

. En notación matemática puedes multiplicar + x + y + y + de esta manera: + x y +. ¿Qué pasa si intentas eso en Julia? ¿Qué hay de 5x?

[[ex02-2]]
===== Ejercicio 2-3

Practique el uso de Julia REPL como calculadora:
(((calculadora)))

. El volumen de una esfera con radio latexmath: [\ (r \)] es latexmath: [\ (\ frac {4} {3} \ pi r ^ 3 \)]. ¿Cuál es el volumen de una esfera con radio 5?

. Supongamos que el precio de portada de un libro es de $ 24.95, pero las librerías obtienen un descuento del 40%. El envío cuesta $ 3 por la primera copia y 75 centavos por cada copia adicional. ¿Cuál es el costo total al por mayor de 60 copias?

. Si salgo de mi casa a las 6:52 a.m. y corro 1 milla a un ritmo fácil (8:15 por milla), luego 3 millas a ritmo (7:12 por milla) y 1 milla a ritmo fácil nuevamente, ¿a qué hora debo llegar a casa para el desayuno?
