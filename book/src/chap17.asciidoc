[[chap17]]
== Multiple Dispatch

Julia permite escribir código que puede operar en diferentes tipos. Esto se llama programación genérica.

En este capítulo se discutirá sobre el uso de declaraciones de tipo en Julia, y se presentan los métodos, que son formas de implementar diferentes comportamientos en una función dependiendo de los tipos de sus argumentos. Esto es llamado multiple dispatch.


=== Declaraciones de Tipo

El operador +::+ asocia _anotaciones de tipo_ a expresiones y variables:
(((TypeError)))((("error", "Core", "TypeError", see="TypeError")))

[source,@julia-repl-test]
----
julia> (1 + 2) :: Float64
ERROR: TypeError: in typeassert, expected Float64, got Int64
julia> (1 + 2) :: Int64
3
----

Esto ayuda a confirmar que su programa funciona de la manera esperada.

El operador +::+ también se puede agregar al lado izquierdo de una asignación, o como parte de una declaración.
(((returnfloat)))((("function", "programmer-defined", "returnfloat", see="returnfloat")))

[source,@julia-repl-test]
----
julia> function devolverfloat()
           x::Float64 = 100
           x
       end
returnfloat (generic function with 1 method)
julia> x = returnfloat()
100.0
julia> typeof(x)
Float64
----

La variable +x+ siempre es de tipo +Float64+, y su valor se convierte en un punto flotante si es necesario.

También se puede añadir una anotación de tipo al encabezado de una definición de función:
(((sinc)))((("function", "programmer-defined", "sinc", see="sinc")))

[source,@julia-setup]
----
function sinc(x)::Float64
    if x == 0
        return 1
    end
    sin(x)/(x)
end
----

El valor de retorno de +sinc+ siempre se convierte al tipo +Float64+.

En Julia, el comportamiento por defecto cuando se omiten los tipos es permitir que los valores sean de cualquier tipo (+Any+).
(((Any)))


=== Metodos

En <<chap16>>, definimos una estructura llamada +Hora+ y en <<time>>, escribimos una función llamada +imprimirhora+:
(((MyTime)))(((printtime)))

[source,@julia-setup chap17a]
----
using Printf

struct Hora
    hora :: Int64
    minuto :: Int64
    segundo :: Int64
end

function imprimirhora(tiempo)
    @printf("%02d:%02d:%02d", tiempo.hora, tiempo.minuto, tiempo.segundo)
end
----

Las declaraciones de tipo pueden y deben agregarse por motivos de rendimiento a los atributos en una definición de estructura.

Para llamar a esta función, debe pasar un objeto +Hora+ como argumento:

[source,@julia-repl-test chap17a]
----
julia> inicio = Hora(9, 45, 0)
Hora(9, 45, 0)
julia> imprimirhora(inicio)
09:45:00
----

Para agregar un _método_ a la función +imprimirhora+ para que solo acepte como argumento un objeto +Hora+, todo lo que tenemos que hacer es agregar +::+ seguido de +Hora+ al argumento +tiempo+ en la definición de la función:
(((method)))

[source,@julia-setup chap17a]
----
function imprimirhora(tiempo::Hora)
    @printf("%02d:%02d:%02d", tiempo.hora, tiempo.minuto, tiempo.segundo)
end
----

Un método es una definición de función con una _signature_ específica: +imprimirhora+ tiene un argumento de tipo +Hora+.
(((signature)))

Llamar a la función +imprimirhora+ con un objeto +Hora+ produce el mismo resultado que antes:

[source,@julia-repl-test chap17a]
----
julia> imprimirhora(inicio)
09:45:00
----

Ahora podemos redefinir el primer método sin la anotación de tipo +::+, lo cual permite un argumento de cualquier tipo:

[source,@julia-setup chap17a]
----
function imprimirhora(tiempo)
    println("No sé cómo imprimir el tiempo del argumento.")
end
----

Si llama a la función +imprimirhora+ con un objeto diferente de +Hora+, obtendrás:

[source,@julia-repl-test chap17a]
----
julia> imprimirhora(150)
No sé cómo imprimir el tiempo del argumento.
----

==== Ejercicio 17-1

Reescriba +horaaentero+ y +enteroahora+ (de <<prototyping_versus_planning>>) para que especifiquen el tipo del argumento.
(((timetoint)))(((inttotime)))


[source,@julia-eval chap17a]
----
function horaaentero(tiempo)
    minutos = tiempo.hora * 60 + tiempo.minuto
    segundos = minutos * 60 + tiempo.segundo
end;

function enteroahora(segundos)
    (minutos, segundo) = divrem(segundos, 60)
    hora, minuto = divrem(minutos, 60)
    Hora(hora, minuto, segundo)
end;
----

=== Ejemplos Adicionales

Aquí hay una versión de +incrementar+ (Ejercicio 16-5 de <<modificadores>>) reescrita especificando sus argumentos:
(((increment)))

[source,@julia-setup chap17a]
----
function incrementar(tiempo::Hora, segundos::Int64)
    segundos += horaaentero(tiempo)
    enteroahora(segundos)
end
----

Tenga en cuenta que ahora, +incrementar+ es una función pura, no un modificador.

Así es como se llama a incrementar:

[source,@julia-repl-test chap17a]
----
julia> inicio = Hora(9, 45, 0)
Hora(9, 45, 0)
julia> incrementar(inicio, 1337)
Hora(10, 7, 17)
----

Si colocas los argumentos en el orden incorrecto, obtendrás un error:
(((MethodError)))

[source,@julia-repl-test chap17a]
----
julia> incrementar(1337, inicio)
ERROR: MethodError: no method matching increment(::Int64, ::MyTime)
----

El signature del método es +incrementar(tiempo::Hora, segundos::Int64)+ y no +incrementar(segundos::Int64, tiempo::Hora)+.

Reescribir +estadespues+ para que solo acepte objetos +Hora+ es tan fácil como esto:
(((isafter)))

[source,@julia-setup chap17a]
----
function estadespues(t1::Hora, t2::Hora)
    (t1.hora, t1.minuto, t1.segundo) > (t2.hora, t2.minuto, t2.segundo)
end
----

Por cierto, los argumentos opcionales permiten definir múltiples métodos. Por ejemplo, esta definición:

[source,@julia-setup]
----
function f(a=1, b=2)
    a + 2b
end
----

se traduce en los siguientes tres métodos:

[source,@julia-setup]
----
f(a, b) = a + 2b
f(a) = f(a, 2)
f() = f(1, 2)
----

Estas expresiones son definiciones válidas de métodos de Julia. Esta es una notación abreviada para definir funciones/métodos.

[[constructor]]
=== Constructores

Un _constructor_ es una función especial que se llama para crear un objeto. Los métodos de constructor por defecto de +Hora+ tienen los siguientes signatures:

A _constructor_ is a special function that is called to create an object. The default constructor methods of +MyTime+ have the following signatures:
(((constructor)))

[source,julia]
----
Hora(hora, minuto, segundo)
Hora(hora::Int64, minuto::Int64, segundo::Int64)
----

También podemos agregar nuestros propios métodos de _constructores externos_:
We can also add our own _outer constructor_ methods:
(((outer constructor)))((("constructor", "outer", see="outer constructor")))

[source,@julia-setup chap17a]
----
function Hora(tiempo::Hora)
    Hora(tiempo.hora, tiempo.minuto, tiempo.segundo)
end
----

Este método se llama _constructor de copia_ porque el nuevo objeto +Hora+ es una copia de su argumento.

This method is called a _copy constructor_ because the new +MyTime+ object is a copy of its argument.
(((copy constructor)))((("constructor", "copy", see="copy constructor")))

To enforce invariants, we need _inner constructor_ methods:
(((inner constructor)))((("constructor", "inner", see="inner constructor")))

[source,@julia-setup chap17b]
----
struct MyTime
    hour :: Int64
    minute :: Int64
    second :: Int64
    function MyTime(hour::Int64=0, minute::Int64=0, second::Int64=0)
        @assert(0 ≤ minute < 60, "Minute is not between 0 and 60.")
        @assert(0 ≤ second < 60, "Second is not between 0 and 60.")
        new(hour, minute, second)
    end
end
----

The struct +MyTime+ has now 4 inner constructor methods:

[source,julia]
----
MyTime()
MyTime(hour::Int64)
MyTime(hour::Int64, minute::Int64)
MyTime(hour::Int64, minute::Int64, second::Int64)
----

An inner constructor method is always defined inside the block of a type declaration and it has access to a special function called +new+ that creates objects of the newly declared type.

[WARNING]
====
The default constructor is not available if any inner constructor is defined. You have to write explicitly all the inner constructors you need.
====

A second method without arguments of the local function +new+ exists:
(((new)))((("function", "Base", "new", see="new")))

[source,@julia-setup chap17c]
----
mutable struct MyTime
    hour :: Int
    minute :: Int
    second :: Int
    function MyTime(hour::Int64=0, minute::Int64=0, second::Int64=0)
        @assert(0 ≤ minute < 60, "Minute is between 0 and 60.")
        @assert(0 ≤ second < 60, "Second is between 0 and 60.")
        time = new()
        time.hour = hour
        time.minute = minute
        time.second = second
        time
    end
end
----

This allows to construct recursive data structures, i.e. a struct where one of the fields is the struct itself. In this case the struct has to be mutable because its fields are modified after instantiation.
(((recursive data structures)))


=== +show+

+show+ is a special function that returns a string representation of an object. For example, here is a +show+ method for +MyTime+ objects:
(((show)))

[source,@julia-setup chap17b]
----
using Printf

function Base.show(io::IO, time::MyTime)
    @printf(io, "%02d:%02d:%02d", time.hour, time.minute, time.second)
end
----

The prefix +Base+ is needed because we want to add a new method to the +Base.show+ function.

When you print an object, Julia invokes the +show+ function:

[source,@julia-repl-test chap17b]
----
julia> time = MyTime(9, 45)
09:45:00
----

When I write a new composite type, I almost always start by writing an outer constructor, which makes it easier to instantiate objects, and +show+, which is useful for debugging.

==== Exercise 17-2

Write an outer constructor method for the +Point+ class that takes +x+ and +y+ as optional parameters and assigns them to the corresponding fields.
(((Point)))


[source,@julia-eval chap17b]
----
function timetoint(time::MyTime)
    minutes = time.hour * 60 + time.minute
    seconds = minutes * 60 + time.second
end;

function inttotime(seconds::Int64)
    (minutes, second) = divrem(seconds, 60)
    hour, minute = divrem(minutes, 60)
    MyTime(hour, minute, second)
end;

function increment(time::MyTime, seconds::Int64)
    seconds += timetoint(time)
    inttotime(seconds)
end;
----

=== Operator Overloading

By defining operator methods, you can specify the behavior of operators on programmer-defined types. For example, if you define a method named +pass:[+]+ with two +MyTime+ arguments, you can use the +pass:[+]+ operator on +MyTime+ objects.

Here is what the definition might look like:

[source,@julia-setup chap17b]
----
import Base.+

function +(t1::MyTime, t2::MyTime)
    seconds = timetoint(t1) + timetoint(t2)
    inttotime(seconds)
end
----

The import statement adds the +pass:[+]+ operator to the local scope so that methods can be added.

And here is how you could use it:


[source,@julia-repl-test chap17b]
----
julia> start = MyTime(9, 45)
09:45:00
julia> duration = MyTime(1, 35, 0)
01:35:00
julia> start + duration
11:20:00
----

When you apply the +pass:[+]+ operator to +MyTime+ objects, Julia invokes the newly added method. When the REPL shows the result, Julia invokes +show+. So there is a lot happening behind the scenes!

Adding to the behavior of an operator so that it works with programmer-defined types is called _operator overloading_.
(((operator overloading)))


=== Multiple Dispatch

In the previous section we added two +MyTime+ objects, but you also might want to add an integer to a +MyTime+ object:

[source,@julia-setup chap17b]
----
function +(time::MyTime, seconds::Int64)
    increment(time, seconds)
end
----

Here is an example that uses the +pass:[+]+ operator with a +MyTime+ object and an integer:

[source,@julia-repl-test chap17b]
----
julia> start = MyTime(9, 45)
09:45:00
julia> start + 1337
10:07:17
----

Addition is a commutative operator so we have to add another method.

[source,@julia-setup chap17b]
----
function +(seconds::Int64, time::MyTime)
  time + seconds
end
----

And we get the same result:

[source,@julia-repl-test chap17b]
----
julia> 1337 + start
10:07:17
----

The choice of which method to execute when a function is applied is called _dispatch_. Julia allows the dispatch process to choose which of a function's methods to call based on the number of arguments given, and on the types of all of the function's arguments.  Using all of a function's arguments to choose which method should be invoked is known as _multiple dispatch_.
(((dispatch)))(((multiple dispatch)))

==== Exercise 17-3

Write +pass:[+]+ methods for point objects:

* If both operands are point objects, the method should return a new point object whose +x+ coordinate is the sum of the +x+ coordinates of the operands, and likewise for the +y+ coordinates.

* If the first or the second operand is a tuple, the method should add the first element of the tuple to the +x+ coordinate and the second element to the +y+ coordinate, and return a new point object with the result.


=== Generic Programming

Multiple dispatch is useful when it is necessary, but (fortunately) it is not always necessary. Often you can avoid it by writing functions that work correctly for arguments with different types.

Many of the functions we wrote for strings also work for other sequence types. For example, in <<dictionary_collection_counters>> we used +histogram+ to count the number of times each letter appears in a word.
(((histogram)))

[source,@julia-setup chap17]
----
function histogram(s)
    d = Dict()
    for c in s
        if c ∉ keys(d)
            d[c] = 1
        else
            d[c] += 1
        end
    end
    d
end
----

This function also works for lists, tuples, and even dictionaries, as long as the elements of +s+ are hashable, so they can be used as keys in +d+.

[source,@julia-repl-test chap17]
----
julia> t = ("spam", "egg", "spam", "spam", "bacon", "spam")
("spam", "egg", "spam", "spam", "bacon", "spam")
julia> histogram(t)
Dict{Any,Any} with 3 entries:
  "bacon" => 1
  "spam"  => 4
  "egg"   => 1
----

Functions that work with several types are called _polymorphic_. Polymorphism can facilitate code reuse.
(((polymorphic)))

For example, the built-in function +sum+, which adds the elements of a sequence, works as long as the elements of the sequence support addition.
(((sum)))

Since a +pass:[+]+ method is provided for +MyTime+ objects, they work with +sum+:

[source,@julia-repl-test chap17b]
----
julia> t1 = MyTime(1, 7, 2)
01:07:02
julia> t2 = MyTime(1, 5, 8)
01:05:08
julia> t3 = MyTime(1, 5, 0)
01:05:00
julia> sum((t1, t2, t3))
03:17:10
----

In general, if all of the operations inside a function work with a given type, the function works with that type.

The best kind of polymorphism is the unintentional kind, where you discover that a function you already wrote can be applied to a type you never planned for.
(((polymorphism)))


=== Interface and Implementation

One of the goals of multiple dispatch is to make software more maintainable, which means that you can keep the program working when other parts of the system change, and modify the program to meet new requirements.

A design principle that helps achieve that goal is to keep interfaces separate from implementations. This means that the methods having an argument annotated with a type should not depend on how the fields of that type are represented.
(((interface)))(((implementation)))

For example, in this chapter we developed a struct that represents a time of day. Methods having an argument annotated with this type include +timetoint+, +isafter+, and +pass:[+]+.

We could implement those methods in several ways. The details of the implementation depend on how we represent +MyTime+. In this chapter, the fields of a +MyTime+ object are +hour+, +minute+, and +second+.

As an alternative, we could replace these fields with a single integer representing the number of seconds since midnight. This implementation would make some functions, like +isafter+, easier to write, but it makes other functions harder.

After you deploy a new type, you might discover a better implementation. If other parts of the program are using your type, it might be time-consuming and error-prone to change the interface.

But if you designed the interface carefully, you can change the implementation without changing the interface, which means that other parts of the program don’t have to change.


=== Debugging

Calling a function with the correct arguments can be difficult when more than one method for the function is specified. Julia allows to introspect the signatures of the methods of a function.

To know what methods are available for a given function, you can use the function +methods+:
(((methods)))(((debugging)))

[source,jlcon]
----
julia> methods(printtime)
# 2 methods for generic function "printtime":
[1] printtime(time::MyTime) in Main at REPL[3]:2
[2] printtime(time) in Main at REPL[4]:2
----

In this example, the function +printtime+ has 2 methods: one with a +MyTime+ argument and one with an +Any+ argument.


=== Glossary

type annotation::
The operator +::+ followed by a type indicating that an expression or a variable is of that type.
(((type annotation)))

method::
A definition of a possible behavior for a function.
(((method)))

dispatch::
The choice of which method to execute when a function is executed.
(((dispatch)))

signature::
The number and type of the arguments of a method allowing the dispatch to select the most specific method of a function during the function call.
(((signature)))

outer constructor::
Constructor defined outside the type definition to define convenience methods for creating an object.
(((outer constructor)))

inner constructor::
Constructor defined inside the type definition to enforce invariants or to construct self-referential objects.
(((inner constructor)))

default constructor::
Inner constructor that is available when no programmer-defined inner constructors are provided.
(((default constructor)))

copy constructor::
Outer constructor method of a type with as only argument an object of the type. It creates a new object that is a copy of the argument.
(((copy constructor)))

operator overloading::
Adding to the behavior of an operator like +pass:[+]+ so it works with a programmer-defined type.
(((operator overloading)))

multiple dispatch::
Dispatch based on all of a function's arguments.
(((multiple dispatch)))

generic programming::
Writing code that can work with more than one type.
(((generic programming)))


=== Exercises

[[ex17-1]]
==== Exercise 17-4

Change the fields of +MyTime+ to be a single integer representing seconds since midnight. Then modify the methods defined in this chapter to work with the new implementation.

[[ex17-2]]
==== Exercise 17-5

Write a definition for a type named +Kangaroo+ with a field named +pouchcontents+ of type +Array+ and the following methods:
(((Kangaroo)))((("type", "programmer-defined", "Kangaroo", see="Kangaroo")))

* A constructor that initializes +pouchcontents+ to an empty array.

* A method named +putinpouch+ that takes a +Kangaroo+ object and an object of any type and adds it to +pouchcontents+.
(((putinpouch)))((("function", "programmer-defined", "putinpouch", see="putinpouch")))

* A +show+ method that returns a string representation of the +Kangaroo+ object and the contents of the pouch.
(((show)))

Test your code by creating two +Kangaroo+ objects, assigning them to variables named +kanga+ and +roo+, and then adding +roo+ to the contents of +kanga+’s pouch.

