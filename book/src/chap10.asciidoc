[[chap10]]
== Arrays

Este capítulo presenta uno de los tipos más útiles de Julia: las matrices. También aprenderemos sobre objetos y lo que puede suceder cuando se tiene más de un nombre para el mismo objeto.

=== Una matriz es una secuencia

Al igual que una cadena, un _array_ es una secuencia de valores. En una cadena los valores son caracteres, en una matriz pueden ser de cualquier tipo. Los valores en una matriz se denominan _elementos_ o, a veces, _items_.
(((array)))(((element)))(((item)))

Hay varias formas de crear una nueva matriz; lo más simple es poner los elementos entre corchetes (+[ ]+):
(((bracket operator)))

[source,julia]
----
[10, 20, 30, 40]
["abadejo", "falsía", "estrambote"]
----

El primer ejemplo es una matriz de cuatro enteros. El segundo es una matriz de tres cadenas. Los elementos de una matriz no tienen que ser del mismo tipo. La siguiente matriz contiene una cadena, un número de punto flotante, un entero y otra matriz:

[source,julia]
----
["spam", 2.0, 5, [10, 20]]
----

Una matriz dentro de otra matriz se dice _anidada_.
(((nested)))

Una matriz que no contiene elementos se llama matriz vacía; se puede crear una con corchetes vacíos, +[]+.
(((empty array)))

Como es de esperar, se pueden asignar valores de una matriz a una variable:

[source,@julia-repl-test chap10]
----
julia> quesos = ["Cheddar", "Edam", "Gouda"];

julia> numeros = [42, 123];

julia> vacio = [];

julia> print(quesos, " ", numeros, " ", vacio)
["Cheddar", "Edam", "Gouda"] [42, 123] Any[]
----

La función +typeof+ se puede usar para conocer el tipo de la matriz:
(((typeof)))

[source,@julia-repl-test chap10]
----
julia> typeof(quesos)
Array{String,1}
julia> typeof(numeros)
Array{Int64,1}
julia> typeof(vacio)
Array{Any,1}
----

El tipo de la matriz se especifica entre llaves, y se compone de un tipo y un número. El número indica las dimensiones. El conjunto +vacío+ contiene valores de tipo +Any+, es decir, puede contener valores de todos los tipos.
(((Array)))((("type", "Base", "Array", see="Array")))(((Any)))((("type", "Base", "Any", see="Any")))


=== Las matrices son mutables

La sintaxis para acceder a los elementos de una matriz es la misma que para acceder a los caracteres de una cadena: el operador corchete. La expresión dentro de los corchetes especifica el índice. Recuerde que los índices comienzan en 1:
(((bracket operator)))(((index)))

[source,@julia-repl-test chap10]
----
julia> quesos[1]
"Cheddar"
----

A diferencia de las cadenas, las matrices son _mutables_. Cuando el operador corchete aparece en el lado izquierdo de una asignación, identifica el elemento de la matriz que será asignado:
(((mutable)))(((assignment statement)))

[source,@julia-repl-test chap10]
----
julia> numeros[2] = 5
5
julia> print(numeros)
[42, 5]
----

El segundo elemento de +numeros+, que era 123, ahora es 5.

<<fig10-1>> muestra los diagramas de estado para +quesos+, +numeros+ y +vacio+.
(((state diagram)))

[[fig10-1]]
.State diagram
image::images/fig101.svg[]

Las matrices son representadas mediante cuadros con elementos de la matriz en su interior. +quesos+ hace referencia a una matriz con tres elementos indexados +1+, +2+ y +3+. +numeros+ contiene dos elementos. El diagrama muestra que el valor del segundo elemento de +numeros+ se ha reasignado de +123+ a +5+. +vacio+ hace referencia a una matriz sin elementos.

Los índices de una matriz funcionan de la misma manera que los índices de una cadena (pero sin los problemas generados por la codificación UTF-8):

* Cualquier expresión entera se puede usar como índice.

* Si se intenta leer o escribir un elemento que no existe, se obtiene un +BoundsError+.

* La palabra reservada +end+ indica el último índice de la matriz.
(((end)))

El operador +∈+ también funciona en matrices:
(((in)))

[source,@julia-repl-test chap10]
----
julia> "Edam" ∈ quesos
true
julia> "Brie" in quesos
false
----


=== Recorriendo una Matriz

La forma más común de recorrer los elementos de una matriz es con un ciclo +for+. La sintaxis es la misma que para las cadenas:
(((traversal)))(((for statement)))

[source,@julia-setup chap10]
----
for queso in quesos
    println(queso)
end
----

Esto funciona bien si solo se necesita leer los elementos de la matriz. Pero si se desea escribir o actualizar los elementos, se necesitan índices. Una forma común de hacerlo es usando la función integrada +eachindex+:
(((eachindex)))((("function", "Base", "eachindex", see="eachindex")))

[source,@julia-setup chap10]
----
for i in eachindex(numeros)
    numeros[i] = numeros[i] * 2
end
----

Este bucle recorre la matriz y actualiza cada elemento. +length+ devuelve el número de elementos en la matriz. En cada iteración del ciclo, +i+ representa el índice del elemento actual. La sentencia de asignación usa +numeros[i]+ para leer el valor original del elemento y asignar el nuevo valor.

Un ciclo +for+ sobre una matriz vacía nunca ejecuta el cuerpo del bucle:
(((empty array)))

[source,@julia-setup]
----
for x in []
    println("Esto nunca pasa.")
end
----

Aunque una matriz puede contener otra matriz, esta matriz anidada cuenta como un elemento único. La longitud de esta matriz es cuatro:

[source,@julia-setup]
----
["spam", 1, ["Brie", "Roquefort", "Camembert"], [1, 2, 3]]
----


=== Porciones de matrices

El operador porción también funciona en matrices:
(((slice operator)))((("operator", "Base", "[:]", see="slice operator")))((("[:]", see="slice operator")))

[source,@julia-repl-test chap10]
----
julia> t = ['a', 'b', 'c', 'd', 'e', 'f'];

julia> print(t[1:3])
['a', 'b', 'c']
julia> print(t[3:end])
['c', 'd', 'e', 'f']
----

El operador porción +[:]+, hace una copia de toda la matriz:
(((copy)))

[source,@julia-repl-test chap10]
----
julia> print(t[:])
['a', 'b', 'c', 'd', 'e', 'f']
----

Como las matrices son mutables, es útil hacer una copia antes de realizar operaciones que las modifiquen.

Un operador porción en el lado izquierdo de una asignación puede actualizar varios elementos:

[source,@julia-repl-test chap10]
----
julia> t[2:3] = ['x', 'y'];

julia> print(t)
['a', 'x', 'y', 'd', 'e', 'f']
----


=== Librería de Matrices

Julia tiene funciones integradas que operan en matrices. Por ejemplo, +push!+ agrega un nuevo elemento al final de una matriz:
(((push!)))((("function", "Base", "push!", see="push!")))

[source,@julia-repl-test chap10]
----
julia> t = ['a', 'b', 'c'];

julia> push!(t, 'd');

julia> print(t)
['a', 'b', 'c', 'd']
----

+append!+ agrega elementos de una segunda matriz al final de la primera:
(((append!)))((("function", "Base", "append!", see="append!")))

[source,@julia-repl-test chap10]
----
julia> t1 = ['a', 'b', 'c'];

julia> t2 = ['d', 'e'];

julia> append!(t1, t2);

julia> print(t1)
['a', 'b', 'c', 'd', 'e']
----

En este ejemplo +t2+ no es modificado.

+sort!+ ordena los elementos de una matriz de menor a mayor:
(((sort!)))((("function", "Base", "sort!", see="sort!")))

[source,@julia-repl-test chap10]
----
julia> t = ['d', 'c', 'e', 'b', 'a'];

julia> sort!(t);

julia> print(t)
['a', 'b', 'c', 'd', 'e']
----

+sort+ devuelve una copia de los elementos de la matriz en orden:
(((sort)))((("function", "Base", "sort", see="sort")))

[source,@julia-repl-test chap10]
----
julia> t1 = ['d', 'c', 'e', 'b', 'a'];

julia> t2 = sort(t1);

julia> print(t1)
['d', 'c', 'e', 'b', 'a']
julia> print(t2)
['a', 'b', 'c', 'd', 'e']
----

[NOTE]
====
Como convención en Julia, se agrega +!+ a los nombres de las funciones que modifican sus argumentos.
(((!)))
====


=== Mapear, Filtrar y Reducir

Para sumar todos los números en una matriz se puede usar un ciclo como este:

[source,@julia-setup]
----
function sumartodo(t)
    total = 0
    for x in t
        total += x
    end
    total
end
----

+total+ se inicializa en 0. En cada iteración, con +pass:[+=]+ se añade un elemento de la matriz a la suma total. El operador +pass:[+=]+ es una forma simple de actualizar esta variable. Esta _sentencia de asignación aumentada_,
(((augmented assignment statement)))(((pass:[+=])))((("operator", "Base", "pass:[+=]", see="pass:[+=]")))

[source,julia]
----
total += x
----

es equivalente a 

[source,julia]
----
total = total + x
----

A medida que se ejecuta el ciclo, +total+ acumula la suma de los elementos. A veces se denomina _acumulador_ a una variable utilizada de esta manera.
(((accumulator)))

Sumar los elementos de una matriz es una operación tan común que Julia tiene una función integrada para ello, +sum+:
(((sum)))((("function", "Base", "sum", see="sum")))

[source,@julia-repl-test]
----
julia> t = [1, 2, 3, 4];

julia> sum(t)
10
----

Una operación como esta que combina una secuencia de elementos en un solo valor a veces se denomina _operación de reducción_.

An operation like this that combines a sequence of elements into a single value is sometimes called a _reduce operation_.
(((reduce operation)))

Es común querer recorrer una matriz mientras se construye otra. Por ejemplo, la siguiente función toma una matriz de cadenas y devuelve una nueva matriz que contiene las mismas cadenas pero en mayúsculas:
(((capitalizeall)))((("function", "programmer-defined", "capitalizeall", see="capitalizeall")))(((uppercase)))

[source,@julia-setup]
----
function todoenmayusculas(t)
    res = []
    for s in t
        push!(res, uppercase(s))
    end
    res
end
----

+res+ se inicializa con una matriz vacía. Y en cada iteración se agrega un nuevo elemento. De esta manera, +res+ es otro tipo de acumulador.

Una operación como +todoenmayusculas+ a veces se denomina _mapeo_ porque se "asigna" una función (en este caso +uppercase+) a cada uno de los elementos en una secuencia.
(((map)))

Otra operación común es seleccionar algunos de los elementos de una matriz y devolver una submatriz. Por ejemplo, la siguiente función toma una matriz de cadenas y devuelve una matriz que contiene solo las cadenas en mayúsculas:
(((onlyupper)))((("function", "programmer-defined", "onlyupper", see="onlyupper")))

[source,@julia-setup]
----
function solomayusculas(t)
    res = []
    for s in t
        if s == uppercase(s)
            push!(res, s)
        end
    end
    res
end
----

An operation like +onlyupper+ is called a _filter_ because it selects some of the elements and filters out the others.
(((filter)))

Most common array operations can be expressed as a combination of map, filter and reduce.


=== Dot Syntax

For every binary operator like +pass:[^]+, there is a corresponding _dot operator_ pass:[<code>.^</code>] that is automatically defined to perform +pass:[^]+ element-by-element on arrays. For example, pass:[<code>&#91;1, 2, 3&#93; ^ 3</code>] is not defined, but pass:[<code>&#91;1, 2, 3&#93; .^ 3</code>] is defined as computing the elementwise result pass:[<code>&#91;1^3, 2^3, 3^3&#93;</code>]:
(((dot operator)))((("operator", "Base", ".", see="dot operator")))(((".", see="dot operator")))

[source,@julia-repl-test]
----
julia> print([1, 2, 3] .^ 3)
[1, 8, 27]
----

Any Julia function +f+ can be applied elementwise to any array with the _dot syntax_. For example to capitalize an array of strings, we don't need an explicit loop:
(((dot syntax)))

[source,@julia-repl-test]
----
julia> t = uppercase.(["abc", "def", "ghi"]);

julia> print(t)
["ABC", "DEF", "GHI"]
----

This is an elegant way to create a map. The function +capitalizeall+ can be implemented by a one-liner:
(((capitalizeall)))

[source,@julia-setup]
----
function capitalizeall(t)
    uppercase.(t)
end
----


=== Deleting (Inserting) Elements

There are several ways to delete elements from an array. If you know the index of the element you want, you can use +splice!+:
(((splice!)))((("function", "Base", "splice!", see="splice!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> splice!(t, 2)
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
julia> print(t)
['a', 'c']
----

+splice!+ modifies the array and returns the element that was removed.

+pop!+ deletes and returns the last element:
(((pop!)))((("function", "Base", "pop!", see="pop!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> pop!(t)
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
julia> print(t)
['a', 'b']
----

+popfirst!+ deletes and returns the first element:
(((popfirst!)))((("function", "Base", "popfirst!", see="popfirst!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> popfirst!(t)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia> print(t)
['b', 'c']
----

The functions +pushfirst!+ and +push!+ insert an element at the beginning, respectively at the end of the array.
(((pushfirst!)))((("function", "Base", "pushfirst!", see="pushfirst!")))(((push!)))

If you don’t need the removed value, you can use the function +deleteat!+:
(((deleteat!)))((("function", "Base", "deleteat!", see="deleteat!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> print(deleteat!(t, 2))
['a', 'c']
----

The function +insert!+ inserts an element at a given index:
(((insert!)))((("function", "Base", "insert!", see="insert!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> print(insert!(t, 2, 'x'))
['a', 'x', 'b', 'c']
----


=== Arrays and Strings

A string is a sequence of characters and an array is a sequence of values, but an array of characters is not the same as a string. To convert from a string to an array of characters, you can use the function +collect+:
(((collect)))((("function", "Base", "collect", see="collect")))

[source,@julia-repl-test]
----
julia> t = collect("spam");

julia> print(t)
['s', 'p', 'a', 'm']
----

The +collect+ function breaks a string or another sequence into individual elements.

If you want to break a string into words, you can use the +split+ function:
(((split)))((("function", "Base", "split", see="split")))

[source,@julia-repl-test]
----
julia> t = split("pining for the fjords");

julia> print(t)
SubString{String}["pining", "for", "the", "fjords"]
----

An _optional argument_ called a _delimiter_ specifies which characters to use as word boundaries. The following example uses a hyphen as a delimiter:
(((optional argument)))(((delimiter)))

[source,@julia-repl-test]
----
julia> t = split("spam-spam-spam", '-');

julia> print(t)
SubString{String}["spam", "spam", "spam"]
----

+join+ is the inverse of +split+. It takes an array of strings and concatenates the elements:
(((join)))((("function", "Base", "join", see="join")))

[source,@julia-repl-test]
----
julia> t = ["pining", "for", "the", "fjords"];

julia> s = join(t, ' ')
"pining for the fjords"
----

In this case the delimiter is a space character. To concatenate strings without spaces, you don't specify a delimiter.


=== Objects and Values

An _object_ is something a variable can refer to. Until now, you could use “object” and “value” interchangeably.
(((object)))(((variable)))(((value)))

If we run these assignment statements:

[source,julia]
----
a = "banana"
b = "banana"
----

We know that +a+ and +b+ both refer to a string, but we don’t know whether they refer to the _same_ string. There are two possible states, shown in Figure 10-2.
(((state diagram)))

.State diagrams.
image::images/fig102.svg[]


In one case, +a+ and +b+ refer to two different objects that have the same value. In the second case, they refer to the same object.

To check whether two variables refer to the same object, you can use the +≡+ (*+\equiv TAB+*) or +===+ operator.
(((≡)))((("operator", "Base", "≡", see="≡")))((("===", see="≡")))

[source,@julia-repl-test]
----
julia> a = "banana"
"banana"
julia> b = "banana"
"banana"
julia> a ≡ b
true
----

In this example, Julia only created one string object, and both +a+ and +b+ refer to it. But when you create two arrays, you get two objects:

[source,@julia-repl-test]
----
julia> a = [1, 2, 3];

julia> b = [1, 2, 3];

julia> a ≡ b
false
----

So the state diagram looks like <<fig10-3>>.
(((state diagram)))

[[fig10-3]]
.State diagram
image::images/fig103.svg[]


In this case we would say that the two arrays are _equivalent_, because they have the same elements, but not _identical_, because they are not the same object. If two objects are identical, they are also equivalent, but if they are equivalent, they are not necessarily identical.
(((equivalent)))(((identical)))

To be precise an object has a value. If you evaluate +[1, 2, 3]+, you get an array object whose value is a sequence of integers. If another array has the same elements, we say it has the same value, but it is not the same object.


=== Aliasing

If +a+ refers to an object and you assign +b = a+, then both variables refer to the same object:

[source,@julia-repl-test chap10]
----
julia> a = [1, 2, 3];

julia> b = a;

julia> b ≡ a
true
----

The state diagram looks like <<fig10-4>>.

[[fig10-4]]
.State diagram
image::images/fig104.svg[]


The association of a variable with an object is called a _reference_. In this example, there are two references to the same object.
(((reference)))

An object with more than one reference has more than one name, so we say that the object is _aliased_.
(((aliased)))

If the aliased object is mutable, changes made with one alias affect the other:
(((mutable)))

[source,@julia-repl-test chap10]
----
julia> b[1] = 42
42
julia> print(a)
[42, 2, 3]
----

[WARNING]
====
Although this behavior can be useful, it is error-prone. In general, it is safer to avoid aliasing when you are working with mutable objects.
====

For immutable objects like strings, aliasing is not as much of a problem. In this example:

[source,@julia-setup]
----
a = "banana"
b = "banana"
----

It almost never makes a difference whether +a+ and +b+ refer to the same string or not.


=== Array Arguments

When you pass an array to a function, the function gets a reference to the array. If the function modifies the array, the caller sees the change. For example, +deletehead!+ removes the first element from an array:
(((deletehead!)))((("function", "programmer-defined", "deletehead!", see="deletehead!")))(((popfirst!)))

[source,@julia-setup chap10]
----
function deletehead!(t)
    popfirst!(t)
end
----

Here’s how it is used:

[source,@julia-repl-test chap10]
----
julia> letters = ['a', 'b', 'c'];

julia> deletehead!(letters);

julia> print(letters)
['b', 'c']
----

The parameter +t+ and the variable +letters+ are aliases for the same object. The stack diagram looks like <<fig10-5>>.
(((stack diagram)))

[[fig10-5]]
.Stack diagram
image::images/fig105.svg[]

Since the array is shared by two frames, I drew it between them.

It is important to distinguish between operations that modify arrays and operations that create new arrays. For example, +push!+ modifies an array, but +vcat+ creates a new array.
(((push!)))(((vcat)))((("function", "Base", "vcat", see="vcat")))

Here’s an example using +push!+:

[source,@julia-repl-test chap10]
----
julia> t1 = [1, 2];

julia> t2 = push!(t1, 3);

julia> print(t1)
[1, 2, 3]
----

+t2+ is an alias of +t1+.

Here’s an example using +vcat+:

[source,@julia-repl-test chap10]
----
julia> t3 = vcat(t1, [4]);

julia> print(t1)
[1, 2, 3]
julia> print(t3)
[1, 2, 3, 4]
----

The result of +vcat+ is a new array, and the original array is unchanged.

This difference is important when you write functions that are supposed to modify arrays.

For example, this function _does not_ delete the head of a array:
(((baddeletehead)))((("function", "programmer-defined", "baddeletehead", see="baddeletehead")))

[source,@julia-setup chap10]
----
function baddeletehead(t)
    t = t[2:end]                # WRONG!
end
----

The slice operator creates a new array and the assignment makes +t+ refer to it, but that doesn’t affect the caller.
(((slice operator)))

[source,@julia-repl-test chap10]
----
julia> t4 = baddeletehead(t3);

julia> print(t3)
[1, 2, 3, 4]
julia> print(t4)
[2, 3, 4]
----

At the beginning of +baddeletehead+, +t+ and +t3+ refer to the same array. At the end, +t+ refers to a new array, but +t3+ still refers to the original, unmodified array.

An alternative is to write a function that creates and returns a new array. For example, +tail+ returns all but the first element of an array:
(((tail)))((("function", "programmer-defined", "tail", see="tail")))

[source,@julia-setup chap10]
----
function tail(t)
    t[2:end]
end
----

This function leaves the original array unmodified. Here’s how it is used:

[source,@julia-repl-test chap10]
----
julia> letters = ['a', 'b', 'c'];

julia> rest = tail(letters);

julia> print(rest)
['b', 'c']
----


=== Debugging

Careless use of arrays (and other mutable objects) can lead to long hours of debugging. Here are some common pitfalls and ways to avoid them:
(((debugging)))

* Most array functions modify the argument. This is the opposite of the string functions, which return a new string and leave the original alone.
+
If you are used to writing string code like this:
(((strip)))(((sort!)))
+
[source,julia]
----
new_word = strip(word)
----
+
It is tempting to write array code like this:
+
[source,julia]
----
t2 = sort!(t1)
----
+
Because +sort!+ returns the modified original array +t1+, +t2+ is an alias of +t1+.
+
[TIP]
====
Before using array functions and operators, you should read the documentation carefully and then test them in interactive mode.
====

* Pick an idiom and stick with it.
+
Part of the problem with arrays is that there are too many ways to do things. For example, to remove an element from an array, you can use +pop!+, +popfirst!+, +delete_at+, or even a slice assignment. To add an element, you can use +push!+, +pushfirst!+, +insert!+ or +vcat+. Assuming that +t+ is an array and +x+ is an array element, these are correct:
(((push!)))(((pushfirst!)))(((insert!)))(((vcat)))
+
[source,julia]
----
insert!(t, 4, x)
push!(t, x)
append!(t, [x])
----
+
And these are wrong:
+
[source,julia]
----
insert!(t, 4, [x])         # WRONG!
push!(t, [x])              # WRONG!
vcat(t, [x])               # WRONG!
----

* Make copies to avoid aliasing.
+
If you want to use a function like +sort!+ that modifies the argument, but you need to keep the original array as well, you can make a copy:
(((sort!)))
+
[source,@julia-repl-test chap10]
----
julia> t = [3, 1, 2];

julia> t2 = t[:]; # t2 = copy(t)

julia> sort!(t2);

julia> print(t)
[3, 1, 2]
julia> print(t2)
[1, 2, 3]
----
+
In this example you could also use the built-in function +sort+, which returns a new, sorted array and leaves the original alone:
(((sort)))
+
[source,@julia-repl-test chap10]
----
julia> t2 = sort(t);

julia> println(t)
[3, 1, 2]
julia> println(t2)
[1, 2, 3]
----


=== Glossary

array::
A sequence of values.
(((array)))

element::
One of the values in an array (or other sequence), also called items.
(((element)))

nested array::
An array that is an element of another array.
(((nested array)))

accumulator::
A variable used in a loop to add up or accumulate a result.
(((accumulator)))

augmented assignment::
A statement that updates the value of a variable using an operator like +=+.
(((augmented assignment)))

dot operator::
Binary operator that is applied element-by-element to arrays.
(((dot operator)))

dot syntax::
Syntax used to apply a function elementwise to any array.
(((dot syntax)))

reduce operation::
A processing pattern that traverses a sequence and accumulates the elements into a single result.
(((reduce operation)))

map::
A processing pattern that traverses a sequence and performs an operation on each element.
(((map)))

filter::
A processing pattern that traverses a sequence and selects the elements that satisfy some criterion.
(((filter)))

object::
Something a variable can refer to. An object has a type and a value.
(((object)))

equivalent::
Having the same value.
(((equivalent)))

identical::
Being the same object (which implies equivalence).
(((identical)))

reference::
The association between a variable and its value.
(((reference)))

aliasing::
A circumstance where two or more variables refer to the same object.
(((aliasing)))

optional arguments::
arguments that are not required.
(((optional arguments)))

delimiter::
A character or string used to indicate where a string should be split.
(((delimiter)))


=== Exercises

[source,@julia-eval chap10]
----
function nestedsum(t)
  total = 0
  for nested in t
    total += sum(nested)
  end
  total
end;

function cumulsum(t)
  total = 0
  res = []
  for x in t
    total += x
    push!(res, total)
  end
  res
end;

function interior(t)
  t[2:end-1]
end;

function interior!(t)
  popfirst!(t)
  pop!(t)
  nothing
end;

function issort(t)
  t == sort(t)
end;
----

[[ex10-1]]
==== Exercise 10-1

Write a function called +nestedsum+ that takes an array of arrays of integers and adds up the elements from all of the nested arrays. For example:
(((nestedsum)))((("function", "programmer-defined", "nestedsum", see="nestedsum")))

[source,@julia-repl-test chap10]
----
julia> t = [[1, 2], [3], [4, 5, 6]];

julia> nestedsum(t)
21
----

[[ex10-2]]
==== Exercise 10-2

Write a function called +cumulsum+ that takes an array of numbers and returns the cumulative sum; that is, a new array where the latexmath:[\(i\)]th element is the sum of the first latexmath:[\(i\)] elements from the original array. For example:
(((cumulsum)))((("function", "programmer-defined", "cumulsum", see="cumulsum")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3];

julia> print(cumulsum(t))
Any[1, 3, 6]
----

[[ex10-3]]
==== Exercise 10-3

Write a function called +interior+ that takes an array and returns a new array that contains all but the first and last elements. For example:
(((interior)))((("function", "programmer-defined", "interior", see="interior")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3, 4];

julia> print(interior(t))
[2, 3]
----

[[ex10-4]]
==== Exercise 10-4

Write a function called +interior!+ that takes an array, modifies it by removing the first and last elements, and returns +nothing+. For example:
(((interior!)))((("function", "programmer-defined", "interior!", see="interior!")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3, 4];

julia> interior!(t)

julia> print(t)
[2, 3]
----

[[ex10-5]]
==== Exercise 10-5

Write a function called +issort+ that takes an array as a parameter and returns +true+ if the array is sorted in ascending order and +false+ otherwise. For example:
(((issort)))((("function", "programmer-defined", "issort", see="issort")))

[source,@julia-repl-test chap10]
----
julia> issort([1, 2, 2])
true
julia> issort(['b', 'a'])
false
----

[[ex10-6]]
==== Exercise 10-6

Two words are anagrams if you can rearrange the letters from one to spell the other. Write a function called +isanagram+ that takes two strings and returns +true+ if they are anagrams.
(((isanagram)))((("function", "programmer-defined", "isanagram", see="isanagram")))

[[ex10-7]]
==== Exercise 10-7

Write a function called +hasduplicates+ that takes an array and returns +true+ if there is any element that appears more than once. It should not modify the original array.
(((hasduplicates)))((("function", "programmer-defined", "hasduplicates", see="hasduplicates")))

[[ex10-8]]
==== Exercise 10-8

This exercise pertains to the so-called Birthday Paradox, which you can read about at https://en.wikipedia.org/wiki/Birthday_paradox.
(((Birthday paradox)))

If there are 23 students in your class, what are the chances that two of you have the same birthday? You can estimate this probability by generating random samples of 23 birthdays and checking for matches.
(((rand)))((("function", "Base", "rand", see="rand")))

[TIP]
====
You can generate random birthdays with +rand(1:365)+.
====

[[ex10-9]]
==== Exercise 10-9

Write a function that reads the file +palabras.txt+ and builds an array with one element per word. Write two versions of this function, one using +push!+ and the other using the idiom +t = [pass:[t...], x]+. Which one takes longer to run? Why?
(((push!)))

[[ex10-10]]
==== Exercise 10-10

To check whether a word is in the word array, you could use the +∈+ operator, but it would be slow because it searches through the words in order.

Because the words are in alphabetical order, we can speed things up with a bisection search (also known as binary search), which is similar to what you do when you look a word up in the dictionary. You start in the middle and check to see whether the word you are looking for comes before the word in the middle of the array. If so, you search the first half of the array the same way. Otherwise you search the second half.

Either way, you cut the remaining search space in half. If the word array has 113,809 words, it will take about 17 steps to find the word or conclude that it’s not there.

Write a function called +inbisect+ that takes a sorted array and a target value and returns +true+ if the word is in the array and +false+ if it’s not.
(((inbisect)))((("function", "programmer-defined", "inbisect", see="inbisect")))

[[ex10-11]]
==== Exercise 10-11

Two words are a “reverse pair” if each is the reverse of the other. Write a program +reversepairs+ that finds all the reverse pairs in the word array.
(((reversepairs)))((("function", "programmer-defined", "reversepairs", see="reversepairs")))

[[ex10-12]]
==== Exercise 10-12

Two words “interlock” if taking alternating letters from each forms a new word. For example, “shoe” and “cold” interlock to form “schooled”.
(((interlock)))

Credit: This exercise is inspired by an example at http://puzzlers.org.

. Write a program that finds all pairs of words that interlock.
+
[TIP]
====
Don’t enumerate all pairs!
====

. Can you find any words that are three-way interlocked; that is, every third letter forms a word, starting from the first, second or third?

