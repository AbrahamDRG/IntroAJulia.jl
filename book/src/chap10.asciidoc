[[chap10]]
== Matrices

Este capítulo presenta uno de los tipos más útiles de Julia: las matrices. También aprenderemos sobre objetos y lo que puede suceder cuando se tiene más de un nombre para el mismo objeto.

=== Una matriz es una secuencia

Al igual que una cadena de texto, una _matriz_ es una secuencia de valores. En una cadena los valores son caracteres, en una matriz pueden ser de cualquier tipo. Los valores en una matriz se denominan _elementos_ o, a veces, _items_.
(((array)))(((element)))(((item)))

Hay varias formas de crear una nueva matriz; la más sencilla es encerrar los elementos entre corchetes (+[ ]+):
(((bracket operator)))

[source,julia]
----
[10, 20, 30, 40]
["abadejo", "falsía", "estrambote"]
----

El primer ejemplo es una matriz de cuatro enteros. El segundo es una matriz de tres cadenas de texto. Los elementos de una matriz no tienen por qué ser del mismo tipo. La siguiente matriz contiene una cadena, un número de punto flotante, un entero y otra matriz:

[source,julia]
----
["spam", 2.0, 5, [10, 20]]
----

Se dice que una matriz dentro de otra matriz está _anidada_.
(((nested)))

Una matriz que no contiene elementos se llama matriz vacía; se puede crear una con corchetes vacíos, +[]+.
(((empty array)))

Como es de esperar, se pueden asignar valores de matrices a variables:

[source,@julia-repl-test chap10]
----
julia> quesos = ["Cheddar", "Edam", "Gouda"];

julia> numeros = [42, 123];

julia> vacio = [];

julia> print(quesos, " ", numeros, " ", vacio)
["Cheddar", "Edam", "Gouda"] [42, 123] Any[]
----

La función +typeof+ se puede usar para conocer el tipo de la matriz:
(((typeof)))

[source,@julia-repl-test chap10]
----
julia> typeof(quesos)
Array{String,1}
julia> typeof(numeros)
Array{Int64,1}
julia> typeof(vacio)
Array{Any,1}
----

El tipo de la matriz se especifica entre llaves, y se compone de un tipo y un número. El número indica las dimensiones. El conjunto +vacío+ contiene valores de tipo +Any+, es decir, puede contener valores de todos los tipos.
(((Array)))((("type", "Base", "Array", see="Array")))(((Any)))((("type", "Base", "Any", see="Any")))


=== Las matrices son mutables

La sintaxis para acceder a los elementos de una matriz es la misma que para acceder a los caracteres de una cadena: el operador corchetes. La expresión dentro de los corchetes especifica el índice. Recuerde que los índices comienzan en 1:
(((bracket operator)))(((index)))

[source,@julia-repl-test chap10]
----
julia> quesos[1]
"Cheddar"
----

A diferencia de las cadenas, las matrices son _mutables_, lo que significa que podemos cambiar sus elementos. Podemos modificar uno de sus elementos usando el operador corchetes en el lado izquierdo de una asignación:

(((mutable)))(((assignment statement)))

[source,@julia-repl-test chap10]
----
julia> numeros[2] = 5
5
julia> print(numeros)
[42, 5]
----

El segundo elemento de +numeros+, que era 123, ahora es 5.

<<fig10-1>> muestra los diagramas de estado para +quesos+, +numeros+ y +vacio+.
(((state diagram)))

[[fig10-1]]
.State diagram
image::images/fig101.svg[]

Las matrices son representadas mediante cuadros con elementos de la matriz en su interior. La matriz +quesos+ hace referencia a una matriz con tres elementos indexados +1+, +2+ y +3+. La matriz +numeros+ contiene dos elementos. El diagrama muestra que el valor del segundo elemento de +numeros+ se ha reasignado de +123+ a +5+. Finalmente, +vacio+ hace referencia a una matriz sin elementos.

Los índices de una matriz funcionan de la misma manera que los índices de una cadena (pero sin los problemas generados por la codificación UTF-8):

* Cualquier expresión entera se puede usar como índice.

* Si se intenta leer o escribir un elemento que no existe, se obtiene un +BoundsError+.

* La palabra reservada +end+ indica el último índice de la matriz.
(((end)))

El operador +∈+ también funciona en matrices:
(((in)))

[source,@julia-repl-test chap10]
----
julia> "Edam" ∈ quesos
true
julia> "Brie" in quesos
false
----


=== Recorriendo una Matriz

La forma más común de recorrer los elementos de una matriz es con un ciclo +for+. La sintaxis es la misma que para las cadenas:
(((traversal)))(((for statement)))

[source,@julia-setup chap10]
----
for queso in quesos
    println(queso)
end
----

Esto funciona bien si solo se necesita leer los elementos de la matriz. Pero si se desea escribir o actualizar los elementos es necesario utilizar índices. Una forma común de hacerlo es usando la función integrada +eachindex+:
(((eachindex)))((("function", "Base", "eachindex", see="eachindex")))

[source,@julia-setup chap10]
----
for i in eachindex(numeros)
    numeros[i] = numeros[i] * 2
end
----

Este bucle recorre la matriz y actualiza cada elemento. En cada iteración del ciclo, +i+ representa el índice del elemento actual. La sentencia de asignación usa +numeros[i]+ para leer el valor original del elemento y asignar el nuevo valor.

Por otra parte, +length+ devuelve el número de elementos en la matriz.

Un ciclo +for+ sobre una matriz vacía nunca ejecuta el cuerpo del bucle:
(((empty array)))

[source,@julia-setup]
----
for x in []
    println("Esto nunca pasa.")
end
----

Aunque una matriz puede contener otra matriz, esta matriz anidada cuenta como un elemento único. Por ejemplo, la longitud de esta matriz es cuatro:

[source,@julia-setup]
----
["spam", 1, ["Brie", "Roquefort", "Camembert"], [1, 2, 3]]
----


=== Porciones de matrices

El operador porción también funciona en matrices:
(((slice operator)))((("operator", "Base", "[:]", see="slice operator")))((("[:]", see="slice operator")))

[source,@julia-repl-test chap10]
----
julia> t = ['a', 'b', 'c', 'd', 'e', 'f'];

julia> print(t[1:3])
['a', 'b', 'c']
julia> print(t[3:end])
['c', 'd', 'e', 'f']
----

El operador porción +[:]+ hace una copia de toda la matriz:
(((copy)))

[source,@julia-repl-test chap10]
----
julia> print(t[:])
['a', 'b', 'c', 'd', 'e', 'f']
----

Como las matrices son mutables, es útil hacer una copia antes de realizar operaciones que las modifiquen.

Un operador porción en el lado izquierdo de una asignación puede actualizar varios elementos:

[source,@julia-repl-test chap10]
----
julia> t[2:3] = ['x', 'y'];

julia> print(t)
['a', 'x', 'y', 'd', 'e', 'f']
----


=== Librería de Matrices

Julia tiene funciones integradas que operan en matrices. Por ejemplo, +push!+ agrega un nuevo elemento al final de una matriz:
(((push!)))((("function", "Base", "push!", see="push!")))

[source,@julia-repl-test chap10]
----
julia> t = ['a', 'b', 'c'];

julia> push!(t, 'd');

julia> print(t)
['a', 'b', 'c', 'd']
----

+append!+ agrega elementos de una matriz al final de otra:
(((append!)))((("function", "Base", "append!", see="append!")))

[source,@julia-repl-test chap10]
----
julia> t1 = ['a', 'b', 'c'];

julia> t2 = ['d', 'e'];

julia> append!(t1, t2);

julia> print(t1)
['a', 'b', 'c', 'd', 'e']
----

En este ejemplo +t2+ no es modificado.

+sort!+ ordena los elementos de una matriz de menor a mayor:
(((sort!)))((("function", "Base", "sort!", see="sort!")))

[source,@julia-repl-test chap10]
----
julia> t = ['d', 'c', 'e', 'b', 'a'];

julia> sort!(t);

julia> print(t)
['a', 'b', 'c', 'd', 'e']
----

+sort+ devuelve una copia ordenada de los elementos de la matriz:
(((sort)))((("function", "Base", "sort", see="sort")))

[source,@julia-repl-test chap10]
----
julia> t1 = ['d', 'c', 'e', 'b', 'a'];

julia> t2 = sort(t1);

julia> print(t1)
['d', 'c', 'e', 'b', 'a']
julia> print(t2)
['a', 'b', 'c', 'd', 'e']
----

[NOTE]
====
Como convención en Julia, se agrega +!+ a los nombres de las funciones que modifican sus argumentos.
(((!)))
====


=== Mapear, Filtrar y Reducir

Para sumar todos los números en una matriz se puede usar un ciclo como este:

[source,@julia-setup]
----
function sumartodo(t)
    total = 0
    for x in t
        total += x
    end
    total
end
----

+total+ se inicializa en 0. En cada iteración, con +pass:[+=]+ se añade un elemento de la matriz a la suma total. El operador +pass:[+=]+ es una forma simple de actualizar esta variable. Esta _sentencia de asignación aumentada_,
(((augmented assignment statement)))(((pass:[+=])))((("operator", "Base", "pass:[+=]", see="pass:[+=]")))

[source,julia]
----
total += x
----

es equivalente a 

[source,julia]
----
total = total + x
----

A medida que se ejecuta el ciclo, +total+ acumula la suma de los elementos. A veces se denomina _acumulador_ a una variable utilizada de esta manera.
(((accumulator)))

Sumar los elementos de una matriz es una operación tan común que Julia tiene una función integrada para ello, +sum+:
(((sum)))((("function", "Base", "sum", see="sum")))

[source,@julia-repl-test]
----
julia> t = [1, 2, 3, 4];

julia> sum(t)
10
----

Una operación como esta, que combina una secuencia de elementos en un solo valor a veces se denomina _operación de reducción_.
(((reduce operation)))

Es común querer recorrer una matriz mientras se construye otra. Por ejemplo, la siguiente función toma una matriz de cadenas y devuelve una nueva matriz que contiene las mismas cadenas pero en mayúsculas:
(((capitalizeall)))((("function", "programmer-defined", "capitalizeall", see="capitalizeall")))(((uppercase)))

[source,@julia-setup]
----
function todoenmayusculas(t)
    res = []
    for s in t
        push!(res, uppercase(s))
    end
    res
end
----

+res+ se inicializa con una matriz vacía, y en cada iteración se le agrega un nuevo elemento. De esta manera, +res+ es otro tipo de acumulador.

Una operación como +todoenmayusculas+ a veces se denomina _mapeo_ porque "asigna" una función (en este caso +uppercase+) a cada uno de los elementos de una secuencia.
(((map)))

Otra operación común es seleccionar solo algunos de los elementos de una matriz y devolver una submatriz. Por ejemplo, la siguiente función toma una matriz de cadenas y devuelve una matriz que contiene solamente las cadenas en mayúsculas:
(((onlyupper)))((("function", "programmer-defined", "onlyupper", see="onlyupper")))

[source,@julia-setup]
----
function solomayusculas(t)
    res = []
    for s in t
        if s == uppercase(s)
            push!(res, s)
        end
    end
    res
end
----

Operaciones como +solomayusculas+ se llaman _filtro_ porque seleccionan solo algunos elementos, filtrando otros.
(((filter)))

Las operaciones de matriz más comunes son una combinación de mapeo, filtro y reducción.


=== Sintaxis de punto

Para cada operador binario, como por ejemplo +pass:[^]+, existe un _operador punto_ correspondiente pass:[<code>.^</code>] que automaticamente define la operación +pass:[^]+ para cada elemento de una matriz. Por ejemplo, pass:[<code>&#91;1, 2, 3&#93; ^ 3</code>] no está definido, pero pass:[<code>&#91;1, 2, 3&#93; .^ 3</code>] se define como el resultado de realizar la operación +pass:[^]+ en cada elemento pass:[<code>&#91;1^3, 2^3, 3^3&#93;</code>]:
(((dot operator)))((("operator", "Base", ".", see="dot operator")))(((".", see="dot operator")))

[source,@julia-repl-test]
----
julia> print([1, 2, 3] .^ 3)
[1, 8, 27]
----

Cualquier función +f+ de Julia puede ser aplicada a cada elemento de cualquier matriz con la _sintaxis de punto_. Por ejemplo, para poner en mayúsculas una matriz de cadenas, no es necesario un bucle explícito:
(((dot syntax)))

[source,@julia-repl-test]
----
julia> t = uppercase.(["abc", "def", "ghi"]);

julia> print(t)
["ABC", "DEF", "GHI"]
----

Esta es una forma elegante de crear un mapeo. Siguiendo esta lógica, la función +todoenmayusculas+ puede implementarse con una línea:
(((capitalizeall)))

[source,@julia-setup]
----
function todoenmayusculas(t)
    uppercase.(t)
end
----


=== Borrando (Insertando) Elementos

Hay varias formas de eliminar elementos de una matriz. Si se conoce el índice del elemento que se desea eliminar, se puede usar +splice!+:
(((splice!)))((("function", "Base", "splice!", see="splice!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> splice!(t, 2)
'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)
julia> print(t)
['a', 'c']
----

+splice!+ modifica la matriz y devuelve el elemento que se eliminó.

+pop!+ elimina y devuelve el último elemento:
(((pop!)))((("function", "Base", "pop!", see="pop!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> pop!(t)
'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)
julia> print(t)
['a', 'b']
----

+popfirst!+ elimina y devuelve el primer elemento:
(((popfirst!)))((("function", "Base", "popfirst!", see="popfirst!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> popfirst!(t)
'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)
julia> print(t)
['b', 'c']
----

Las funciones +pushfirst!+ y +push!+ insertan un elemento al principio y al final de la matriz, respectivamente.
(((pushfirst!)))((("function", "Base", "pushfirst!", see="pushfirst!")))(((push!)))

Si no se necesita el valor eliminado, se puede usar la función +deleteat!+:
(((deleteat!)))((("function", "Base", "deleteat!", see="deleteat!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> print(deleteat!(t, 2))
['a', 'c']
----

La función +insert!+ inserta un elemento en un índice dado:
(((insert!)))((("function", "Base", "insert!", see="insert!")))

[source,@julia-repl-test]
----
julia> t = ['a', 'b', 'c'];

julia> print(insert!(t, 2, 'x'))
['a', 'x', 'b', 'c']
----


=== Matrices y Cadenas

Una cadena es una secuencia de caracteres y una matriz es una secuencia de valores, pero una matriz de caracteres no es lo mismo que una cadena. Para convertir una cadena a una matriz de caracteres, se puede usar la función +collect+:
(((collect)))((("function", "Base", "collect", see="collect")))

[source,@julia-repl-test]
----
julia> t = collect("spam");

julia> print(t)
['s', 'p', 'a', 'm']
----

La función +collect+ divide una cadena u otra secuencia en elementos individuales.

Si desea dividir una cadena en palabras, puede usar la función +split+:
(((split)))((("function", "Base", "split", see="split")))

[source,@julia-repl-test]
----
julia> t = split("En un lugar de la Mancha");

julia> print(t)
SubString{String}["En", "un", "lugar", "de", "la", "Mancha"]
----

Un _argumento opcional_ llamado _delimitador_ especifica qué caracteres usar como límites de palabra. El siguiente ejemplo usa un guión como delimitador:
(((optional argument)))(((delimiter)))

[source,@julia-repl-test]
----
julia> t = split("hola-hola-hola", '-');

julia> print(t)
SubString{String}["hola", "hola", "hola"]
----

+join+ es el inverso de +split+. Toma una matriz de cadenas y concatena los elementos:
(((join)))((("function", "Base", "join", see="join")))

[source,@julia-repl-test]
----
julia> t = ["En", "un", "lugar", "de", "la", "Mancha"];

julia> s = join(t, ' ')
"En un lugar de la Mancha"
----

En este caso, el delimitador es un carácter de espacio en blanco. Para concatenar cadenas sin espacios, no especifique un delimitador.

=== Objeto y Valores 

Un _objeto_ es algo a lo que una variable puede referirse. Hasta ahora, podría usar "objeto" y "valor" indistintamente.
(((object)))(((variable)))(((value)))

Si ejecutamos estas sentencias de asignación:

[source,julia]
----
a = "banana"
b = "banana"
----

Sabemos que +a+ y +b+ apuntan a una cadena, pero no sabemos si están apuntando a la _misma_ cadena. Hay dos estados posibles, los cuales se muestran en la Figura 10-2.
(((state diagram)))

.State diagrams.
image::images/fig102.svg[]


En un caso, +a+ y +b+ se refieren a dos objetos diferentes que tienen el mismo valor. En el segundo caso, se refieren al mismo objeto. 

Para verificar si dos variables se refieren al mismo objeto, se puede usar el operador +≡+ (*+\equiv TAB+*)) o +===+.
(((≡)))((("operator", "Base", "≡", see="≡")))((("===", see="≡")))

[source,@julia-repl-test]
----
julia> a = "banana"
"banana"
julia> b = "banana"
"banana"
julia> a ≡ b
true
----

En este ejemplo, Julia solo creó un objeto de cadena, y ambas variables +a+ y +b+ apuntan a ella. Pero cuando se crean dos matrices, se obtienen dos objetos:

[source,@julia-repl-test]
----
julia> a = [1, 2, 3];

julia> b = [1, 2, 3];

julia> a ≡ b
false
----

Entonces el diagrama de estado se ve así <<fig10-3>>.
(((state diagram)))

[[fig10-3]]
.State diagram
image::images/fig103.svg[]


En este caso, diríamos que las dos matrices son _equivalentes_, porque tienen los mismos elementos, pero no _idénticos_, porque no son el mismo objeto. Si dos objetos son idénticos, también son equivalentes, pero si son equivalentes, no son necesariamente idénticos.
(((equivalent)))(((identical)))

Para ser precisos, un objeto tiene un valor. Si se evalúa +[1, 2, 3]+, se obtendrá un objeto de matriz cuyo valor es una secuencia de enteros. Si otra matriz tiene los mismos elementos, decimos que tiene el mismo valor, pero no es el mismo objeto.


=== Alias (poner sobrenombres)

Si +a+ apunta a un objeto, y asignas +b = a+, entonces ambas variables se refieren al mismo objeto:

[source,@julia-repl-test chap10]
----
julia> a = [1, 2, 3];

julia> b = a;

julia> b ≡ a
true
----

El diagrama de estado sería como este <<fig10-4>>.

[[fig10-4]]
.State diagram
image::images/fig104.svg[]


La asociación de una variable con un objeto se llama _referencia_. En este ejemplo, hay dos referencias al mismo objeto.
(((reference)))

Un objeto con más de una referencia tiene más de un nombre, por lo que decimos que el objeto tiene un _alias_.
(((aliased)))

Si el objeto con alias es mutable, los cambios hechos a un alias afectan al otro:
(((mutable)))

[source,@julia-repl-test chap10]
----
julia> b[1] = 42
42
julia> print(a)
[42, 2, 3]
----

[WARNING]
====
Aunque este comportamiento puede ser util, a veces puede inducir a errores. En general, es ms seguro evitar los alias cuando trabajemos con objetos mutables.
==== 

No hay problema con los alias al trabajar con objetos inmutables, tales como cadenas de texto. En este ejemplo: 

[source,@julia-setup]
----
a = "banana"
b = "banana"
----

Casi nunca es relevante que +a+ y +b+ se refieran a la misma cadena o no.


=== Matrices como argumentos

Cuando se pasa una matriz como argumento de una función, en realidad se pasa una referencia a ella. Si la función modifica la matriz, el que hizo la llamada verá el cambio. Por ejemplo, la función +borrarprimero+ elimina el primer elemento de una matriz:
(((deletehead!)))((("function", "programmer-defined", "deletehead!", see="deletehead!")))(((popfirst!)))

[source,@julia-setup chap10]
----
function borrarprimero(t)
    popfirst!(t)
end
----

Aquí vemos el uso de borrarprimero:

[source,@julia-repl-test chap10]
----
julia> letras = ['a', 'b', 'c'];

julia> deletehead!(letras);

julia> print(letras)
['b', 'c']
----

El parámetro +t+ y la variable +letras+ son alias de un mismo objeto. El diagrama de estado es así <<fig10-5>>.
(((stack diagram)))

[[fig10-5]]
.Stack diagram
image::images/fig105.svg[]

Como la matriz está compartida por dos marcos, la dibujamos entre ambos.

It is important to distinguish between operations that modify arrays and operations that create new arrays. For example, +push!+ modifies an array, but +vcat+ creates a new array.
(((push!)))(((vcat)))((("function", "Base", "vcat", see="vcat")))

Here’s an example using +push!+:

[source,@julia-repl-test chap10]
----
julia> t1 = [1, 2];

julia> t2 = push!(t1, 3);

julia> print(t1)
[1, 2, 3]
----

+t2+ is an alias of +t1+.

Here’s an example using +vcat+:

[source,@julia-repl-test chap10]
----
julia> t3 = vcat(t1, [4]);

julia> print(t1)
[1, 2, 3]
julia> print(t3)
[1, 2, 3, 4]
----

The result of +vcat+ is a new array, and the original array is unchanged.

This difference is important when you write functions that are supposed to modify arrays.

For example, this function _does not_ delete the head of a array:
(((baddeletehead)))((("function", "programmer-defined", "baddeletehead", see="baddeletehead")))

[source,@julia-setup chap10]
----
function baddeletehead(t)
    t = t[2:end]                # WRONG!
end
----

The slice operator creates a new array and the assignment makes +t+ refer to it, but that doesn’t affect the caller.
(((slice operator)))

[source,@julia-repl-test chap10]
----
julia> t4 = baddeletehead(t3);

julia> print(t3)
[1, 2, 3, 4]
julia> print(t4)
[2, 3, 4]
----

At the beginning of +baddeletehead+, +t+ and +t3+ refer to the same array. At the end, +t+ refers to a new array, but +t3+ still refers to the original, unmodified array.

An alternative is to write a function that creates and returns a new array. For example, +tail+ returns all but the first element of an array:
(((tail)))((("function", "programmer-defined", "tail", see="tail")))

[source,@julia-setup chap10]
----
function tail(t)
    t[2:end]
end
----

This function leaves the original array unmodified. Here’s how it is used:

[source,@julia-repl-test chap10]
----
julia> letters = ['a', 'b', 'c'];

julia> rest = tail(letters);

julia> print(rest)
['b', 'c']
----


=== Debugging

Careless use of arrays (and other mutable objects) can lead to long hours of debugging. Here are some common pitfalls and ways to avoid them:
(((debugging)))

* Most array functions modify the argument. This is the opposite of the string functions, which return a new string and leave the original alone.
+
If you are used to writing string code like this:
(((strip)))(((sort!)))
+
[source,julia]
----
new_word = strip(word)
----
+
It is tempting to write array code like this:
+
[source,julia]
----
t2 = sort!(t1)
----
+
Because +sort!+ returns the modified original array +t1+, +t2+ is an alias of +t1+.
+
[TIP]
====
Before using array functions and operators, you should read the documentation carefully and then test them in interactive mode.
====

* Pick an idiom and stick with it.
+
Part of the problem with arrays is that there are too many ways to do things. For example, to remove an element from an array, you can use +pop!+, +popfirst!+, +delete_at+, or even a slice assignment. To add an element, you can use +push!+, +pushfirst!+, +insert!+ or +vcat+. Assuming that +t+ is an array and +x+ is an array element, these are correct:
(((push!)))(((pushfirst!)))(((insert!)))(((vcat)))
+
[source,julia]
----
insert!(t, 4, x)
push!(t, x)
append!(t, [x])
----
+
And these are wrong:
+
[source,julia]
----
insert!(t, 4, [x])         # WRONG!
push!(t, [x])              # WRONG!
vcat(t, [x])               # WRONG!
----

* Make copies to avoid aliasing.
+
If you want to use a function like +sort!+ that modifies the argument, but you need to keep the original array as well, you can make a copy:
(((sort!)))
+
[source,@julia-repl-test chap10]
----
julia> t = [3, 1, 2];

julia> t2 = t[:]; # t2 = copy(t)

julia> sort!(t2);

julia> print(t)
[3, 1, 2]
julia> print(t2)
[1, 2, 3]
----
+
In this example you could also use the built-in function +sort+, which returns a new, sorted array and leaves the original alone:
(((sort)))
+
[source,@julia-repl-test chap10]
----
julia> t2 = sort(t);

julia> println(t)
[3, 1, 2]
julia> println(t2)
[1, 2, 3]
----


=== Glossary

array::
A sequence of values.
(((array)))

element::
One of the values in an array (or other sequence), also called items.
(((element)))

nested array::
An array that is an element of another array.
(((nested array)))

accumulator::
A variable used in a loop to add up or accumulate a result.
(((accumulator)))

augmented assignment::
A statement that updates the value of a variable using an operator like +=+.
(((augmented assignment)))

dot operator::
Binary operator that is applied element-by-element to arrays.
(((dot operator)))

dot syntax::
Syntax used to apply a function elementwise to any array.
(((dot syntax)))

reduce operation::
A processing pattern that traverses a sequence and accumulates the elements into a single result.
(((reduce operation)))

map::
A processing pattern that traverses a sequence and performs an operation on each element.
(((map)))

filter::
A processing pattern that traverses a sequence and selects the elements that satisfy some criterion.
(((filter)))

object::
Something a variable can refer to. An object has a type and a value.
(((object)))

equivalent::
Having the same value.
(((equivalent)))

identical::
Being the same object (which implies equivalence).
(((identical)))

reference::
The association between a variable and its value.
(((reference)))

aliasing::
A circumstance where two or more variables refer to the same object.
(((aliasing)))

optional arguments::
arguments that are not required.
(((optional arguments)))

delimiter::
A character or string used to indicate where a string should be split.
(((delimiter)))


=== Exercises

[source,@julia-eval chap10]
----
function nestedsum(t)
  total = 0
  for nested in t
    total += sum(nested)
  end
  total
end;

function cumulsum(t)
  total = 0
  res = []
  for x in t
    total += x
    push!(res, total)
  end
  res
end;

function interior(t)
  t[2:end-1]
end;

function interior!(t)
  popfirst!(t)
  pop!(t)
  nothing
end;

function issort(t)
  t == sort(t)
end;
----

[[ex10-1]]
==== Exercise 10-1

Write a function called +nestedsum+ that takes an array of arrays of integers and adds up the elements from all of the nested arrays. For example:
(((nestedsum)))((("function", "programmer-defined", "nestedsum", see="nestedsum")))

[source,@julia-repl-test chap10]
----
julia> t = [[1, 2], [3], [4, 5, 6]];

julia> nestedsum(t)
21
----

[[ex10-2]]
==== Exercise 10-2

Write a function called +cumulsum+ that takes an array of numbers and returns the cumulative sum; that is, a new array where the latexmath:[\(i\)]th element is the sum of the first latexmath:[\(i\)] elements from the original array. For example:
(((cumulsum)))((("function", "programmer-defined", "cumulsum", see="cumulsum")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3];

julia> print(cumulsum(t))
Any[1, 3, 6]
----

[[ex10-3]]
==== Exercise 10-3

Write a function called +interior+ that takes an array and returns a new array that contains all but the first and last elements. For example:
(((interior)))((("function", "programmer-defined", "interior", see="interior")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3, 4];

julia> print(interior(t))
[2, 3]
----

[[ex10-4]]
==== Exercise 10-4

Write a function called +interior!+ that takes an array, modifies it by removing the first and last elements, and returns +nothing+. For example:
(((interior!)))((("function", "programmer-defined", "interior!", see="interior!")))

[source,@julia-repl-test chap10]
----
julia> t = [1, 2, 3, 4];

julia> interior!(t)

julia> print(t)
[2, 3]
----

[[ex10-5]]
==== Exercise 10-5

Write a function called +issort+ that takes an array as a parameter and returns +true+ if the array is sorted in ascending order and +false+ otherwise. For example:
(((issort)))((("function", "programmer-defined", "issort", see="issort")))

[source,@julia-repl-test chap10]
----
julia> issort([1, 2, 2])
true
julia> issort(['b', 'a'])
false
----

[[ex10-6]]
==== Exercise 10-6

Two words are anagrams if you can rearrange the letters from one to spell the other. Write a function called +isanagram+ that takes two strings and returns +true+ if they are anagrams.
(((isanagram)))((("function", "programmer-defined", "isanagram", see="isanagram")))

[[ex10-7]]
==== Exercise 10-7

Write a function called +hasduplicates+ that takes an array and returns +true+ if there is any element that appears more than once. It should not modify the original array.
(((hasduplicates)))((("function", "programmer-defined", "hasduplicates", see="hasduplicates")))

[[ex10-8]]
==== Exercise 10-8

This exercise pertains to the so-called Birthday Paradox, which you can read about at https://en.wikipedia.org/wiki/Birthday_paradox.
(((Birthday paradox)))

If there are 23 students in your class, what are the chances that two of you have the same birthday? You can estimate this probability by generating random samples of 23 birthdays and checking for matches.
(((rand)))((("function", "Base", "rand", see="rand")))

[TIP]
====
You can generate random birthdays with +rand(1:365)+.
====

[[ex10-9]]
==== Exercise 10-9

Write a function that reads the file +palabras.txt+ and builds an array with one element per word. Write two versions of this function, one using +push!+ and the other using the idiom +t = [pass:[t...], x]+. Which one takes longer to run? Why?
(((push!)))

[[ex10-10]]
==== Exercise 10-10

To check whether a word is in the word array, you could use the +∈+ operator, but it would be slow because it searches through the words in order.

Because the words are in alphabetical order, we can speed things up with a bisection search (also known as binary search), which is similar to what you do when you look a word up in the dictionary. You start in the middle and check to see whether the word you are looking for comes before the word in the middle of the array. If so, you search the first half of the array the same way. Otherwise you search the second half.

Either way, you cut the remaining search space in half. If the word array has 113,809 words, it will take about 17 steps to find the word or conclude that it’s not there.

Write a function called +inbisect+ that takes a sorted array and a target value and returns +true+ if the word is in the array and +false+ if it’s not.
(((inbisect)))((("function", "programmer-defined", "inbisect", see="inbisect")))

[[ex10-11]]
==== Exercise 10-11

Two words are a “reverse pair” if each is the reverse of the other. Write a program +reversepairs+ that finds all the reverse pairs in the word array.
(((reversepairs)))((("function", "programmer-defined", "reversepairs", see="reversepairs")))

[[ex10-12]]
==== Exercise 10-12

Two words “interlock” if taking alternating letters from each forms a new word. For example, “shoe” and “cold” interlock to form “schooled”.
(((interlock)))

Credit: This exercise is inspired by an example at http://puzzlers.org.

. Write a program that finds all pairs of words that interlock.
+
[TIP]
====
Don’t enumerate all pairs!
====

. Can you find any words that are three-way interlocked; that is, every third letter forms a word, starting from the first, second or third?

