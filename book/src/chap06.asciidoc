[[chap06]]
== Funciones productivas

Muchas de las funciones de Julia que hemos utilizado, como las funciones matemáticas, producen valores de retorno. Todas las funciones que hemos escrito hasta ahora son nulas, es decir, tienen un efecto, como imprimir un valor, pero devuelven el valor +nothing+. En este capítulo aprenderemos a escribir funciones productivas.
(((fruitful function)))

=== Valores de retorno

Llamar a la función genera un valor de retorno, que generalmente asignamos a una variable o usamos como parte de una expresión.

[source,julia]
----
e = exp(1.0)
altura = radio * sin(radio)
----

Las funciones que hemos escrito hasta ahora son nulas. Coloquialmente hablando, no tienen valor de retorno; de manera formal, su valor de retorno es +nothing+. En este capítulo, (finalmente) vamos a escribir funciones productivas. El primer ejemplo es +area+, que devuelve el área de un círculo dado un radio:
(((nothing)))(((area)))((("function", "programmer-defined", "area", see="area")))

[source,@julia-setup]
----
function area(radio)
    a = π * radio^2
    return a
end
----
Hemos visto la sentencia +return+ antes, pero en una función productiva la sentencia +return+ incluye una expresión. Esta sentencia significa: "Retorne inmediatamente de esta función y use la siguiente expresión como valor de retorno". La expresión dada puede ser arbitrariamente complicada; así pues, podríamos haber escrito esta función más concisamente:
(((return statement)))

[source,@julia-setup]
----
function area(radio)
    π * radio^2
end
----

El valor devuelto por una función es el valor de la última expresión evaluada, que, por defecto, es la última expresión en el cuerpo de la definición de la función.

Por otro lado, las _variables temporales_ como +a+, y las sentencias +return+ explícitas pueden facilitar la depuración.
(((temporary variable)))

A veces es útil tener múltiples sentencias +return+, una en cada rama de una sentencia condicional:
(((absvalue)))((("function", "programmer-defined", "absvalue", see="absvalue")))

[source,@julia-setup chap06]
----
function valorabsoluto(x)
    if x < 0
        return -x
    else
        return x
    end
end
----

Dado que estas sentencias return están en una condicional alternativa, solo se ejecuta una.
(((alternative conditional)))

En cuanto se ejecuta una sentencia return, la función termina sin ejecutar ninguna de las sentencias siguientes. El código que aparezca después de la sentencia return, o en cualquier otro lugar al que el flujo de ejecución nunca llegará, se llama código muerto.
(((flow of execution)))(((dead code)))

En una función productiva, es una buena idea asegurarse que cualquier posible recorrido del programa llegue a una sentencia return. Por ejemplo:

[source,@julia-setup chap06]
----
function valorabsoluto(x)
    if x < 0
        return -x
    end
    if x > 0
        return x
    end
end
----

Esta versión no es correcta porque si +x+ es igual a 0, ninguna de las condiciones es verdadera, y la función termina sin alcanzar una sentencia return. Si el flujo de ejecución llega al final de la función, el valor de retorno es +nothing+, que claramente no es el valor absoluto de 0.

[source,@julia-repl-test chap06]
----
julia> show(valorabsoluto(0))
nothing
----

[TIP]
====
Julia tiene una función incorporada llamada +abs+ que calcula los valores absolutos.
(((abs)))((("function", "Base", "abs", see="abs")))
====

===== Ejercicio 6-1

Escriba la función +comparar+ que tome dos valores, +x+ y +y+, y que devuelva +1+ si +x > y+, +0+ si +x == y+, y +-1+ si +x < y+.

[[incremental_development]]
=== Desarrollo incremental

Conforme vaya escribiendo funciones más extensas puede empezar a dedicar más tiempo a la depuración.
(((debugging)))

Para lidiar con programas de complejidad creciente, se sugiere una técnica llamada desarrollo incremental. El objetivo del desarrollo incremental es evitar largas sesiones de depuración, adicionando y probando solamente pequeñas porciones de código cada vez.
(((incremental development)))

Por ejemplo, suponga que desea encontrar la distancia entre dos puntos dados por las coordenadas latexmath:[\(\left(x_1, y_1\right)\)] y latexmath:[\(\left(x_2, y_2\right)\)]. Por el teorema de Pitágoras, la distancia es:
(((Pythagorean theorem)))

[latexmath]
++++
\begin{equation}
{d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}}
\end{equation}
++++

El primer paso es considerar qué aspecto tendría la función distancia en Julia. En otras palabras, ¿cuáles son las entradas (parámetros) y cuál es la salida (valor de retorno)?

En este caso las entradas son los dos puntos, que podemos representar usando cuatro números. El valor devuelto es la distancia, que es un valor de punto flotante.

Escribamos una primera versión de la función:
(((distance)))((("function", "programmer-defined", "distance", see="distance")))

[source,@julia-setup chap06]
----
function distance(x₁, y₁, x₂, y₂)
    0.0
end
----

Obviamente esta versión de la función no calcula distancias; siempre devuelve cero. Pero es correcta sintácticamente y se ejecutará, lo que implica que la podemos probar antes de hacerla más compleja. Los números de subíndice están disponibles en la codificación de caracteres Unicode (*+\_1 TAB+*, *+\_2 TAB+*, etc.).
(((Unicode character)))

Para probar la nueva función, la llamamos con una muestra de valores:

[source,@julia-repl-test chap06]
----
distance(1, 2, 4, 6)
----

Se eligen estos valores de tal forma que la distancia horizontal sea igual a 3 y la distancia vertical sea igual a 4; de esa manera el resultado es 5 (la hipotenusa del triángulo 3-4-5). Cuando se comprueba una función, es útil conocer la respuesta correcta.

Hasta el momento hemos confirmado que la función es sintácticamente correcta, por lo que podemos empezar a agregar líneas de código. El paso lógico siguiente es encontrar las diferencias latexmath:[\(x_2 - x_1\)] y latexmath:[\(y_2 - y_1\)]. En la siguiente versión de la función almacenaremos estos valores en variables temporales y las mostraremos con el macro +@show+.
((("@show")))((("macro", "Base", "@show", see="@show")))

[source,@julia-setup]
----
function distancia(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    @show dx dy
    0.0
end
----

Si la función trabaja bien, las salidas deben ser +dx = 3+ y +dy = 4+. Si es así, sabemos que la función está obteniendo los parámetros correctos y realizando el primer cálculo correctamente. Si no, entonces sólo hay unas pocas líneas que revisar.

A continuación calculamos la suma de los cuadrados de +dx+ y +dy+:

[source,@julia-setup]
----
function distance(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    @show d²
    0.0
end
----

De nuevo queremos ejecutar el programa en esta etapa y comprobar la salida (que debería ser 25). Los números en superíndice también están disponibles (*+\^2 TAB+*). Finalmente, se puede usar +sqrt+ para calcular y devolver el resultado:
(((sqrt)))

[source,@julia-setup]
----
function distancia(x₁, y₁, x₂, y₂)
    dx = x₂ - x₁
    dy = y₂ - y₁
    d² = dx^2 + dy^2
    sqrt(d²)
end
----

Si esto funciona correctamente, habremos terminado. Si no, podríamos mostrar el valor de la variable resultado antes de la sentencia de retorno.

La versión final de la función no muestra nada cuando se ejecuta; sólo retorna un valor. Las sentencias print que escribimos son útiles para la depuración, pero una vez que el programa esté funcionando correctamente, se deben eliminar. El código eliminado se llama _andamiaje_ porque es útil para construir el programa pero no es parte del producto final.
(((scaffolding)))

Al principio, debería añadir solamente una o dos líneas de código cada vez. Conforme vaya ganando experiencia, puede que se encuentre escribiendo y depurando fragmentos mayores de código. Sin embargo, el proceso de desarrollo incremental puede ahorrarle mucho tiempo de depuración.

Los aspectos clave del proceso son:

. Inicie con un programa que funcione y hágale pequeños cambios incrementales. En cualquier momento, si hay un error, sabrá exactamente dónde está.

. Use variables temporales para guardar valores intermedios para que pueda mostrarlos y verificarlos.

. Una vez que el programa está funcionando, tal vez prefiera eliminar parte del andamiaje o consolidar múltiples sentencias en expresiones compuestas, pero sólo si eso no hace que el programa sea difícil de leer.

===== Ejercicio 6-2

Use la técnica de desarrollo incremental para escribir una función llamada +hipotenusa+ que retorne el largo de la hipotenusa de un triángulo rectángulo dado el largo de las otras dos aristas. Registre cada etapa del proceso de desarrollo.

=== Composición

Ahora, como usted esperaría, se puede llamar a una función desde otra. Como ejemplo, escribiremos una función que tome dos puntos, el centro del círculo y un punto del perímetro, y calcule el área del círculo.
(((composition)))

Suponga que el punto central está almacenado en las variables +xc+ y +yc+, y que el punto del perímetro lo está en +xp+ y +yp+. El primer paso es hallar el radio del círculo, que es la distancia entre los dos puntos. Hemos escrito la función distancia que realiza esta tarea:

[source,julia]
----
radio = distancia(xc, yc, xp, yp)
----

El siguiente paso es encontrar el área del círculo usando este radio. De nuevo usaremos una de las funciones definidas previamente:

[source,julia]
----
resultado = area(radio)
----

Envolviendo todo en una función, obtenemos:
(((circlearea)))((("function", "programmer-defined", "circlearea", see="circlearea")))

[source,@julia-setup]
----
function areacirculo(xc, yc, xp, yp)
    radio = distancia(xc, yc, xp, yp)
    resultado = area(radio)
    return resultado
end
----

Las variables temporales +radio+ y +resultado+ son útiles para el desarrollo y la depuración, pero una vez que el programa está funcionando, podemos hacerlo más conciso componiendo las llamadas a función:
(((temporary variable)))

[source,@julia-setup]
----
function areacirculo(xc, yc, xp, yp)
    area(distancia(xc, yc, xp, yp))
end
----


[[boolean_functions]]
=== Funciones Booleanas

Las funciones pueden devolver valores booleanos, lo que a menudo es conveniente para ocultar complicadas comprobaciones dentro de funciones. Por ejemplo:
(((boolean function)))(((isdivisible)))((("function", "programmer-defined", "isdivisible", see="isdivisible")))

[source,@julia-setup chap06]
----
function esdivisible(x, y)
    if x % y == 0
        return true
    else
        return false
    end
end
----
Es común dar a las funciones booleanas nombres que suenan como preguntas que tienen como respuesta un si ó un no; es_divisible devuelve +true+ o +false+ para indicar si +x+ es o no divisible por +y+.

Por ejemplo:

[source,@julia-repl-test chap06]
----
julia> esdivisible(6, 4)
false
julia> esdivisible(6, 3)
true
----

El resultado del operador +==+ es booleano, por lo tanto podemos escribir la función de una manera más concisa devolviendo el resultado directamente:
(((==)))

[source,@julia-setup]
----
function esdivisible(x, y)
    x % y == 0
end
----

Las funciones booleanas se usan a menudo en las sentencias condicionales:
(((conditional statement)))

[source,julia]
----
if esdivisible(x, y)
    println("x es divisible por y")
end
----

Puede parecer tentador escribir algo como:

[source,julia]
----
if esdivisible(x, y) == true
    println("x es divisible por y")
end
----

Pero la comparación extra con +true+ es innecesaria.

===== Ejercicio 6-3

Escriba la función +entremedio(x,y,z)+ que devuelva +true+ si +x ≤ y ≤ z+, o +false+ en otro caso.

=== Más recursividad

Solo hemos cubierto una pequeña parte de Julia, pero le puede interesar saber que esta parte ya es un lenguaje de programación _completo_, lo que significa que cualquier cómputo puede expresarse en este lenguaje. Cualquier programa que se haya escrito podría reescribirse usando solo lo que ha aprendido hasta ahora (en realidad, necesitaría algunos comandos para controlar dispositivos como el mouse, discos, etc., pero eso es todo).
(((recursion)))(((complete programming language)))((("programming language", "complete", see="complete programming language")))

Probar esa afirmación es un ejercicio no trivial realizado por primera vez por Alan Turing, uno de los primeros científicos de la computación (algunos argumentarían que era matemático, pero muchos de los primeros científicos informáticos comenzaron como matemáticos). En consecuencia, esto se conoce como la Tesis de Turing. Para una discusión más completa (y precisa) de la Tesis de Turing, se recomienda el libro de Michael Sipser _Introducción a la Teoría de la Computación_.
(((Turing, Alan)))(((Turing thesis)))

To give you an idea of what you can do with the tools you have learned so far, we’ll evaluate a few recursively defined mathematical functions. A recursive definition is similar to a circular definition, in the sense that the definition contains a reference to the thing being defined. A truly circular definition is not very useful:
(((recursive definition)))(((circular definition)))

vorpal::
An adjective used to describe something that is vorpal.

If you saw that definition in the dictionary, you might be annoyed. On the other hand, if you looked up the definition of the factorial function, denoted with the symbol latexmath:[\(!\)], you might get something like this:
(((factorial function)))

[latexmath]
++++
\begin{equation}
{n! = 
\begin{cases}
  1& \textrm{if}\  n = 0 \\
  n (n-1)!& \textrm{if}\  n > 0
\end{cases}}
\end{equation}
++++
This definition says that the factorial of 0 is 1, and the factorial of any other value, latexmath:[\(n\)], is latexmath:[\(n\)] multiplied by the factorial of latexmath:[\(n-1\)].

So latexmath:[\(3!\)] is 3 times latexmath:[\(2!\)], which is 2 times latexmath:[\(1!\)], which is 1 times latexmath:[\(0!\)]. Putting it all together, latexmath:[\(3!\)] equals 3 times 2 times 1 times 1, which is 6.

If you can write a recursive definition of something, you can write a Julia program to evaluate it. The first step is to decide what the parameters should be. In this case it should be clear that factorial takes an integer:
(((fact)))((("function", "programmer-defined", "fact", see="fact")))

[source,@julia-setup]
----
function fact(n) end
----

If the argument happens to be +0+, all we have to do is return +1+:

[source,@julia-setup]
----
function fact(n)
    if n == 0
        return 1
    end
end
----

Otherwise, and this is the interesting part, we have to make a recursive call to find the factorial of +n-1+ and then multiply it by +n+:

[source,@julia-setup]
----
function fact(n)
    if n == 0
        return 1
    else
        recurse = fact(n-1)
        result = n * recurse
        return result
    end
end
----

The flow of execution for this program is similar to the flow of +countdown+ in <<recursion>>. If we call +fact+ with the value +3+:
(((flow of execution)))

[small]
--
Since +3+ is not +0+, we take the second branch and calculate the factorial of +n-1+ ...

pass:[&#8193;]Since +2+ is not +0+, we take the second branch and calculate the factorial of +n-1+ ...

pass:[&#8193;&#8193;]Since +1+ is not +0+, we take the second branch and calculate the factorial of +n-1+ ...

pass:[&#8193;&#8193;&#8193;]Since +0+ equals +0+, we take the first branch and return +1+ without making any pass:[<br/>&#8193;&#8193;&#8193;&#8193;]more recursive calls.

pass:[&#8193;&#8193;]The return value, +1+, is multiplied by +n+, which is +1+, and the +result+ is returned.

pass:[&#8193;]The return value, +1+, is multiplied by +n+, which is +2+, and the +result+ is returned.

The return value +2+ is multiplied by +n+, which is +3+, and the result, +6+, becomes the return value of the function call that started the whole process.
--

[[fig06-1]]
.Stack diagram
image::images/fig61.svg[]


<<fig06-1>> shows what the stack diagram looks like for this sequence of function calls.
(((stack diagram)))

The return values are shown being passed back up the stack. In each frame, the return value is the value of +result+, which is the product of +n+ and +recurse+.

In the last frame, the local variables +recurse+ and +result+ do not exist, because the branch that creates them does not run.

[TIP]
====
Julia provides the function +factorial+ to calculate the factorial of an integer number.
(((factorial)))((("function", "Base", "factorial", see="factorial")))
====


=== Leap of Faith

Following the flow of execution is one way to read programs, but it can quickly become overwhelming. An alternative is what I call the “leap of faith”. When you come to a function call, instead of following the flow of execution, you _assume_ that the function works correctly and returns the right result.
(((leap of faith)))

In fact, you are already practicing this leap of faith when you use built-in functions. When you call +cos+ or +exp+, you don’t examine the bodies of those functions. You just assume that they work because the people who wrote the built-in functions were good programmers.

The same is true when you call one of your own functions. For example, in <<boolean_functions>>, we wrote a function called +isdivisible+ that determines whether one number is divisible by another. Once we have convinced ourselves that this function is correct—by examining the code and testing—we can use the function without looking at the body again.

The same is true of recursive programs. When you get to the recursive call, instead of following the flow of execution, you should assume that the recursive call works (returns the correct result) and then ask yourself, “Assuming that I can find the factorial of latexmath:[\(n-1\)], can I compute the factorial of latexmath:[\(n\)]?” It is clear that you can, by multiplying by latexmath:[\(n\)].

Of course, it’s a bit strange to assume that the function works correctly when you haven’t finished writing it, but that’s why it’s called a leap of faith!

[[one_more_example]]
=== One More Example

After factorial, the most common example of a recursively defined mathematical function is fibonacci, which has the following definition (see https://en.wikipedia.org/wiki/Fibonacci_number):
(((fibonnaci function)))

[latexmath]
++++
\begin{equation}
{fib(n) =
\begin{cases}
    0& \textrm{if}\  n = 0 \\
    1& \textrm{if}\  n = 1 \\
    fib(n-1) + fib(n-2)& \textrm{if}\  n > 1 
\end{cases}}
\end{equation}
++++

Translated into Julia, it looks like this:
(((fib)))((("function", "programmer-defined", "fib", see="fib")))

[source,@julia-setup chap06]
----
function fib(n)
    if n == 0
        return 0
    elseif n == 1
        return 1
    else
        return fib(n-1) + fib(n-2)
    end
end
----

If you try to follow the flow of execution here, even for fairly small values of +n+, your head explodes. But according to the leap of faith, if you assume that the two recursive calls work correctly, then it is clear that you get the right result by adding them together.


=== Checking Types

What happens if we call +fact+ and give it +1.5+ as an argument?
(((StackOverflowError)))

[source,jlcon]
----
julia> fact(1.5)
ERROR: StackOverflowError:
Stacktrace:
 [1] fact(::Float64) at ./REPL[3]:2
----

It looks like an infinite recursion. How can that be? The function has a base case—when +n == 0+. But if +n+ is not an integer, we can _miss_ the base case and recurse forever.
(((infinite recursion)))

In the first recursive call, the value of +n+ is +0.5+. In the next, it is +-0.5+. From there, it gets smaller (more negative), but it will never be +0+.

We have two choices. We can try to generalize the factorial function to work with floating-point numbers, or we can make +fact+ check the type of its argument. The first option is called the gamma function and it’s a little beyond the scope of this book. So we’ll go for the second.
(((gamma function)))

We can use the built-in operator +isa+ to verify the type of the argument. While we’re at it, we can also make sure the argument is positive:
(((isa)))(((fact)))

[source,@julia-setup chap06]
----
function fact(n)
    if !(n isa Int64)
        error("Factorial is only defined for integers.")
    elseif n < 0
        error("Factorial is not defined for negative integers.")
    elseif n == 0
        return 1
    else
        return n * fact(n-1)
    end
end
----

The first base case handles nonintegers; the second handles negative integers. In both cases, the program prints an error message and returns +nothing+ to indicate that something went wrong:

[source,@julia-repl-test chap06]
----
julia> fact("fred")
ERROR: Factorial is only defined for integers.
julia> fact(-2)
ERROR: Factorial is not defined for negative integers.
----

If we get past both checks, we know that +n+ is positive or zero, so we can prove that the recursion terminates.

This program demonstrates a pattern sometimes called a _guardian_. The first two conditionals act as guardians, protecting the code that follows from values that might cause an error. The guardians make it possible to prove the correctness of the code.
(((guardian)))

In <<catching_exceptions>> we will see a more flexible alternative to printing an error message: raising an exception.

[[deb06]]
=== Debugging

Breaking a large program into smaller functions creates natural checkpoints for debugging. If a function is not working, there are three possibilities to consider:
(((debugging)))

* There is something wrong with the arguments the function is getting; a precondition is violated.
(((precondition)))

* There is something wrong with the function; a postcondition is violated.
(((postcondition)))

* There is something wrong with the return value or the way it is being used.

To rule out the first possibility, you can add a print statement at the beginning of the function and display the values of the parameters (and maybe their types). Or you can write code that checks the preconditions explicitly.

If the parameters look good, add a print statement before each return statement and display the return value. If possible, check the result by hand. Consider calling the function with values that make it easy to check the result (as in <<incremental_development>>).

If the function seems to be working, look at the function call to make sure the return value is being used correctly (or used at all!).

Adding print statements at the beginning and end of a function can help make the flow of execution more visible. For example, here is a version of +fact+ with print statements:
(((fact)))(((flow of execution)))(((print statement)))

[source,@julia-setup chap06]
----
function fact(n)
    space = " " ^ (4 * n)
    println(space, "factorial ", n)
    if n == 0
        println(space, "returning 1")
        return 1
    else
        recurse = fact(n-1)
        result = n * recurse
        println(space, "returning ", result)
        return result
    end
end
----

+space+ is a string of space characters that controls the indentation of the output:

[source,@julia-repl chap06]
----
fact(4)
----

If you are confused about the flow of execution, this kind of output can be helpful. It takes some time to develop effective scaffolding, but a little bit of scaffolding can save a lot of debugging.


=== Glossary

temporary variable::
A variable used to store an intermediate value in a complex calculation.
(((temporary variable)))

dead code::
Part of a program that can never run, often because it appears after a return statement.
(((dead code)))

incremental development::
A program development plan intended to avoid debugging by adding and testing only a small amount of code at a time.
(((incremental development)))(((program development plan)))

scaffolding::
Code that is used during program development but is not part of the final version.
(((scaffolding)))

guardian::
A programming pattern that uses a conditional statement to check for and handle circumstances that might cause an error.
(((guardian)))


=== Exercises

[[ex06-1]]
===== Exercise 6-4

Draw a stack diagram for the following program. What does the program print?

[source,@julia-setup]
----
function b(z)
    prod = a(z, z)
    println(z, " ", prod)
    prod
end

function a(x, y)
    x = x + 1
    x * y
end

function c(x, y, z)
    total = x + y + z
    square = b(total)^2
    square
end

x = 1
y = x + 1
println(c(x, y+3, x+y))
----

[[ex06-2]]
===== Exercise 6-5

The Ackermann function, latexmath:[\(A(m, n)\)], is defined:
(((Ackermann function)))

[latexmath]
++++
\begin{equation}
{A(m, n) =
\begin{cases}
              n+1& \textrm{if}\ m = 0 \\
        A(m-1, 1)& \textrm{if}\ m > 0\ \textrm{and}\ n = 0 \\
A(m-1, A(m, n-1))& \textrm{if}\ m > 0\ \textrm{and}\ n > 0.
\end{cases}}
\end{equation}
++++
See https://en.wikipedia.org/wiki/Ackermann_function. Write a function named +ack+ that evaluates the Ackermann function. Use your function to evaluate +ack(3, 4)+, which should be 125. What happens for larger values of +m+ and +n+?
(((ack)))((("function", "programmer-defined", "ack", see="ack")))

[[ex06-3]]
===== Exercise 6-6

A palindrome is a word that is spelled the same backward and forward, like “noon” and “redivider”. Recursively, a word is a palindrome if the first and last letters are the same and the middle is a palindrome.
(((palindrome)))

The following are functions that take a string argument and return the first, last, and middle letters:
(((first)))((("function", "programmer-defined", "first", see="first")))(((last)))((("function", "programmer-defined", "last", see="last")))(((middle)))((("function", "programmer-defined", "middle", see="middle")))

[source,@julia-setup]
----
function first(word)
    first = firstindex(word)
    word[first]
end

function last(word)
    last = lastindex(word)
    word[last]
end

function middle(word)
    first = firstindex(word)
    last = lastindex(word)
    word[nextind(word, first) : prevind(word, last)]
end
----

We’ll see how they work in <<chap08>>

. Test these functions out. What happens if you call middle with a string with two letters? One letter? What about the empty string, which is written +""+ and contains no letters?

. Write a function called +ispalindrome+ that takes a string argument and returns +true+ if it is a palindrome and +false+ otherwise. Remember that you can use the built-in function +length+ to check the length of a string.
(((ispalindrome)))((("function", "programmer-defined", "ispalindrome", see="ispalindrome")))(((length)))

[[ex06-4]]
===== Exercise 6-7

A number, latexmath:[\(a\)], is a power of latexmath:[\(b\)] if it is divisible by latexmath:[\(b\)] and latexmath:[\(\frac{a}{b}\)] is a power of latexmath:[\(b\)]. Write a function called +ispower+ that takes parameters +a+ and +b+ and returns +true+ if +a+ is a power of +b+.
(((ispower)))((("function", "programmer-defined", "ispower", see="ispower")))

[TIP]
====
You will have to think about the base case.
====

[[ex06-5]]
===== Exercise 6-8

The greatest common divisor (GCD) of latexmath:[\(a\)] and latexmath:[\(b\)] is the largest number that divides both of them with no remainder.

One way to find the GCD of two numbers is based on the observation that if latexmath:[\(r\)] is the remainder when latexmath:[\(a\)] is divided by latexmath:[\(b\)], then +gcd(a, b) = gcd(b, r)+. As a base case, we can use +gcd(a, 0) = a+.

Write a function called +gcd+ that takes parameters +a+ and +b+ and returns their greatest common divisor.
(((gcd)))((("function", "programmer-defined", "gcd", see="gcd")))

Credit: This exercise is based on an example from Abelson and Sussman’s _Structure and Interpretation of Computer Programs_.

