[[chap18]]
== Subtipos

En el capítulo anterior se presentó el dispatch múltiple y los métodos polimórficos. Al no especificar el tipo de los argumentos de un método, este se puede invocar con argumentos de cualquier tipo. Ahora veremos cómo especificar un subconjunto de tipos permitidos en las especificaciones de un método.

En este capítulo se explica el concepto de subtipo usando tipos que representan cartas, mazos de cartas y manos de póker.

Si nunca has jugado póker, puedes leer sobre él en https://es.wikipedia.org/wiki/P%C3%B3quer, aunque no es necesario, pues te diré todo lo que necesitas saber para los ejercicios.


=== Naipes

Hay cincuenta y dos naipes en una baraja inglesa, cada uno de los cuales pertenece a uno de los cuatro palos y tiene un valor. Los palos son Picas (+♠+), Corazones (+♥+), Diamantes (+♦+) y Tréboles (+♣+). Los valores son As (A), 2, 3, 4, 5, 6, 7, 8, 9, 10, Jota (J), Reina (Q) y Rey (K). Dependiendo del tipo de juego, el valor del As puede ser mayor que al Rey o inferior al 2.

Si queremos definir un nuevo objeto para representar un naipe, es obvio qué atributos debería tener: valor y palo. Lo que no es tan obvio es el tipo que se debe dar a estos atributos. Una opción es usar cadenas de caracteres que contengan palabras como +"Picas"+ para los palos y +"Reina"+ para los valores. Un problema de esta implementación es que no sería fácil comparar naipes para ver cuál tiene mayor valor o palo.

Una alternativa es usar números enteros para _codificar_ los valores y palos. En este contexto, "codificar" significa definir una asociación entre números y palos, o entre números y valores. Este tipo de codificación no está relacionada con cifrar o traducir a un código secreto (eso sería "cifrado").
(((encode)))

Por ejemplo, esta tabla muestra una correspondencia entre palos y códigos (números) enteros:

* +♠+  latexmath:[\(\mapsto\)]  4

* +♥+  latexmath:[\(\mapsto\)]  3

* +♦+  latexmath:[\(\mapsto\)]  2

* +♣+  latexmath:[\(\mapsto\)]  1

Este código facilita la comparación de naipes, pues los palos más altos se asignan a los números más altos, por lo tanto podemos comparar los palos al comparar sus códigos.

Estamos usando el símbolo latexmath:[\(\mapsto\)] para dejar en claro que estas asignaciones no son parte de Julia. Forman parte del diseño del programa, pero no aparecen explícitamente en el código.

La definición de estructura de +Naipe+ se ve así:
(((Card)))((("type", "programmer-defined", "Card", see="Card")))

[source,@julia-setup chap18]
----
struct Naipe
    palo :: Int64
    valor :: Int64
    function Naipe(suit::Int64, rank::Int64)
        @assert(1 ≤ palo ≤ 4, "el palo no está entre 1 y 4")
        @assert(1 ≤ valor ≤ 13, "el valor no está entre 1 y 13")
        new(palo, valor)
    end
end
----

Para crear un +Naipe+, se debe llamar a +Naipe+ con el palo y el valor de la carta deseado:

[source,@julia-repl-test chap18]
----
julia> reina_de_diamantes = Naipe(2, 12)
Naipe(2, 12)
----


=== Variables Globales

Para poder imprimir los objetos +Naipe+ de una manera fácil de leer, necesitamos establecer una correspondencia entre los códigos enteros, y sus correspondientes palos y valores. Una manera natural de hacer esto es con matrices de cadenas: 

[source,@julia-setup chap18]
----
const nombres_palo = ["♣", "♦", "♥", "♠"]
const nombres_valor = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]
----

Las variables +nombres_palo + y +nombres_valor+ son variables globales. La declaración +const+ significa que la variable solo se puede asignar una vez. Esto resuelve el problema de rendimiento de las variables globales.
(((global statement)))(((const)))((("keyword", "const", see="const")))

Ahora podemos implementar un método +show+ apropiado:
(((show)))

[source,@julia-setup chap18]
----
function Base.show(io::IO, naipe::Naipe)
    print(io, nombres_valor[naipe.valor], nombres_palo[naipe.palo])
end
----

La expresión +nombres_valor[naipe.valor]+ significa "use el atributo +valor+ del objeto +naipe+ como índice en la matriz +nombres_valor+, y seleccione la cadena correspondiente".

Con los métodos que tenemos hasta ahora, podemos crear e imprimir naipes:

[source,@julia-repl-test chap18]
----
julia> Naipe(3, 11)
J♥
----


=== Comparación de naipes

Para los tipos integrados, existen operadores relacionales (+<+, +>+, +==+, etc.) que comparan valores y determinan cuándo uno es mayor, menor, o igual a otro. Para los tipos definidos por el usuario, podemos sustituir el comportamiento de los operadores internos si proporcionamos un método llamado: +<+.

El orden correcto de las tarjetas no es obvio. Por ejemplo, ¿cuál es mejor, el 3 de Tréboles o el 2 de Diamantes? Uno tiene un valor mayor, pero el otro tiene un palo mayor. Para hacer que los naipes sean comparables, se debe decidir qué es más importante: valor o palo.

La respuesta puede depender del tipo de juego, pero para simplificar las cosas, haremos la elección arbitraria de que el palo es más importante, por lo que todas las espadas superan a todos los diamantes, y así sucesivamente.

Con esa decisión tomada, podemos escribir +<+:

[source,@julia-setup chap18]
----
import Base.<

function <(c1::Naipe, c2::Naipe)
    (c1.palo, c1.rvalor) < (c2.palo, c2.valor)
end
----

==== Ejercicio 18-1

Escriba un método +<+ para objetos +Hora+. Puede usar comparación de tuplas, o comparación de enteros.


=== Prueba unitaria


Una _prueba unitaria_ permite verificar el correcto funcionamiento de su código comparando los resultados obtenidos con los esperados. Esto puede ser útil para verificar que su código funciona correctamente después de haberlo modificado, y también es una forma de predefinir el comportamiento correcto de su código durante el desarrollo.
(((unit testing)))

Se pueden realizar pruebas unitarias simples con las macros +@test+:
(((Test)))((("module", "Test", see="Test")))(((@test)))((("macro", "Test", "@test", see="@test"))) 

[source,@julia-repl-test chap18]
----
julia> using Test

julia> @test Naipe(1, 4) < Naipe(2, 4)
Test Passed
julia> @test Naipe(1, 3) < Naipe(1, 4)
Test Passed
----

+@test+ devuelve +"Test Passed"+ ("Prueba aprobada") si la expresión que sigue es +true+, y +"Test Failed"+ ("Prueba fallida") si es +false+, y +"Error Result"+ ("Resultado de error") si no se pudo evaluar.


=== Mazos

Ahora que ya tenemos Naipes, el próximo paso es definir Mazos. Como un mazo está compuesto de naipes, naturalmente cada Mazo contendrá una matriz de naipes como atributo.

A continuación se muestra una definición para +Mazo+. El constructor crea el atributo naipes y genera el conjunto estándar de cincuenta
y dos naipes:
(((Deck)))((("type", "programmer-defined", "Deck", see="Deck")))

[source,@julia-setup chap18]
----
struct Mazo
    naipes :: Array{Naipe, 1}
end

function Mazo()
    mazo = Mazo(Card[])
    for palo in 1:4
        for valor in 1:13
            push!(mazo.naipes, Naipe(palo, valor))
        end
    end
    deck
end
----

La forma más fácil de poblar el mazo es mediante un bucle anidado. El bucle exterior enumera los palos desde 1 hasta 4. El bucle interior enumera los valores desde 1 hasta 13. Cada iteración crea un nuevo +Naipe+ con el palo y valor actual, y lo agrega a +mazo.naipes+.

Este es un método +show+ para +Mazo+:

[source,@julia-setup chap18]
----
function Base.show(io::IO, mazo::Mazo)
    for naipe in mazo.naipes
        print(io, naipe, " ")
    end
    println()
end
----

Así es como se ve el resultado:

[source,@julia-repl-test chap18]
----
julia> Mazo()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠
----


=== Añadir, Eliminar, Barajar y Ordenar

Para repartir los naipes, nos gustaría tener una función que elimine un naipe del mazo y lo devuelva. La función +pop!+ proporciona una forma conveniente de realizar esto:
(((pop!)))

[source,@julia-setup chap18]
----
function Base.pop!(mazo::Mazo)
    pop!(mazo.naipes)
end
----

Como +pop!+ elimina el último naipe en la matriz, estamos repartiendo desde el extremo inferior del mazo.

Para añadir un naipe, podemos usar la función +push!+:
(((push!)))

[source,@julia-setup chap18]
----
function Base.push!(mazo::Mazo, naipe::Naipe)
    push!(mazo.naipes, naipe)
    deck
end
----

Un método como este, que usa otro método sin hacer mucho más se llama _enchapado_. La metáfora proviene de la carpintería, donde un enchapado es una capa fina de madera de alta calidad que se pega a la superficie de una pieza de madera de baja calidad para mejorar su apariencia.
(((veneer)))

En este caso, +push!+ es un método "fino" que expresa una operación de matriz adecuada para los mazos. Mejora la apariencia o interfaz, de la implementación.

También podemos escribir un método llamado +shuffle!+ (barajar en inglés) Usando la función +Random.shuffle!+:
(((Random)))((("module", "Random", see="Random")))(((shuffle!)))((("function", "Random", "shuffle!", see="shuffle!")))

[source,@julia-setup chap18]
----
using Random

function Random.shuffle!(mazo::Mazo)
    shuffle!(mazo.naipes)
    mazo
end
----

==== Ejercicio 18-2

Escriba una función llamada +sort!+ (ordenar en inglés) que use la función +sort!+ para ordenar las cartas en un Mazo. +sort!+ usa el método +isless+ que definimos para determinar el orden.
(((sort!)))


=== Tipos Abstractos y Subtipos

Queremos que un tipo represente una "mano", es decir, los naipes que tiene un jugador. Una mano es similar a un mazo: ambos están compuestos de un conjunto de naipes, y ambos requieren de operaciones tales como agregar y eliminar una carta.

Una mano es diferente de un mazo en ciertos aspectos; podemos querer realizar ciertas operaciones sobre una mano que no tienen sentido sobre un mazo. Por ejemplo, en el poker querríamos comparar una mano con otra para ver quién gana. En bridge, necesitamos calcular el puntaje de la mano para así poder hacer la subasta.

Por lo tanto, necesitamos una forma de agrupar los _tipos concretos_ que están relacionados. En Julia, esto se hace definiendo un _abstract type_ (tipo abstracto en inglés) que sea padre de +Mazo+ y +Mano+. A esto se le llama _subtipo_.
(((concrete type)))(((abstract type)))(((subtyping)))

Llamemos a este tipo abstracto +ConjuntoDeCartas+:
(((CardSet)))((("type", "programmer-defined", "CardSet", see="CardSet")))

[source,@julia-eval chap18a]
----
struct Naipe
    palo :: Int64
    valor :: Int64
    function Naipe(palo::Int64, valor::Int64)
        @assert(1 ≤ palo ≤ 4, "palo está entre 1 y 4")
        @assert(1 ≤ valor ≤ 13, "valor es entre 1 y 13")
        new(palo, valor)
    end
end;
----

[source,@julia-setup chap18a]
----
abstract type ConjuntoDeCartasCardSet end
----

Se puede crear un nuevo tipo abstracto con la palabra reservada +abstract type+. También se puede especificar un tipo "padre" opcional colocando después del nombre, el símbolo +<:+ seguido del nombre de un tipo abstracto ya existente.
(((abstract type)))((("keyword", "abstract type", see="abstract type")))(((type)))

Cuando no se proporciona un _supertipo_, el supertipo por defecto es +Any+, es decir, un tipo abstracto predefinido del que todos los objetos son instancias y del que todos los tipos son _subtipos_.
(((supertype)))(((subtype)))

Ahora podemos expresar que +Mazo+ es un descendiente de +ConjuntoDeCartas+:
We can now express that +Deck+ is a descendant of +CardSet+:

[source,@julia-setup chap18a]
----
struct Mazo <: ConjuntoDeCartas
    naipes :: Array{Naipe, 1}
end

function Mazo()
    mazo = Mazo(Naipe[])
    for palo in 1:4
        for valor in 1:13
            push!(mazo.naipes, Naipe(palo, valor))
        end
    end
    deck
end
----

[source,@julia-eval chap18a]
----
using Random

const nombres_palo = ["♣", "♦", "♥", "♠"];
const nombres_valor = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];

function Base.show(io::IO, naipe::Naipe)
    print(io, nombres_valor[naipe.valor], nombres_palo[naipe.palo])
end

function Random.shuffle!(mazo::Mazo)
    shuffle!(mazo.naipes)
    mazo
end
----

The operator +isa+ checks whether an object is of a given type:
(((isa)))((("operator", "Base", "isa", see="isa")))

[source,@julia-repl-test chap18a]
----
julia> deck = Deck();

julia> deck isa CardSet
true
----

A hand is also a kind of +CardSet+:
(((Hand)))((("type", "programmer-defined", "Hand", see="Hand")))

[source,@julia-setup chap18a]
----
struct Hand <: CardSet
    cards :: Array{Card, 1}
    label :: String
end

function Hand(label::String="")
    Hand(Card[], label)
end
----

Instead of populating the hand with 52 new cards, the constructor for +Hand+ initializes +cards+ with an empty array. An optional argument can be passed to the constructor giving a label to the +Hand+.

[source,@julia-repl-test chap18a]
----
julia> hand = Hand("new hand")
Hand(Card[], "new hand")
----


=== Abstract Types and Functions

We can now express the common operations between +Deck+ and +Hand+ as functions having as argument +CardSet+:
(((show)))(((pop!)))(((push!)))

[source,@julia-setup chap18a]
----
function Base.show(io::IO, cs::CardSet)
    for card in cs.cards
        print(io, card, " ")
    end
end

function Base.pop!(cs::CardSet)
    pop!(cs.cards)
end

function Base.push!(cs::CardSet, card::Card)
    push!(cs.cards, card)
    nothing
end
----

We can use +pop!+ and +push!+ to deal a card:

[source,@julia-repl chap18a]
----
deck = Deck()
shuffle!(deck)
card = pop!(deck)
push!(hand, card)
----

A natural next step is to encapsulate this code in a function called +move!+:
(((move!)))((("function", "programmer-defined", "move!", see="move!")))

[source,@julia-setup chap18a]
----
function move!(cs1::CardSet, cs2::CardSet, n::Int)
    @assert 1 ≤ n ≤ length(cs1.cards)
    for i in 1:n
        card = pop!(cs1)
        push!(cs2, card)
    end
    nothing
end
----

+move!+ takes three arguments, two +Cardset+ objects and the number of cards to deal. It modifies both +Cardset+ objects, and returns +nothing+.

In some games, cards are moved from one hand to another, or from a hand back to the deck. You can use +move!+ for any of these operations: +cs1+ and +cs2+ can be either a +Deck+ or a +Hand+.


=== Type Diagrams

So far we have seen stack diagrams, which show the state of a program, and object diagrams, which show the attributes of an object and their values. These diagrams represent a snapshot in the execution of a program, so they change as the program runs.

They are also highly detailed; for some purposes, too detailed. A _type diagram_ is a more abstract representation of the structure of a program. Instead of showing individual objects, it shows types and the relationships between them.
(((type diagram)))((("diagram", "type", see="type diagram")))

There are several kinds of relationship between types:

* Objects of a concrete type might contain references to objects of another type. For example, each Rectangle contains a reference to a Point, and each Deck contains references to an array of Cards. This kind of relationship is called _HAS-A_, as in, “a Rectangle has a Point”.
(((HAS-A)))

* A concrete type can have an abstract type as a supertype. This relationship is called _IS-A_, as in, “a Hand is a kind of a CardSet.”
(((IS-A)))

* One type might depend on another in the sense that objects of one type take objects of the second type as parameters, or use objects of the second type as part of a computation. This kind of relationship is called a _dependency_.
(((dependency)))

[[fig18-1]]
.Type diagram
image::images/fig181.svg[]

The arrow with a hollow triangle head represents an IS-A relationship; in this case it indicates that Hand has as supertype CardSet.

The standard arrow head represents a HAS-A relationship; in this case a Deck has references to Card objects.

The star (+pass:[*]+) near the arrow head is a _multiplicity_; it indicates how many Cards a Deck has. A multiplicity can be a simple number, like +52+, a range, +like 5:7+ or a star, which indicates that a Deck can have any number of Cards.
(((multiplicity)))

There are no dependencies in this diagram. They would normally be shown with a dashed arrow. Or if there are a lot of dependencies, they are sometimes omitted.

A more detailed diagram might show that a Deck actually contains an array of Cards, but built-in types like array and dictionnaries are usually not included in type diagrams.

[[interactive]]
=== Debugging

Subtyping can make debugging difficult because when you call a function with an object as argument, it might be hard to figure out which method will be invoked.

Suppose you are writing a function that works with +Hand+ objects. You would like it to work with all kinds of +Hand+s, like +PokerHand+s, +BridgeHand+s, etc. If you invoke a method like +sort!+, you might get the one defined for an abstract type +Hand+, but if a method +sort!+ with as argument any of the subtypes exists, you’ll get that version instead. This behavior is usually a good thing, but it can be confusing.

[source,@julia-setup chap18a]
----
function Base.sort!(hand::Hand)
    sort!(hand.cards)
end
----

Any time you are unsure about the flow of execution through your program, the simplest solution is to add print statements at the beginning of the relevant methods. If +shuffle!+ prints a message that says something like +Running shuffle! Deck+, then as the program runs it traces the flow of execution.

As better alternative, you can also use the +@which+ macro:
(((InteractiveUtils)))((("module", "InteractiveUtils", see="InteractiveUtils")))(((@which)))((("macro", "InteractiveUtils", "@which", see="@which")))

[source,jlcon]
----
julia> @which sort!(hand)
sort!(hand::Hand) in Main at REPL[5]:1
----

So the +sort!+ method for +hand+ is the one having as argument an object of type +Hand+.

Here’s a design suggestion: when you override a method, the interface of the new method should be the same as the old. It should take the same parameters, return the same type, and obey the same preconditions and postconditions. If you follow this rule, you will find that any function designed to work with an instance of a supertype, like a +CardSet+, will also work with instances of its subtypes +Deck+ and +Hand+.

If you violate this rule, which is called the “Liskov substitution principle”, your code will collapse like (sorry) a house of cards.
(((Liskov substitution principle)))

The function +supertype+ can be used to find the direct supertype of a type.
(((supertype)))((("function", "Base", "supertype", see="supertype")))

[source,@julia-repl-test chap18a]
----
julia> supertype(Deck)
CardSet
----


=== Data Encapsulation

The previous chapters demonstrate a development plan we might call “type-oriented design”. We identified objects we needed—like +Point+, +Rectangle+ and +MyTime+—and defined structs to represent them. In each case there is an obvious correspondence between the object and some entity in the real world (or at least a mathematical world).
(((type-oriented design)))

But sometimes it is less obvious what objects you need and how they should interact. In that case you need a different development plan. In the same way that we discovered function interfaces by encapsulation and generalization, we can discover type interfaces by _data encapsulation_.
(((data encapsulation)))

Markov analysis, from <<markov_analysis>>, provides a good example. If you download code from https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/src/solutions/chap13.jl, you’ll see that it uses two global variables—+suffixes+ and +prefix+—that are read and written from several functions.

[source,@julia-setup]
----
suffixes = Dict()
prefix = []
----

Because these variables are global, we can only run one analysis at a time. If we read two texts, their prefixes and suffixes would be added to the same data structures (which makes for some interesting generated text).

To run multiple analyses, and keep them separate, we can encapsulate the state of each analysis in an object. Here’s what that looks like:
(((Markov)))((("type", "programmer-defined", "Markov", see="Markov")))

[source,@julia-setup chap18b]
----
struct Markov
    order :: Int64
    suffixes :: Dict{Tuple{String,Vararg{String}}, Array{String, 1}}
    prefix :: Array{String, 1}
end

function Markov(order::Int64=2)
    new(order, Dict{Tuple{String,Vararg{String}}, Array{String, 1}}(), Array{String, 1}())
end
----

Next, we transform the functions into methods. For example, here’s +processword+:
(((processword)))((("function", "programmer-defined", "processword", see="processword")))

[source,@julia-setup chap18b]
----
function processword(markov::Markov, word::String)
    if length(markov.prefix) < markov.order
        push!(markov.prefix, word)
        return
    end
    get!(markov.suffixes, (markov.prefix...,), Array{String, 1}())
    push!(markov.suffixes[(markov.prefix...,)], word)
    popfirst!(markov.prefix)
    push!(markov.prefix, word)
end
----

Transforming a program like this—changing the design without changing the behavior—is another example of refactoring (see <<refactoring>>).
(((refactoring)))(((program development plan)))

This example suggests a development plan for designing types:

* Start by writing functions that read and write global variables (when necessary).

* Once you get the program working, look for associations between global variables and the functions that use them.

* Encapsulate related variables as fields of a struct.

* Transform the associated functions into methods with as argument objects of the new type.

==== Exercise 18-3

Download Markov code from https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/src/solutions/chap13.jl, and follow the steps described above to encapsulate the global variables as attributes of a new struct called +Markov+.


=== Glossary

encode::
To represent one set of values using another set of values by constructing a mapping between them.
(((encode)))

unit testing::
Standardized way to test the correctness of code.
(((unit testing)))

veneer::
A method or function that provides a different interface to another function without doing much computation.
(((veneer)))

subtyping::
The ability to define a hierarchy of related types.
(((subtyping)))

abstract type::
A type that can act as a parent for another type.
(((abstract type)))

concrete type::
A type that can be constructed.
(((concrete type)))

subtype::
A type that has as parent an abstract type.
(((subtype)))

supertype::
An abstract type that is the parent of another type.
(((supertype)))

IS-A relationship::
A relationship between a subtype and its supertype.
(((IS-A relationship)))

HAS-A relationship::
A relationship between two types where instances of one type contain references to instances of the other.
(((HAS-A relationship)))

dependency::
A relationship between two types where instances of one type use instances of the other type, but do not store them as fields.
(((dependency)))

type diagram::
A diagram that shows the types in a program and the relationships between them.
(((type diagram)))

multiplicity::
A notation in a type diagram that shows, for a HAS-A relationship, how many references there are to instances of another class.
(((multiplicity)))

data encapsulation::
A program development plan that involves a prototype using global variables and a final version that makes the global variables into instance fields.
(((data encapsulation)))


=== Exercises

[[ex18-1]]
==== Exercise 18-4

For the following program, draw a type diagram that shows these types and the relationships among them.

[source,julia]
----
abstract type PingPongParent end

struct Ping <: PingPongParent
    pong :: PingPongParent
end

struct Pong <: PingPongParent
    pings :: Array{Ping, 1}
    function Pong(pings=Array{Ping, 1}())
        new(pings)
    end
end

function addping(pong::Pong, ping::Ping)
    push!(pong.pings, ping)
    nothing
end

pong = Pong()
ping = Ping(pong)
addping(pong, ping)
----

[[ex18-2]]
==== Exercise 18-5

Write a method called +deal!+ that takes three parameters, a +Deck+, the number of hands and the number of cards per hand. It should create the appropriate number of +Hand+ objects, deal the appropriate number of cards per hand, and return an array of +Hand+s.
(((deal!)))((("function", "programmer-defined", "deal!", see="deal!")))

[[ex18-3]]
==== Exercise 18-6

The following are the possible hands in poker, in increasing order of value and decreasing order of probability:

pair::
two cards with the same rank

two pair::
two pairs of cards with the same rank

three of a kind::
three cards with the same rank

straight::
five cards with ranks in sequence (aces can be high or low, so Ace-2-3-4-5 is a straight and so is 10-Jack-Queen-King-Ace, but Queen-King-Ace-2-3 is not.)

flush::
five cards with the same suit

full house::
three cards with one rank, two cards with another

four of a kind::
four cards with the same rank

straight flush::
five cards in sequence (as defined above) and with the same suit

The goal of this exercise is to estimate the probability of drawing these various hands.

. Add methods named +haspair+, +hastwopair+, etc. that return +true+ or +false+ according to whether or not the hand meets the relevant criteria. Your code should work correctly for “hands” that contain any number of cards (although 5 and 7 are the most common sizes).
(((haspair)))((("function", "programmer-defined", "haspair", see="haspair")))(((hastwopair)))((("function", "programmer-defined", "hastwopair", see="hastwopair")))

. Write a method named +classify+ that figures out the highest-value classification for a hand and sets the +label+ field accordingly. For example, a 7-card hand might contain a flush and a pair; it should be labeled “flush”.
(((classify)))((("function", "programmer-defined", "classify", see="classify")))

. When you are convinced that your classification methods are working, the next step is to estimate the probabilities of the various hands. Write a function that shuffles a deck of cards, divides it into hands, classifies the hands, and counts the number of times various classifications appear.

. Print a table of the classifications and their probabilities. Run your program with larger and larger numbers of hands until the output values converge to a reasonable degree of accuracy. Compare your results to the values at https://en.wikipedia.org/wiki/Hand_rankings.

