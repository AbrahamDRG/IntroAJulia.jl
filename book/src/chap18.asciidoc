[[chap18]]
== Subtipos

En el capítulo anterior se presentó el dispatch múltiple y los métodos polimórficos. Al no especificar el tipo de los argumentos de un método, este se puede invocar con argumentos de cualquier tipo. Ahora veremos cómo especificar un subconjunto de tipos permitidos en las especificaciones de un método.

En este capítulo se explica el concepto de subtipo usando tipos que representan cartas, mazos de cartas y manos de póker.

Si nunca has jugado póker, puedes leer sobre él en https://es.wikipedia.org/wiki/P%C3%B3quer, aunque no es necesario, pues explicaremos todo lo necesario para los ejercicios.


=== Naipes

Hay cincuenta y dos naipes en una baraja inglesa, cada uno de los cuales pertenece a uno de los cuatro palos y tiene un valor. Los palos son Picas (+♠+), Corazones (+♥+), Diamantes (+♦+) y Tréboles (+♣+). Los valores son As (A), 2, 3, 4, 5, 6, 7, 8, 9, 10, Jota (J), Reina (Q) y Rey (K). Dependiendo del tipo de juego, el valor del As puede ser mayor que al Rey o inferior al 2.

Si queremos definir un nuevo objeto para representar un naipe, es obvio qué atributos debería tener: valor y palo. Lo que no es tan obvio es el tipo que se debe dar a estos atributos. Una opción es usar cadenas de caracteres que contengan palabras como +"Picas"+ para los palos y +"Reina"+ para los valores. Un problema de esta implementación es que no sería fácil comparar naipes para ver cuál tiene mayor valor o palo.

Una alternativa es usar números enteros para _codificar_ los valores y palos. En este contexto, "codificar" significa definir una asociación entre números y palos, o entre números y valores. Este tipo de codificación no está relacionada con cifrar o traducir a un código secreto (eso sería "cifrado").
(((encode)))

Por ejemplo, esta tabla muestra una correspondencia entre palos y códigos (números) enteros:

* +♠+  latexmath:[\(\mapsto\)]  4

* +♥+  latexmath:[\(\mapsto\)]  3

* +♦+  latexmath:[\(\mapsto\)]  2

* +♣+  latexmath:[\(\mapsto\)]  1

Este código facilita la comparación de naipes; los palos más altos se asignan a los números más altos, por lo tanto podemos comparar los palos al comparar sus códigos.

Estamos usando el símbolo latexmath:[\(\mapsto\)] para dejar en claro que estas asignaciones no son parte de Julia. Forman parte del diseño del programa, pero no aparecen explícitamente en el código.

La definición de estructura de +Naipe+ se ve así:
(((Card)))((("type", "programmer-defined", "Card", see="Card")))

[source,@julia-setup chap18]
----
struct Naipe
    palo :: Int64
    valor :: Int64
    function Naipe(palo::Int64, valor::Int64)
        @assert(1 ≤ palo ≤ 4, "el palo no está entre 1 y 4")
        @assert(1 ≤ valor ≤ 13, "el valor no está entre 1 y 13")
        new(palo, valor)
    end
end
----

Para crear un +Naipe+, se debe llamar a +Naipe+ con el palo y el valor del naipe deseado:

[source,@julia-repl-test chap18]
----
julia> reina_de_diamantes = Naipe(2, 12)
Naipe(2, 12)
----


=== Variables Globales

Para poder imprimir los objetos +Naipe+ de una manera que sea fácil de leer, necesitamos establecer una correspondencia entre los códigos enteros, y sus correspondientes palos y valores. Una manera natural de hacer esto es con matrices de cadenas: 

[source,@julia-setup chap18]
----
const nombres_palo = ["♣", "♦", "♥", "♠"]
const nombres_valor = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]
----

Las variables +nombres_palo+ y +nombres_valor+ son variables globales. La declaración +const+ significa que la variable solo se puede asignar una vez. Esto resuelve el problema de rendimiento de las variables globales.
(((global statement)))(((const)))((("keyword", "const", see="const")))

Ahora podemos implementar un método +show+ apropiado:
(((show)))

[source,@julia-setup chap18]
----
function Base.show(io::IO, naipe::Naipe)
    print(io, nombres_valor[naipe.valor], nombres_palo[naipe.palo])
end
----

La expresión +nombres_valor[naipe.valor]+ significa "use el atributo +valor+ del objeto +naipe+ como índice en la matriz +nombres_valor+, y seleccione la cadena correspondiente".

Con los métodos que tenemos hasta ahora, podemos crear e imprimir naipes:

[source,@julia-repl-test chap18]
----
julia> Naipe(3, 11)
J♥
----


=== Comparación de naipes

Para los tipos integrados, existen operadores relacionales (+<+, +>+, +==+, etc.) que comparan valores y determinan cuándo uno es mayor, menor, o igual a otro. Para los tipos definidos por el usuario, podemos sustituir el comportamiento de los operadores internos si proporcionamos un método llamado: +<+.

El orden correcto de las tarjetas no es obvio. Por ejemplo, ¿cuál es mejor, el 3 de Tréboles o el 2 de Diamantes? Uno tiene un valor mayor, pero el otro tiene un palo mayor. Para hacer que los naipes sean comparables, se debe decidir qué es más importante: valor o palo.

La respuesta puede depender del tipo de juego, pero para simplificar las cosas, haremos la elección arbitraria de que el palo es más importante, por lo que todas las espadas superan a todos los diamantes, y así sucesivamente.

Con esa decisión tomada, podemos escribir +<+:

[source,@julia-setup chap18]
----
import Base.<

function <(c1::Naipe, c2::Naipe)
    (c1.palo, c1.rvalor) < (c2.palo, c2.valor)
end
----

==== Ejercicio 18-1

Escriba un método +<+ para objetos +Hora+. Puede usar comparación de tuplas, o comparación de enteros.


=== Prueba unitaria


Una _prueba unitaria_ permite verificar el correcto funcionamiento de su código comparando los resultados obtenidos con los esperados. Esto puede ser útil para verificar que su código funciona correctamente después de haberlo modificado, y también es una forma de predefinir el comportamiento correcto de su código durante el desarrollo.
(((unit testing)))

Se pueden realizar pruebas unitarias simples con las macros +@test+:
(((Test)))((("module", "Test", see="Test")))(((@test)))((("macro", "Test", "@test", see="@test"))) 

[source,@julia-repl-test chap18]
----
julia> using Test

julia> @test Naipe(1, 4) < Naipe(2, 4)
Test Passed
julia> @test Naipe(1, 3) < Naipe(1, 4)
Test Passed
----

+@test+ devuelve +"Test Passed"+ ("Prueba aprobada") si la expresión que sigue es +true+, +"Test Failed"+ ("Prueba fallida") si es +false+, y +"Error Result"+ ("Resultado de error") si no se pudo evaluar.


=== Mazos

Ahora que ya tenemos Naipes, el próximo paso es definir Mazos. Como un mazo está compuesto de naipes, naturalmente cada Mazo contendrá una matriz de naipes como atributo.

A continuación se muestra una definición para +Mazo+. El constructor crea el atributo naipes y genera el conjunto estándar de cincuenta
y dos naipes:
(((Deck)))((("type", "programmer-defined", "Deck", see="Deck")))

[source,@julia-setup chap18]
----
struct Mazo
    naipes :: Array{Naipe, 1}
end

function Mazo()
    mazo = Mazo(Card[])
    for palo in 1:4
        for valor in 1:13
            push!(mazo.naipes, Naipe(palo, valor))
        end
    end
    deck
end
----

La forma más fácil de poblar el mazo es mediante un bucle anidado. El bucle exterior enumera los palos desde 1 hasta 4. El bucle interior enumera los valores desde 1 hasta 13. Cada iteración crea un nuevo +Naipe+ con el palo y valor actual, y lo agrega a +mazo.naipes+.

Este es un método +show+ para +Mazo+:

[source,@julia-setup chap18]
----
function Base.show(io::IO, mazo::Mazo)
    for naipe in mazo.naipes
        print(io, naipe, " ")
    end
    println()
end
----

Así es como se ve el resultado:

[source,@julia-repl-test chap18]
----
julia> Mazo()
A♣ 2♣ 3♣ 4♣ 5♣ 6♣ 7♣ 8♣ 9♣ 10♣ J♣ Q♣ K♣ A♦ 2♦ 3♦ 4♦ 5♦ 6♦ 7♦ 8♦ 9♦ 10♦ J♦ Q♦ K♦ A♥ 2♥ 3♥ 4♥ 5♥ 6♥ 7♥ 8♥ 9♥ 10♥ J♥ Q♥ K♥ A♠ 2♠ 3♠ 4♠ 5♠ 6♠ 7♠ 8♠ 9♠ 10♠ J♠ Q♠ K♠
----


=== Añadir, Eliminar, Barajar y Ordenar

Para repartir los naipes, nos gustaría tener una función que elimine un naipe del mazo y lo devuelva. La función +pop!+ proporciona una forma conveniente de realizar esto:
(((pop!)))

[source,@julia-setup chap18]
----
function Base.pop!(mazo::Mazo)
    pop!(mazo.naipes)
end
----

Como +pop!+ elimina el último naipe en la matriz, estamos repartiendo desde el extremo inferior del mazo.

Para añadir un naipe, podemos usar la función +push!+:
(((push!)))

[source,@julia-setup chap18]
----
function Base.push!(mazo::Mazo, naipe::Naipe)
    push!(mazo.naipes, naipe)
    deck
end
----

Un método como este, que usa otro método sin hacer mucho más se llama _enchapado_. La metáfora proviene de la carpintería, donde un enchapado es una capa fina de madera de alta calidad que se pega a la superficie de una pieza de madera de baja calidad para mejorar su apariencia.
(((veneer)))

En este caso, +push!+ es un método "fino" que expresa una operación de matriz adecuada para los mazos. Mejora la apariencia o interfaz, de la implementación.

También podemos escribir un método llamado +shuffle!+ (barajar en inglés) Usando la función +Random.shuffle!+:
(((Random)))((("module", "Random", see="Random")))(((shuffle!)))((("function", "Random", "shuffle!", see="shuffle!")))

[source,@julia-setup chap18]
----
using Random

function Random.shuffle!(mazo::Mazo)
    shuffle!(mazo.naipes)
    mazo
end
----

==== Ejercicio 18-2

Escriba una función llamada +sort!+ (ordenar en inglés) que use la función +sort!+ para ordenar las cartas en un Mazo. +sort!+ usa el método +isless+ que definimos para determinar el orden.
(((sort!)))


=== Tipos Abstractos y Subtipos

Queremos que un tipo represente una "mano", es decir, los naipes que tiene un jugador. Una mano es similar a un mazo: ambos están compuestos de un conjunto de naipes, y ambos requieren de operaciones tales como agregar y eliminar una carta.

Una mano es diferente de un mazo en ciertos aspectos; podemos querer realizar ciertas operaciones sobre una mano que no tienen sentido sobre un mazo. Por ejemplo, en el poker querríamos comparar una mano con otra para ver quién gana. En bridge, necesitamos calcular el puntaje de la mano para así poder hacer la subasta.

Por lo tanto, necesitamos una forma de agrupar los _tipos concretos_ que están relacionados. En Julia, esto se hace definiendo un _abstract type_ (tipo abstracto en inglés) que sea padre de +Mazo+ y +Mano+. A esto se le llama _subtipo_.
(((concrete type)))(((abstract type)))(((subtyping)))

Llamemos a este tipo abstracto +ConjuntoDeCartas+:
(((CardSet)))((("type", "programmer-defined", "CardSet", see="CardSet")))

[source,@julia-eval chap18a]
----
struct Naipe
    palo :: Int64
    valor :: Int64
    function Naipe(palo::Int64, valor::Int64)
        @assert(1 ≤ palo ≤ 4, "palo está entre 1 y 4")
        @assert(1 ≤ valor ≤ 13, "valor es entre 1 y 13")
        new(palo, valor)
    end
end;
----

[source,@julia-setup chap18a]
----
abstract type ConjuntoDeCartasCardSet end
----

Se puede crear un nuevo tipo abstracto con la palabra reservada +abstract type+. También se puede especificar un tipo "padre" opcional colocando después del nombre, el símbolo +<:+ seguido del nombre de un tipo abstracto ya existente.
(((abstract type)))((("keyword", "abstract type", see="abstract type")))(((type)))

Cuando no se proporciona un _supertipo_, el supertipo por defecto es +Any+, es decir, un tipo abstracto predefinido del que todos los objetos son instancias y del que todos los tipos son _subtipos_.
(((supertype)))(((subtype)))

Ahora podemos expresar que +Mazo+ es un hijo de +ConjuntoDeCartas+:

[source,@julia-setup chap18a]
----
struct Mazo <: ConjuntoDeCartas
    naipes :: Array{Naipe, 1}
end

function Mazo()
    mazo = Mazo(Naipe[])
    for palo in 1:4
        for valor in 1:13
            push!(mazo.naipes, Naipe(palo, valor))
        end
    end
    deck
end
----

[source,@julia-eval chap18a]
----
using Random

const nombres_palo = ["♣", "♦", "♥", "♠"];
const nombres_valor = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];

function Base.show(io::IO, naipe::Naipe)
    print(io, nombres_valor[naipe.valor], nombres_palo[naipe.palo])
end

function Random.shuffle!(mazo::Mazo)
    shuffle!(mazo.naipes)
    mazo
end
----

El operador +isa+ comprueba si un objeto es de un tipo dado:
(((isa)))((("operator", "Base", "isa", see="isa")))

[source,@julia-repl-test chap18a]
----
julia> mazo = Mazo();

julia> mazo isa ConjuntoDeCartas
true
----

Una mano también es una especie de +ConjuntoDeCartas+:
A hand is also a kind of +CardSet+:
(((Hand)))((("type", "programmer-defined", "Hand", see="Hand")))

[source,@julia-setup chap18a]
----
struct Mano <: ConjuntoDeCartas
    naipes :: Array{Naipe, 1}
    etiqueta :: String
end

function Mano(etiqueta::String="")
    Mano(Naipe[], etiqueta)
end
----

En lugar de llenar la mano con 52 cartas nuevas, el constructor de +Mano+ inicializa +naipes+ a una matriz vacía. Se puede pasar una etiqueta de la +Mano+ como argumento opcional al constructor.

[source,@julia-repl-test chap18a]
----
julia> mano = Mano("nueva mano")
Mano(Naipe[], "nueva mano")
----


=== Tipos Abstractos y Funciones

Ahora podemos expresar las operaciones que tienen en común +Mazo+ y +Mano+, al ser funciones que tienen como argumento a +ConjuntoDeCartas+:
(((show)))(((pop!)))(((push!)))

[source,@julia-setup chap18a]
----
function Base.show(io::IO, cdc::ConjuntoDeCartas)
    for naipe in cdc.naipes
        print(io, naipe, " ")
    end
end

function Base.pop!(cdc::ConjuntoDeCartas)
    pop!(cdc.naipes)
end

function Base.push!(cdc::ConjuntoDeCartas, naipe::Naipe)
    push!(cdc.naipes, naipe)
    nothing
end
----

Podemos usar +pop!+ y +push!+ para repartir una carta:

[source,@julia-repl chap18a]
----
mazo = Mazo()
shuffle!(mazo)
naipe = pop!(mazo)
push!(mano, naipe)
----

A continuación, encapsularemos este código en una función llamada +mover!+:
(((move!)))((("function", "programmer-defined", "move!", see="move!")))

[source,@julia-setup chap18a]
----
function mover!(cdc1::ConjuntoDeCartas, cdc2::ConjuntoDeCartas, n::Int)
    @assert 1 ≤ n ≤ length(cs1.naipes)
    for i in 1:n
        naipe = pop!(cs1)
        push!(cs2, naipe)
    end
    nothing
end
----

+mover!+ toma tres argumentos: dos objetos +ConjuntoDeCartas+ y el número de cartas a repartir. Modifica ambos objetos +ConjuntoDeCartas+, y devuelve +nothing+. 

En algunos juegos, las cartas se mueven de una mano a otra, o de una mano a la baraja. Puedes usar +mover!+ para cualquiera de estas operaciones: +cdc1+ y +cdc2+ pueden ser un +Mazo+ o una +Mano+.


=== Diagramas de tipo

Hasta ahora hemos visto diagramas de pila; que muestran el estado de un programa, y diagramas de objetos; que muestran los atributos de un objeto y sus valores. Estos diagramas son como una foto sacada durante la ejecución de un programa, por lo que cambian a medida que se ejecuta el programa.

También son muy detallados; en algunos casos demasiado detallados. Un _diagrama de tipo_ es una representación más abstracta de la estructura de un programa. En vez de mostrar objetos individuales, muestra los tipos y las relaciones entre ellos.
(((type diagram)))((("diagram", "type", see="type diagram")))

Hay varias formas de relación entre tipos:

* Los objetos de un tipo concreto pueden contener referencias a objetos de otro tipo. Por ejemplo, cada Rectangulo contiene una referencia a un Punto, y cada Mazo contiene referencias a un conjunto de Naipes. Este tipo de relación se llama _TIENE-UN_, como por ejemplo "un Rectángulo tiene un Punto".
(((HAS-A)))

* Un tipo concreto puede tener un tipo abstracto como supertipo. Esta relación se llama _ES-UN_, como por ejemplo "una Mano es un ConjuntoDeCartas".
(((IS-A)))

* Un tipo puede depender de otro en el sentido de que los objetos de un tipo toman objetos del segundo tipo como parámetros, o usan objetos del segundo tipo como parte de un cálculo. Este tipo de relación se llama _dependencia_.
(((dependency)))

[[fig18-1]]
.Type diagram
image::images/fig181.svg[]

Cada una de las flechas superiores representa una relación ES-UN; en este caso, indica que Mano tiene como supertipo a ConjuntoDeCartas.

Cada una de las flechas inferiores representa una relación TIENE-UN; en este caso, un Mazo tiene referencias a objetos Naipe.

El asterisco (+pass:[*]+) cerca de la flecha es una _multiplicidad_; indica cuántos Naipes tiene un Mazo. Una multiplicidad puede ser un número simple; como +52+, un rango; + como 5:7+ o un asterisco; lo cual indica que un Mazo puede tener cualquier número de Cartas.
(((multiplicity)))

No hay dependencias en este diagrama. Normalmente se mostrarían con una flecha achurada. Si hay muchas dependencias, a veces se omiten.

Un diagrama más detallado podría mostrar que un Mazo en realidad contiene una matriz de Naipes, pero los tipos integrados como matrices y diccionarios generalmente no se incluyen en los diagramas de tipos.

[[interactive]]
=== Depuración

Utilizar subtipos puede dificultar la depuración ya que al llamar a una función con un objeto como argumento, puede ser difícil determinar qué método se invocará.

Supongamos que estamos escribiendo una función que funciona con objetos +Mano+. Nos gustaría que funcionara con todo tipo de +Mano+s, como +ManoDePoker+, +ManoDeBridge+, etc. Si invoca un método como +sort!+, podrías obtener el método definido para un tipo abstracto +Mano+, pero si existe un método +sort!+ que tenga como argumento cualquiera de los subtipos, obtendrás esa versión. Este comportamiento suele ser algo bueno, pero puede ser confuso.

[source,@julia-setup chap18a]
----
function Base.sort!(mano::Mano)
    sort!(mano.naipes)
end
----

Si no estás seguro del flujo de ejecución de su programa, la solución más simple es agregar sentencias de impresión al inicio de los métodos más relevantes. Si +shuffle!+ imprimiera un mensaje como +Ejecutando shuffle! Mazo+, a medida que el programa se ejecutara, sería posible rastrear el flujo de ejecución.

Una mejor alternativa es la macro +@which+:
(((InteractiveUtils)))((("module", "InteractiveUtils", see="InteractiveUtils")))(((@which)))((("macro", "InteractiveUtils", "@which", see="@which")))

[source,jlcon]
----
julia> @which sort!(mano)
sort!(mano::Mano) in Main at REPL[5]:1
----

Entonces, el método +sort!+ de +mano+ es el que tiene como argumento un objeto de tipo +Mano+.

Una sugerencia para el diseño del programa: cuando anula un método, la interfaz del nuevo método debería ser la misma que la anterior. Debería tomar los mismos parámetros, devolver el mismo tipo y obedecer las mismas condiciones previas y posteriores. Si sigues esta regla, cualquier función diseñada para funcionar con una instancia de un supertipo, como un +ConjuntoDeCartas+, también funcionará con instancias de sus subtipos +Mazo+ y +Mano+.

Si viola esta regla, llamada "principio de sustitución de Liskov", su código colapsará como un castillo de naipes (jeje).
(((Liskov substitution principle)))

La función +supertype+ permite encontrar el supertipo directo de un tipo.
(((supertype)))((("function", "Base", "supertype", see="supertype")))

[source,@julia-repl-test chap18a]
----
julia> supertype(Mazo)
ConjuntoDeCartas
----


=== Data Encapsulation

The previous chapters demonstrate a development plan we might call “type-oriented design”. We identified objects we needed—like +Point+, +Rectangle+ and +MyTime+—and defined structs to represent them. In each case there is an obvious correspondence between the object and some entity in the real world (or at least a mathematical world).
(((type-oriented design)))

But sometimes it is less obvious what objects you need and how they should interact. In that case you need a different development plan. In the same way that we discovered function interfaces by encapsulation and generalization, we can discover type interfaces by _data encapsulation_.
(((data encapsulation)))

Markov analysis, from <<markov_analysis>>, provides a good example. If you download code from https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/src/solutions/chap13.jl, you’ll see that it uses two global variables—+suffixes+ and +prefix+—that are read and written from several functions.

[source,@julia-setup]
----
suffixes = Dict()
prefix = []
----

Because these variables are global, we can only run one analysis at a time. If we read two texts, their prefixes and suffixes would be added to the same data structures (which makes for some interesting generated text).

To run multiple analyses, and keep them separate, we can encapsulate the state of each analysis in an object. Here’s what that looks like:
(((Markov)))((("type", "programmer-defined", "Markov", see="Markov")))

[source,@julia-setup chap18b]
----
struct Markov
    order :: Int64
    suffixes :: Dict{Tuple{String,Vararg{String}}, Array{String, 1}}
    prefix :: Array{String, 1}
end

function Markov(order::Int64=2)
    new(order, Dict{Tuple{String,Vararg{String}}, Array{String, 1}}(), Array{String, 1}())
end
----

Next, we transform the functions into methods. For example, here’s +processword+:
(((processword)))((("function", "programmer-defined", "processword", see="processword")))

[source,@julia-setup chap18b]
----
function processword(markov::Markov, word::String)
    if length(markov.prefix) < markov.order
        push!(markov.prefix, word)
        return
    end
    get!(markov.suffixes, (markov.prefix...,), Array{String, 1}())
    push!(markov.suffixes[(markov.prefix...,)], word)
    popfirst!(markov.prefix)
    push!(markov.prefix, word)
end
----

Transforming a program like this—changing the design without changing the behavior—is another example of refactoring (see <<refactoring>>).
(((refactoring)))(((program development plan)))

This example suggests a development plan for designing types:

* Start by writing functions that read and write global variables (when necessary).

* Once you get the program working, look for associations between global variables and the functions that use them.

* Encapsulate related variables as fields of a struct.

* Transform the associated functions into methods with as argument objects of the new type.

==== Exercise 18-3

Download Markov code from https://github.com/PiensaEnJulia/PiensaEnJulia.jl/blob/master/src/solutions/chap13.jl, and follow the steps described above to encapsulate the global variables as attributes of a new struct called +Markov+.


=== Glossary

encode::
To represent one set of values using another set of values by constructing a mapping between them.
(((encode)))

unit testing::
Standardized way to test the correctness of code.
(((unit testing)))

veneer::
A method or function that provides a different interface to another function without doing much computation.
(((veneer)))

subtyping::
The ability to define a hierarchy of related types.
(((subtyping)))

abstract type::
A type that can act as a parent for another type.
(((abstract type)))

concrete type::
A type that can be constructed.
(((concrete type)))

subtype::
A type that has as parent an abstract type.
(((subtype)))

supertype::
An abstract type that is the parent of another type.
(((supertype)))

IS-A relationship::
A relationship between a subtype and its supertype.
(((IS-A relationship)))

HAS-A relationship::
A relationship between two types where instances of one type contain references to instances of the other.
(((HAS-A relationship)))

dependency::
A relationship between two types where instances of one type use instances of the other type, but do not store them as fields.
(((dependency)))

type diagram::
A diagram that shows the types in a program and the relationships between them.
(((type diagram)))

multiplicity::
A notation in a type diagram that shows, for a HAS-A relationship, how many references there are to instances of another class.
(((multiplicity)))

data encapsulation::
A program development plan that involves a prototype using global variables and a final version that makes the global variables into instance fields.
(((data encapsulation)))


=== Exercises

[[ex18-1]]
==== Exercise 18-4

For the following program, draw a type diagram that shows these types and the relationships among them.

[source,julia]
----
abstract type PingPongParent end

struct Ping <: PingPongParent
    pong :: PingPongParent
end

struct Pong <: PingPongParent
    pings :: Array{Ping, 1}
    function Pong(pings=Array{Ping, 1}())
        new(pings)
    end
end

function addping(pong::Pong, ping::Ping)
    push!(pong.pings, ping)
    nothing
end

pong = Pong()
ping = Ping(pong)
addping(pong, ping)
----

[[ex18-2]]
==== Exercise 18-5

Write a method called +deal!+ that takes three parameters, a +Deck+, the number of hands and the number of cards per hand. It should create the appropriate number of +Hand+ objects, deal the appropriate number of cards per hand, and return an array of +Hand+s.
(((deal!)))((("function", "programmer-defined", "deal!", see="deal!")))

[[ex18-3]]
==== Exercise 18-6

The following are the possible hands in poker, in increasing order of value and decreasing order of probability:

pair::
two cards with the same rank

two pair::
two pairs of cards with the same rank

three of a kind::
three cards with the same rank

straight::
five cards with ranks in sequence (aces can be high or low, so Ace-2-3-4-5 is a straight and so is 10-Jack-Queen-King-Ace, but Queen-King-Ace-2-3 is not.)

flush::
five cards with the same suit

full house::
three cards with one rank, two cards with another

four of a kind::
four cards with the same rank

straight flush::
five cards in sequence (as defined above) and with the same suit

The goal of this exercise is to estimate the probability of drawing these various hands.

. Add methods named +haspair+, +hastwopair+, etc. that return +true+ or +false+ according to whether or not the hand meets the relevant criteria. Your code should work correctly for “hands” that contain any number of cards (although 5 and 7 are the most common sizes).
(((haspair)))((("function", "programmer-defined", "haspair", see="haspair")))(((hastwopair)))((("function", "programmer-defined", "hastwopair", see="hastwopair")))

. Write a method named +classify+ that figures out the highest-value classification for a hand and sets the +label+ field accordingly. For example, a 7-card hand might contain a flush and a pair; it should be labeled “flush”.
(((classify)))((("function", "programmer-defined", "classify", see="classify")))

. When you are convinced that your classification methods are working, the next step is to estimate the probabilities of the various hands. Write a function that shuffles a deck of cards, divides it into hands, classifies the hands, and counts the number of times various classifications appear.

. Print a table of the classifications and their probabilities. Run your program with larger and larger numbers of hands until the output values converge to a reasonable degree of accuracy. Compare your results to the values at https://en.wikipedia.org/wiki/Hand_rankings.

